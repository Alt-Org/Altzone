<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Quantum.Unity</name>
    </assembly>
    <members>
        <member name="T:Quantum.QuantumMonoBehaviour">
            <summary>
            Base class for all Quantum MonoBehaviours.
            </summary>
        </member>
        <member name="T:Quantum.ReflectionUtils">
            <summary>
            Quantum reflection utilities.
            </summary>
        </member>
        <member name="F:Quantum.ReflectionUtils.DefaultBindingFlags">
            <summary>
            The default binding flags.
            </summary>
        </member>
        <member name="T:Quantum.ReflectionUtils.TypeHierarchyComparer">
            <summary>
            Comparer for types for sorting.
            </summary>
        </member>
        <member name="F:Quantum.ReflectionUtils.TypeHierarchyComparer.Instance">
            <summary>
            An instance to the comparer.
            </summary>
        </member>
        <member name="T:Quantum.QuantumUnityHostProfiler">
            <summary>
            Profiler implementation for Unity.
            </summary>
        </member>
        <member name="M:Quantum.QuantumUnityHostProfiler.CreateMarker(System.String)">
            <inheritdoc cref="M:Quantum.Profiling.IHostProfiler.CreateMarker(System.String)"/>
        </member>
        <member name="M:Quantum.QuantumUnityHostProfiler.StartMarker(Quantum.Profiling.HostProfilerMarker)">
            <inheritdoc cref="M:Quantum.Profiling.IHostProfiler.StartMarker(Quantum.Profiling.HostProfilerMarker)"/>
        </member>
        <member name="M:Quantum.QuantumUnityHostProfiler.EndMarker(Quantum.Profiling.HostProfilerMarker)">
            <inheritdoc cref="M:Quantum.Profiling.IHostProfiler.EndMarker(Quantum.Profiling.HostProfilerMarker)"/>
        </member>
        <member name="M:Quantum.QuantumUnityHostProfiler.StartNamedMarker(System.String)">
            <inheritdoc cref="M:Quantum.Profiling.IHostProfiler.StartNamedMarker(System.String)"/>
        </member>
        <member name="M:Quantum.QuantumUnityHostProfiler.EndLastNamedMarker">
            <inheritdoc cref="M:Quantum.Profiling.IHostProfiler.EndLastNamedMarker"/>
        </member>
        <member name="T:Quantum.QuantumUnityLogger">
            <summary>
            A log wrapper around the Quantum static logger to bind to the Unity debug logging.
            Toggle the LogLevel using `Quantum.Log.LogLevel`. It get's initialized using the defines:
              QUANTUM_LOGLEVEL_TRACE, QUANTUM_LOGLEVEL_DEBUG, QUANTUM_LOGLEVEL_INFO, QUANTUM_LOGLEVEL_WARN, QUANTUM_LOGLEVEL_ERROR
            </summary>
        </member>
        <member name="F:Quantum.QuantumUnityLogger.NameUnavailableObjectDestroyedLabel">
            <summary>
            Customize logged object names for destroyed objects.
            </summary>
        </member>
        <member name="F:Quantum.QuantumUnityLogger.NameUnavailableInWorkerThreadLabel">
            <summary>
            Customize logged object names from other threads.
            </summary>
        </member>
        <member name="F:Quantum.QuantumUnityLogger.UseGlobalPrefix">
            <summary>
            If true, all messages will be prefixed with [Quantum] tag
            </summary>
        </member>
        <member name="F:Quantum.QuantumUnityLogger.UseColorTags">
            <summary>
            If true, some parts of messages will be enclosed with &lt;color&gt; tags.
            </summary>
        </member>
        <member name="F:Quantum.QuantumUnityLogger.AddHashCodePrefix">
            <summary>
            If true, each log message that has a source parameter will be prefixed with a hash code of the source object. 
            </summary>
        </member>
        <member name="F:Quantum.QuantumUnityLogger.GlobalPrefixColor">
            <summary>
            Color of the global prefix (see <see cref="F:Quantum.QuantumUnityLogger.UseGlobalPrefix"/>).
            </summary>
        </member>
        <member name="F:Quantum.QuantumUnityLogger.MinRandomColor">
            <summary>
            Min Random Color
            </summary>
        </member>
        <member name="F:Quantum.QuantumUnityLogger.MaxRandomColor">
            <summary>
            Max Random Color
            </summary>
        </member>
        <member name="F:Quantum.QuantumUnityLogger.GlobalPrefix">
            <summary>
            A prefix tag added to each log.
            </summary>
            
        </member>
        <member name="P:Quantum.QuantumUnityLogger.DefinedLogLevel">
            <summary>
            Returns the log level defined by QUANTUM_LOGLEVEL_(..) defines.
            </summary>
        </member>
        <member name="M:Quantum.QuantumUnityLogger.#ctor(System.Threading.Thread)">
            <summary>
            Create unity logger instance.
            </summary>
            <param name="mainThread">The thread used by <see cref="P:Quantum.QuantumUnityLogger.IsInMainThread"/> or <see langword="null"/> to use the current thread.</param>
        </member>
        <member name="M:Quantum.QuantumUnityLogger.Log(Quantum.LogType,System.String,Quantum.LogContext@)">
            <summary>
            Log a message that will call <see cref="M:UnityEngine.Debug.Log(System.Object,UnityEngine.Object)"/>.
            </summary>
            <param name="logType">Log type.</param>
            <param name="message">The log message.</param>
            <param name="logContext">The context object or <see langword="null"/>.</param>
        </member>
        <member name="M:Quantum.QuantumUnityLogger.LogException(System.Exception,Quantum.LogContext@)">
            <summary>
            Log an exception.
            <para>Tries to force console windows double click to the exception source when UNITY_EDITOR is defined, otherwise will also call <see cref="M:UnityEngine.Debug.LogException(System.Exception,UnityEngine.Object)"/>.</para>
            </summary>
            <param name="ex">Exception to log.</param>
            <param name="logContext">Log context or <see langword="null"/></param>
        </member>
        <member name="T:Quantum.QuantumMapData">
            <summary>
            Unity component that holds and bakes the map data for a Quantum map from a given scene.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMapData.Asset">
            <summary>
            The source asset to bake the data into.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMapData.BakeAllMode">
            <summary>
            How the map data should be baked.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMapData.NavMeshSerializeType">
            <summary>
            <see cref="T:Quantum.NavMeshSerializeType"/>
            </summary>
        </member>
        <member name="F:Quantum.QuantumMapData.StaticCollider2DReferences">
            <summary>
            One-to-one mapping of Quantum 2D static collider entries in QAssetMap to their original source scripts. 
            Purely for convenience to do post bake mappings and not required by the Quantum simulation.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMapData.StaticCollider3DReferences">
            <summary>
            One-to-one mapping of Quantum 3D static collider entries in QAssetMap to their original source scripts. 
            Purely for convenience to do post bake mappings and not required by the Quantum simulation.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMapData.MapEntityReferences">
            <summary>
            One-to-one mapping of Quantum map entity entries in QAssetMap to their original source scripts.
            </summary>
        </member>
        <member name="T:Quantum.Profiling.QuantumGraphProfilerSimulationTime">
            <summary>
            A Quantum graph profiler that shows the simulation time.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilerSimulationTime.OnUpdate">
            <inheritdoc/>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilerSimulationTime.OnTargetFPSChanged(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Quantum.Profiling.QuantumGraphProfilerFrameTime">
            <summary>
            A Quantum graph profiler that records the frame time.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilerFrameTime.OnUpdate">
            <inheritdoc/>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilerFrameTime.OnTargetFPSChanged(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Quantum.Profiling.QuantumGraphProfilerPing">
            <summary>
            A Quantum graph profiler that shows the RTT to the server.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilerPing.OnUpdate">
            <inheritdoc/>
        </member>
        <member name="T:Quantum.Profiling.QuantumGraphSeriesMarker">
            <summary>
            The rendering of a marker series.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphSeriesMarker.SetColors(UnityEngine.Color[])">
            <summary>
            Set the marker colors in the material.
            Must have certain color fields: _Marker{0}Color.
            </summary>
            <param name="colors">Color parameter</param>
        </member>
        <member name="T:Quantum.Profiling.QuantumGraphPlayerLoopUtility">
            <summary>
            A system to add profiler callbacks into the Unity player loop.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphPlayerLoopUtility.SetDefaultPlayerLoopSystem">
            <summary>
            Resets the player loop.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphPlayerLoopUtility.HasPlayerLoopSystem(System.Type)">
            <summary>
            Checks if certain player loop system is already added.
            </summary>
            <param name="playerLoopSystemType">Player loop system type</param>
            <returns>True if the system type was found</returns>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphPlayerLoopUtility.AddPlayerLoopSystem(System.Type,System.Type,UnityEngine.LowLevel.PlayerLoopSystem.UpdateFunction,System.Int32)">
            <summary>
            Adds a player loop system to the Unity player loop.
            </summary>
            <param name="playerLoopSystemType">Player loos system type</param>
            <param name="targetLoopSystemType">Target loop type</param>
            <param name="updateFunction">Update function</param>
            <param name="position">The position of the sub system</param>
            <returns>True is system was added</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Is raised when the position is invalid</exception>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphPlayerLoopUtility.AddPlayerLoopSystem(System.Type,System.Type,UnityEngine.LowLevel.PlayerLoopSystem.UpdateFunction,UnityEngine.LowLevel.PlayerLoopSystem.UpdateFunction)">
            <summary>
            Adds a player loop system to the Unity player loop.
            </summary>
            <param name="playerLoopSystemType">Player loos system type</param>
            <param name="targetSubSystemType">Target sub system type</param>
            <param name="updateFunctionBefore">Update before function</param>
            <param name="updateFunctionAfter">Update after function</param>
            <returns>True if the system was added</returns>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphPlayerLoopUtility.RemovePlayerLoopSystems(System.Type)">
            <summary>
            Remove a player loop system.
            </summary>
            <param name="playerLoopSystemType">System type to remove</param>
            <returns>True if the system was found and removed</returns>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphPlayerLoopUtility.DumpPlayerLoopSystems">
            <summary>
            Debug output of the player loop systems.
            </summary>
        </member>
        <member name="T:Quantum.Profiling.QuantumGraphProfilerRenderTime">
            <summary>
            A Quantum graph profiler that shows the render time
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilerRenderTime.OnUpdate">
            <inheritdoc/>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilerRenderTime.OnTargetFPSChanged(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Quantum.Profiling.QuantumGraphProfilerGC">
            <summary>
            A Quantum graph profiler that records the garbage collection time.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilerGC.OnActivated">
            <inheritdoc/>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilerGC.OnDeactivated">
            <inheritdoc/>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilerGC.OnUpdate">
            <inheritdoc/>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilerGC.OnTargetFPSChanged(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Quantum.Profiling.QuantumGraphProfilerPredictedFrames">
            <summary>
            A Quantum graph profiler that shows how far the simulation is in predicting.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilerPredictedFrames.OnUpdate">
            <inheritdoc/>
        </member>
        <member name="T:Quantum.Profiling.QuantumGraphProfilerMarkerSeries">
            <summary>
            A graph profiler that records a series of markers.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilerMarkerSeries.OnActivated">
            <inheritdoc/>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilerMarkerSeries.SetMarkers(System.Boolean[])">
            <inheritdoc/>
        </member>
        <member name="T:Quantum.Profiling.QuantumGraphProfilerUserScripts">
            <summary>
            A Quantum graph profiler that shows the time spent in Unity scripts.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilerUserScripts.OnUpdate">
            <inheritdoc/>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilerUserScripts.OnTargetFPSChanged(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Quantum.Profiling.QuantumGraphPool`1">
            <summary>
            A pool for <see cref="T:Quantum.Profiling.QuantumGraphTimer"/> objects. 
            </summary>
            <typeparam name="T">Type </typeparam>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphPool`1.Get">
            <summary>
            Get an item from the pool or create a new one if the pool is empty.
            </summary>
            <returns>Pooled item</returns>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphPool`1.Return(`0)">
            <summary>
            Return an item to the pool.
            </summary>
            <param name="item">Item to return to the pool</param>
        </member>
        <member name="T:Quantum.Profiling.QuantumGraphProfilingTools">
            <summary>
            A Unity script that renders additional profiling tools to the graph UI.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilingTools.ToggleVisibility">
            <summary>
            Toggle the visibility of the UI.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilingTools.ToggleFPS">
            <summary>
            Toggle the target frame rate.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilingTools.ToggleIncomingLag">
            <summary>
            Toggle simulating incoming lag.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilingTools.ToggleOutgoingLag">
            <summary>
            Toggle simulating outgoing lag.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilingTools.ToggleIncomingJitter">
            <summary>
            Toggle simulating incoming network jitter.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilingTools.ToggleOutgoingJitter">
            <summary>
            Toggle simulating outgoing network jitter.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilingTools.ToggleIncomingLoss">
            <summary>
            Toggle simulating incoming packet loss.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilingTools.ToggleOutgoingLoss">
            <summary>
            Toggle simulating outgoing packet loss.
            </summary>
        </member>
        <member name="T:Quantum.Profiling.QuantumGraphSeriesValue">
            <summary>
            The series value graph is used format, average values add graphical features to the graph rendering.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphSeriesValue.SetThresholds(System.Single,System.Single,System.Single)">
            <summary>
            Set the thresholds for color changes.
            </summary>
            <param name="threshold1">Threshold one</param>
            <param name="threshold2">Threshold two</param>
            <param name="threshold3">Threshold three</param>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphSeriesValue.SetColors(UnityEngine.Color,UnityEngine.Color,UnityEngine.Color,UnityEngine.Color,UnityEngine.Color)">
            <summary>
            Set colors for the thresholds.
            </summary>
            <param name="normalColor">Normal color</param>
            <param name="averageColor">Average color</param>
            <param name="threshold1Color">Threshold one color</param>
            <param name="threshold2Color">Threshold two color</param>
            <param name="threshold3Color">Threshold three color</param>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphSeriesValue.SetValues(System.Single[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphSeriesValue.SetValues(System.Single[],System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            Set the values to render
            </summary>
            <param name="values">Values array</param>
            <param name="offset">Offset to start reading values from the array</param>
            <param name="minValue">Min value </param>
            <param name="maxValue">Max value</param>
            <param name="averageValue">Average value</param>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphSeriesValue.OnInitialize">
            <inheritdoc/>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphSeriesValue.OnRestore">
            <inheritdoc/>
        </member>
        <member name="T:Quantum.Profiling.QuantumGraphProfilerValueSeries">
            <summary>
            Records a series of values for a graph profiler.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilerValueSeries.OnActivated">
            <inheritdoc/>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilerValueSeries.AddValue(System.Single)">
            <summary>
            Add a value to the series.
            </summary>
            <param name="value">Value to record</param>
        </member>
        <member name="T:Quantum.Profiling.QuantumGraphProfilers">
            <summary>
            The main management class in the Quantum graph profilers.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.QuantumGraphProfilers.FrameTimer">
            <summary>
            List of frame graph timers running.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.QuantumGraphProfilers.ScriptsTimer">
            <summary>
            List of scripts timers running.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.QuantumGraphProfilers.RenderTimer">
            <summary>
            List of render timers running.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilers.InitializeSubSystem">
            <summary>
            Register to unity callbacks and start the graph profilers using the Unity player loop.
            </summary>
        </member>
        <member name="T:Quantum.Profiling.QuantumGraphProfilersUtility">
            <summary>
            A utility class for Quantum graph profilers.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilersUtility.GetNetworkPeer">
            <summary>
            Tries to find the network peer by the default runner.
            </summary>
            <returns>Photon Peer or null</returns>
        </member>
        <member name="T:Quantum.Profiling.QuantumGraphTimer">
            <summary>
            The Quantum graph timer to measure time with a stopwatch.
            </summary>
        </member>
        <member name="T:Quantum.Profiling.QuantumGraphTimer.EState">
            <summary>
            The state of the timer.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.QuantumGraphTimer.EState.Stopped">
            <summary>
            Timer stopped
            </summary>
        </member>
        <member name="F:Quantum.Profiling.QuantumGraphTimer.EState.Running">
            <summary>
            Timer running
            </summary>
        </member>
        <member name="F:Quantum.Profiling.QuantumGraphTimer.EState.Paused">
            <summary>
            Timer paused
            </summary>
        </member>
        <member name="F:Quantum.Profiling.QuantumGraphTimer.ID">
            <summary>
            The time id
            </summary>
        </member>
        <member name="F:Quantum.Profiling.QuantumGraphTimer.Name">
            <summary>
            The time name
            </summary>
        </member>
        <member name="P:Quantum.Profiling.QuantumGraphTimer.State">
            <summary>
            Returns the timer state.
            </summary>
        </member>
        <member name="P:Quantum.Profiling.QuantumGraphTimer.Counter">
            <summary>
            Counts how many time the timer has been updated.
            </summary>
        </member>
        <member name="P:Quantum.Profiling.QuantumGraphTimer.TotalTime">
            <summary>
            The total accumulated time.
            </summary>
        </member>
        <member name="P:Quantum.Profiling.QuantumGraphTimer.RecentTime">
            <summary>
            The time after the last start.
            </summary>
        </member>
        <member name="P:Quantum.Profiling.QuantumGraphTimer.PeakTime">
            <summary>
            The peak time measured.
            </summary>
        </member>
        <member name="P:Quantum.Profiling.QuantumGraphTimer.LastTime">
            <summary>
            The time in the last update.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphTimer.#ctor">
            <summary>
            Create a new timer.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphTimer.#ctor(System.String)">
            <summary>
            Create a new timer with a name.
            </summary>
            <param name="name">Name</param>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphTimer.#ctor(System.Int32,System.String)">
            <summary>
            Create a new timer with an id and a name.
            </summary>
            <param name="id">Timer id</param>
            <param name="name">Timer name</param>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphTimer.Start">
            <summary>
            Start the timer.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphTimer.Pause">
            <summary>
            Pause the timer.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphTimer.Stop">
            <summary>
            Stop the timer.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphTimer.Restart">
            <summary>
            Restart the timer.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphTimer.Reset">
            <summary>
            Reset the timer.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphTimer.Return">
            <summary>
            Return the timer to the pool.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphTimer.Combine(Quantum.Profiling.QuantumGraphTimer)">
            <summary>
            Combine the timer with another timer.
            </summary>
            <param name="other">Other timer</param>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphTimer.GetTotalSeconds">
            <summary>
            Get the total time in seconds.
            </summary>
            <returns>Time in seconds</returns>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphTimer.GetTotalMilliseconds">
            <summary>
            Get the total time in milliseconds.
            </summary>
            <returns>Time in ms</returns>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphTimer.GetRecentSeconds">
            <summary>
            Get the recent time in seconds since the last start.
            </summary>
            <returns>TIme in seconds</returns>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphTimer.GetRecentMilliseconds">
            <summary>
            Get the recent time in milliseconds since the last start.
            </summary>
            <returns>Time in ms</returns>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphTimer.GetPeakSeconds">
            <summary>
            Get the peak seconds measured.
            </summary>
            <returns>Peak seconds</returns>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphTimer.GetPeakMilliseconds">
            <summary>
            Get the peak milliseconds measured.
            </summary>
            <returns>Peak ms</returns>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphTimer.GetLastSeconds">
            <summary>
            Get the seconds measured of the last update.
            </summary>
            <returns>Time in seconds</returns>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphTimer.GetLastMilliseconds">
            <summary>
            Get the milliseconds measured of the last update.
            </summary>
            <returns>Time in ms</returns>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphTimer.Get(System.Boolean)">
            <summary>
            Create a new timer or get one from the pool.
            </summary>
            <param name="start">Set true to automatically start the timer.</param>
            <returns>A timer object</returns>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphTimer.Return(Quantum.Profiling.QuantumGraphTimer)">
            <summary>
            Return the timer object to the pool.
            </summary>
            <param name="timer">Timer</param>
        </member>
        <member name="T:Quantum.Profiling.QuantumGraphProfilerNetworkActivity">
            <summary>
            A Quantum graph profiler that shows the time delta between the last received packet.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilerNetworkActivity.OnUpdate">
            <inheritdoc/>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilerNetworkActivity.OnTargetFPSChanged(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Quantum.Profiling.QuantumGraphProfilerDeltaTime">
            <summary>
            A graph profiler that records the delta time.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilerDeltaTime.OnUpdate">
            <inheritdoc/>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilerDeltaTime.OnTargetFPSChanged(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="T:Quantum.Profiling.QuantumGraphProfiler`1">
            <summary>
            The base class for all Quantum graph profilers.
            </summary>
            <typeparam name="TGraph">Type of graph <see cref="T:Quantum.Profiling.QuantumGraphSeries"/></typeparam>
        </member>
        <member name="P:Quantum.Profiling.QuantumGraphProfiler`1.Graph">
            <summary>
            The graph object.
            </summary>
        </member>
        <member name="P:Quantum.Profiling.QuantumGraphProfiler`1.Values">
            <summary>
            Recorded values.
            </summary>
        </member>
        <member name="P:Quantum.Profiling.QuantumGraphProfiler`1.IsActive">
            <summary>
            Is the profiler active and visible.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfiler`1.ToggleVisibility">
            <summary>
            Toggle the visibility of the profiler.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfiler`1.OnInitialize">
            <summary>
            Called during Unity <see cref="M:Quantum.Profiling.QuantumGraphProfiler`1.Awake"/>.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfiler`1.OnDeinitialize">
            <summary>
            Called during Unity <see cref="M:Quantum.Profiling.QuantumGraphProfiler`1.OnDestroy"/>
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfiler`1.OnActivated">
            <summary>
            Called when enabled <see cref="M:Quantum.Profiling.QuantumGraphProfiler`1.SetState(System.Boolean)"/>.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfiler`1.OnDeactivated">
            <summary>
            Called when disabled <see cref="M:Quantum.Profiling.QuantumGraphProfiler`1.SetState(System.Boolean)"/>
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfiler`1.OnUpdate">
            <summary>
            Called during Unity <see cref="M:Quantum.Profiling.QuantumGraphProfiler`1.Update"/>
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfiler`1.OnRestore">
            <summary>
            Called when the profiler is enabled or disabled.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfiler`1.OnTargetFPSChanged(System.Int32)">
            <summary>
            Called when <see cref="P:UnityEngine.Application.targetFrameRate"/> changed during <see cref="M:Quantum.Profiling.QuantumGraphProfiler`1.Update"/>.
            </summary>
            <param name="fps"></param>
        </member>
        <member name="T:Quantum.Profiling.QuantumGraphProfilingStatistics">
            <summary>
            A Unity script that renders additional statistics to the graph UI.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilingStatistics.ToggleVisibility">
            <summary>
            Toggle the visibility of the UI.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilingStatistics.OnEnable">
            <summary>
            Unity <see cref="M:Quantum.Profiling.QuantumGraphProfilingStatistics.OnEnable"/>, create and start profiler.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilingStatistics.OnDisable">
            <summary>
            Unity <see cref="M:Quantum.Profiling.QuantumGraphProfilingStatistics.OnDisable"/>, dispose and stop profilers.
            </summary>
        </member>
        <member name="T:Quantum.Profiling.QuantumGraphSeries">
            <summary>
            A graph series is the base class to render graphs in Unity.
            </summary>
        </member>
        <member name="P:Quantum.Profiling.QuantumGraphSeries.Samples">
            <summary>
            Returns the number of samples that can be displayed.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.QuantumGraphSeries._targetImage">
            <summary>
            The target image to render the graphs in.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.QuantumGraphSeries._samples">
            <summary>
            The number of samples that are displayed.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.QuantumGraphSeries._values">
            <summary>
            The values to render.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.QuantumGraphSeries._material">
            <summary>
            The material to render the graph.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.QuantumGraphSeries._valuesShaderPropertyID">
            <summary>
            Cache shared property.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphSeries.OnInitialize">
            <inheritdoc/>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphSeries.OnRestore">
            <inheritdoc/>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphSeries.Initialize">
            <inheritdoc/>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphSeries.SetValues(System.Single[],System.Int32,System.Int32)">
            <summary>
            Set the values to render
            </summary>
            <param name="values">Values array</param>
            <param name="offset">Offset to start reading values from the array</param>
            <param name="samples">Number of samples to display</param>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphSeries.Restore">
            <inheritdoc/>
        </member>
        <member name="T:Quantum.Profiling.QuantumGraphProfilerMarkers">
            <summary>
            A Quantum graph profiler that records custom markers.
            </summary>
        </member>
        <member name="F:Quantum.Profiling.QuantumGraphProfilerMarkers.Instances">
            <summary>
            All marker profiler instances.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilerMarkers.Get(System.String)">
            <summary>
            Get a marker profiler by name.
            </summary>
            <param name="name">Name</param>
            <returns>Marker graph</returns>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilerMarkers.Set(System.Int32)">
            <summary>
            Set the marker index to true on all marker profilers.
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilerMarkers.SetMarker(System.Int32)">
            <summary>
            Set the marker index to true.
            </summary>
            <param name="index">Index</param>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilerMarkers.OnInitialize">
            <inheritdoc/>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilerMarkers.OnDeinitialize">
            <inheritdoc/>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilerMarkers.OnActivated">
            <inheritdoc/>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilerMarkers.OnDeactivated">
            <inheritdoc/>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilerMarkers.OnUpdate">
            <inheritdoc/>
        </member>
        <member name="T:Quantum.Profiling.QuantumGraphProfilerVerifiedFrames">
            <summary>
            A Quantum graph profiler that shows how many verified frames have been simulated during the last update.
            </summary>
        </member>
        <member name="M:Quantum.Profiling.QuantumGraphProfilerVerifiedFrames.OnUpdate">
            <inheritdoc/>
        </member>
        <member name="T:Quantum.QuantumLoadBalancingClient">
            <summary>
            Obsolete: Not used anymore. Replace by using RealtimeClient directly.
            </summary>
        </member>
        <member name="M:Quantum.QuantumLoadBalancingClient.#ctor(Photon.Client.ConnectionProtocol)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Quantum.QuantumLoadBalancingClient.ConnectUsingSettings(Photon.Realtime.AppSettings,System.String)">
            <summary>
            Overridden connect method.
            </summary>
        </member>
        <member name="T:Quantum.QuantumGameGizmos">
            <summary>
            Draws gizmos for the Quantum simulation.
            </summary>
        </member>
        <member name="M:Quantum.QuantumGameGizmos.InvalidateNavMeshGizmos">
            <summary>
            Invalidates the navmesh gizmos.
            </summary>
        </member>
        <member name="M:Quantum.QuantumGameGizmos.InvalidatePhysicsGizmos">
            <summary>
            Invalidates the physics gizmos.
            </summary>
        </member>
        <member name="M:Quantum.QuantumGameGizmos.OnBeforeBake(Quantum.QuantumMapData)">
            <summary>
            On BeforeBake override, empty.
            </summary>
        </member>
        <member name="M:Quantum.QuantumGameGizmos.OnBake(Quantum.QuantumMapData)">
            <summary>
            On Bake override, creates gizmos data for terrain collider.
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:Quantum.QuantumGameGizmos.CreateAndDrawNavMeshGizmo(Quantum.NavMesh,Quantum.NavMeshRegionMask)">
            <summary>
              Creates a Unity mesh from the navmesh data and renders it as a gizmo. Uses submeshes to draw main mesh, regions and
              deactivated regions in different colors.
              The meshes are cached in a static dictionary by their NavMesh.Name. Call InvalidateGizmos() to reset the cache
              manually.
              New meshes are created when the region mask changed.
            </summary>
        </member>
        <member name="T:Quantum.DebugMesh">
            <summary>
            Access to Quantum debug mesh resources.
            Obsolete: has been replaced by QuantumMeshCollection.Global.
            </summary>
        </member>
        <member name="P:Quantum.DebugMesh.CircleMesh">
            <summary>
            Load and return the QuantumGizmoCircleMesh asset and cache for later use.
            This circle mesh is aligned to the XY plane.
            </summary>
        </member>
        <member name="P:Quantum.DebugMesh.SphereMesh">
            <summary>
            Load and return the QuantumGizmoSphereMesh asset and cache for later use.
            </summary>
        </member>
        <member name="P:Quantum.DebugMesh.QuadMesh">
            <summary>
            Load and return the QuantumGizmoQuadMesh asset and cache for later use.
            </summary>
        </member>
        <member name="P:Quantum.DebugMesh.CubeMesh">
            <summary>
            Load and return the QuantumGizmoCubeMesh asset and cache for later use.
            </summary>
        </member>
        <member name="P:Quantum.DebugMesh.CapsuleMesh">
            <summary>
            Load and return the QuantumGizmoCapsuleMesh asset and cache for later use.
            </summary>
        </member>
        <member name="P:Quantum.DebugMesh.CylinderMesh">
            <summary>
            Load and return the QuantumGizmoCylinderMesh asset and cache for later use.
            This cylinder mesh is aligned to the XY plane.
            </summary>
        </member>
        <member name="P:Quantum.DebugMesh.DebugMaterial">
            <summary>
            The material used to draw transparent simulation debug shapes. 
            Replace by setting a material before it's ever used.
            </summary>
        </member>
        <member name="T:Quantum.DebugDraw">
            <summary>
            This class will draw shapes issued by the simulation (e.g. <see cref="M:Quantum.Draw.Sphere(Photon.Deterministic.FPVector3,Photon.Deterministic.FP,System.Nullable{Quantum.ColorRGBA},System.Boolean)"/>)
            The shape drawing is based on the DEBUG define which is enabled in UnityEditor and development builds.
            Can be globally toggled of by using <see cref="F:Quantum.DebugDraw.IsEnabled"/>.
            </summary>
        </member>
        <member name="F:Quantum.DebugDraw.IsEnabled">
            <summary>
            Globally toggle on/off any simulation debug shape drawing.
            </summary>
        </member>
        <member name="M:Quantum.DebugDraw.Ray(Quantum.Draw.DebugRay)">
            <summary>
            The action to call on Draw.Ray.
            </summary>
            <param name="ray">Ray to be drawn in the view.</param>
        </member>
        <member name="M:Quantum.DebugDraw.Line(Quantum.Draw.DebugLine)">
            <summary>
            The action to call on Draw.Line.
            </summary>
            <param name="line">The line information to draw in the view.</param>
        </member>
        <member name="M:Quantum.DebugDraw.Circle(Quantum.Draw.DebugCircle)">
            <summary>
            The action to call on Draw.Circle.
            </summary>
            <param name="circle">Circle information</param>
        </member>
        <member name="M:Quantum.DebugDraw.Sphere(Quantum.Draw.DebugSphere)">
            <summary>
            The action to call on Draw.Sphere.
            </summary>
            <param name="sphere">Sphere information</param>
        </member>
        <member name="M:Quantum.DebugDraw.Rectangle(Quantum.Draw.DebugRectangle)">
            <summary>
            The action to call on Draw.Rectangle.
            </summary>
            <param name="rectangle">Rectangle information</param>
        </member>
        <member name="M:Quantum.DebugDraw.Box(Quantum.Draw.DebugBox)">
            <summary>
            The action to call on Draw.Box.
            </summary>
            <param name="box">Boc information</param>
        </member>
        <member name="M:Quantum.DebugDraw.Capsule(Quantum.Draw.DebugCapsule)">
            <summary>
            The action to call on Draw.Capsule.
            </summary>
            <param name="capsule">Capsule information</param>
        </member>
        <member name="M:Quantum.DebugDraw.GetMaterial(Quantum.ColorRGBA)">
            <summary>
            Return the debug shape drawing material based on the color.
            Will set the main color on the material.
            </summary>
            <param name="color">Color</param>
            <returns>Material</returns>
        </member>
        <member name="M:Quantum.DebugDraw.Clear">
            <summary>
            Clear everything still in the queues.
            </summary>
        </member>
        <member name="M:Quantum.DebugDraw.TakeAll">
            <summary>
            Transfer all items from the locked queue to the internal draw shape arrays.
            </summary>
        </member>
        <member name="M:Quantum.DebugDraw.DrawAll">
            <summary>
            Obsolete
            </summary>
        </member>
        <member name="M:Quantum.DebugDraw.OnPostRender(UnityEngine.Camera)">
            <summary>
            Must be called from Unity callback OnPostRenderInternal to draw all debug shapes on top of everything else.
            </summary>
            <param name="camera">The scene camera</param>
        </member>
        <member name="T:Quantum.QuantumStaticPolygonCollider2D">
            <summary>
            The script will create a static 2D polygon collider during Quantum map baking.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticPolygonCollider2D.SourceCollider">
            <summary>
            Link a Unity polygon collider to copy its size and position of during Quantum map baking.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticPolygonCollider2D.BakeAsStaticEdges2D">
            <summary>
            Bake the static collider as 2D edges instead.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticPolygonCollider2D.Vertices">
            <summary>
            The individual vertices of the polygon.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticPolygonCollider2D.PositionOffset">
            <summary>
            The position offset added to the <see cref="P:UnityEngine.Transform.position"/> during baking.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticPolygonCollider2D.RotationOffset">
            <summary>
            The rotation offset added to the <see cref="P:UnityEngine.Transform.rotation"/> during baking.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticPolygonCollider2D.Height">
            <summary>
            The optional 2D pseudo height of the collider.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticPolygonCollider2D.Settings">
            <summary>
            Additional static collider settings.
            </summary>
        </member>
        <member name="P:Quantum.QuantumStaticPolygonCollider2D.UpdateVerticesFromSourceOnBake">
            <summary>
            Should the <see cref="F:Quantum.QuantumStaticPolygonCollider2D.Vertices"/> be set from the source collider during baking.
            </summary>
        </member>
        <member name="M:Quantum.QuantumStaticPolygonCollider2D.UpdateFromSourceCollider(System.Boolean)">
            <summary>
            Copy collider configuration from source collider if exist. 
            </summary>
        </member>
        <member name="M:Quantum.QuantumStaticPolygonCollider2D.BeforeBake">
            <summary>
            Callback before baking the collider.
            </summary>
        </member>
        <member name="T:Quantum.QuantumEntityViewFlags">
            <summary>
            Additional configuration of the entity view that enables of disabled parts of the updating process.
            Either for performance reasons or when taking over control.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityViewFlags.DisableUpdateView">
            <summary>
            <see cref="M:Quantum.QuantumEntityView.UpdateView(System.Boolean,System.Boolean)"/> and <see cref="M:Quantum.QuantumEntityView.LateUpdateView"/> are not processed and forwarded to entity view components.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityViewFlags.DisableUpdatePosition">
            <summary>
            Will completely disable updating the entity view positions.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityViewFlags.UseCachedTransform">
            <summary>
            Use cached transforms to improve the performance by not calling Transform properties.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityViewFlags.DisableEntityRefNaming">
            <summary>
            The entity game object will be named to resemble the EntityRef, set this flag to prevent naming.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityViewFlags.DisableSearchChildrenForEntityViewComponents">
            <summary>
            Disable searching the entity view game object children for entity view components.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityViewFlags.EnableSnapshotInterpolation">
            <summary>
            Inits a transform buffer, so updating with verified frames only can be switched on to guarantee smooth visuals. When in use, visuals are presented with latency proportional to ping.
            Turning this on only prepares the buffers and callbacks. Switching the interpolation mode is controlled with a separate toggle on the QuantumEntityView.
            </summary>
        </member>
        <member name="T:Quantum.QuantumEntityViewTimeReference">
            <summary>
            Used when grabbing transform data for view interpolation.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityViewTimeReference.To">
            <summary>
            Either Predicted frame or closest frame data from verified (when using snapshot interpolation).
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityViewTimeReference.From">
            <summary>
            Either PredictedPrevious frame or farthest frame data from verified (when using snapshot interpolation).
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityViewTimeReference.ErrorCorrection">
            <summary>
            Previous update corrected frame (to compute total mis-prediction).
            </summary>
        </member>
        <member name="T:Quantum.QuantumEntityViewInterpolationMode">
            <summary>
            Interpolation mode for the view.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityViewInterpolationMode.Prediction">
            <summary>
            Default mode interpolated between PredictedPrevious and Predicted, also using mis-prediction error smoothing.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityViewInterpolationMode.SnapshotInterpolation">
            <summary>
            Dynamically interpolates between two past verified frames. Timing is computed by EntityViewUpdater.
            Views using this mode are always seen "in the past", but are smooth and accurate, given mis-predictions are not possible.
            REQUIRES: QuantumEntityViewFlags must include EnableSnapshotInterpolation
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityViewInterpolationMode.Auto">
            <summary>
            Dynamically switches between Prediction and SnapshotInterpolation based on culled status of the Entity.
            REQUIRES: QuantumEntityViewFlags must include EnableSnapshotInterpolation
            </summary>
        </member>
        <member name="T:Quantum.QuantumEntityPrototypeTransformMode">
            <summary>
            Defines what kind of transform component a <see cref="T:Quantum.QuantumEntityPrototype"/> has.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototypeTransformMode.Transform2D">
            <summary>
            <see cref="T:Quantum.Transform2D"/>
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototypeTransformMode.Transform3D">
            <summary>
            <see cref="T:Quantum.Transform3D"/>
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototypeTransformMode.None">
            <summary>
            No transform component.
            </summary>
        </member>
        <member name="T:Quantum.MultiTypeReferenceAttribute">
            <summary>
            Adds one object picker per type to the inspector.
            </summary>
        </member>
        <member name="M:Quantum.MultiTypeReferenceAttribute.#ctor(System.Type[])">
            <summary>
            Initializes a new instance.
            </summary>
            <param name="types">Types of objects this field supports.</param>
        </member>
        <member name="F:Quantum.MultiTypeReferenceAttribute.Types">
            <summary>
            Types of objects this field supports.
            </summary>
        </member>
        <member name="T:Quantum.QuantumEvent">
            <summary>
            Events are a fire-and-forget mechanism to transfer information from the simulation to the view.
            Use this class to subscribe and unsubscribe from Quantum events.
            <para>Events are mostly custom and code-generated by the Quantum DSL.</para>
            <para>Events do not synchronize anything between clients and they are fired by each client's own simulation.</para>
            <para>Since the same Frame can be simulated more than once (prediction, rollback), it is possible to have events being triggered multiple times. 
            To avoid undesired duplicated Events Quantum identifies duplicates using a hash code function over the Event data members, the Event id and the tick.</para>
            <para>Regular, non-synced, Events will be either cancelled or confirmed once the predicted Frame from which they were fired has been verified.</para>
            <para>Events are dispatched after all Frames have been simulated right after the OnUpdateView callback. Events are called in the same order they were invoked with 
            the exception of non-synced Events which can be skipped when identified as duplicated. Due to this timing, the targeted QuantumEntityView may already have been destroyed.</para>
            </summary>
        </member>
        <member name="T:Quantum.QuantumUnityEventDispatcher">
            <summary>
            <see cref="T:Quantum.EventDispatcher"/> implementation for Unity.
            </summary>
        </member>
        <member name="M:Quantum.QuantumUnityEventDispatcher.GetListenerStatus(System.Object,System.UInt32)">
            <inheritdoc cref="M:Quantum.IQuantumUnityDispatcherExtensions.GetUnityListenerStatus(Quantum.IQuantumUnityDispatcher,System.Object,System.UInt32)"/>
        </member>
        <member name="T:Quantum.QuantumRunnerLocalSavegame">
            <summary>
            This script can be used to start a Quantum simulation from a savegame file and is very similar to <see cref="T:Quantum.QuantumRunnerLocalReplay"/>.
            </summary>
        </member>
        <member name="F:Quantum.QuantumRunnerLocalSavegame.SavegameFile">
            <summary>
            The savegame file (<see cref="T:Quantum.ReplayFile"/>).
            </summary>
        </member>
        <member name="F:Quantum.QuantumRunnerLocalSavegame.DatabaseFile">
            <summary>
            The optional database file.
            </summary>
        </member>
        <member name="F:Quantum.QuantumRunnerLocalSavegame.InstantReplayConfig">
            <summary>
            The instant replay settings.
            </summary>
        </member>
        <member name="M:Quantum.QuantumRunnerLocalSavegame.Start">
            <summary>
            Unity start method loads the savegame files and starts the runner.
            </summary>
        </member>
        <member name="T:Quantum.QuantumReconnectInformation">
            <summary>
            Implements <see cref="T:Photon.Realtime.MatchmakingReconnectInformation"/> to save reconnect information to player prefs.
            This way the app can try to reconnect after app start.
            </summary>
        </member>
        <member name="M:Quantum.QuantumReconnectInformation.Load">
            <summary>
            Load the matchmaking information from player prefs.
            <para>Always returns a valid object.</para>
            </summary>
        </member>
        <member name="M:Quantum.QuantumReconnectInformation.Set(Photon.Realtime.RealtimeClient)">
            <summary>
            Is a callback from matchmaking that triggers a successful connect that can then be stored.
            </summary>
            <param name="client">Realtime client that created the connection.</param>
        </member>
        <member name="M:Quantum.QuantumReconnectInformation.Reset">
            <summary>
            Reset the saved reconnect information.
            </summary>
        </member>
        <member name="M:Quantum.QuantumReconnectInformation.Save(Quantum.QuantumReconnectInformation)">
            <summary>
            Save the reconnect information to player prefs.
            </summary>
            <param name="value">The info to store.</param>
        </member>
        <member name="T:Quantum.QuantumCallbackHandler_DebugDraw">
            <summary>
            A handler object that registers to Quantum callbacks and draws debug shapes issued from the simulation.
            </summary>
        </member>
        <member name="M:Quantum.QuantumCallbackHandler_DebugDraw.Initialize">
            <summary>
            Init and subscribe to Quantum callbacks.
            </summary>
            <returns>An object to dispose to unsubscribe from the callbacks</returns>
        </member>
        <member name="T:Quantum.QuantumCallbackHandler_UnityCallbacks">
            <summary>
            A handler object that subscribes to Quantum callbacks to handle Unity scene loading and unloading.
            </summary>
        </member>
        <member name="M:Quantum.QuantumCallbackHandler_UnityCallbacks.#ctor(Quantum.QuantumGame)">
            <summary>
            Creates a new instance of the QuantumCallbackHandler_UnityCallbacks class.
            </summary>
            <param name="game">Referenced game</param>
        </member>
        <member name="M:Quantum.QuantumCallbackHandler_UnityCallbacks.Initialize">
            <summary>
            Init and subscribe to Quantum callbacks.
            </summary>
            <returns>An object to dispose to unsubscribe from the callbacks</returns>
        </member>
        <member name="M:Quantum.QuantumCallbackHandler_UnityCallbacks.Dispose">
            <summary>
            Dispose the object, unsubscribe from Quantum callbacks.
            Will log a warning if a map loading or unloading is still in progress.
            Will start a coroutine to unload the current scene if it was not unloaded yet.
            </summary>
        </member>
        <member name="T:Quantum.QuantumUnityJsonSerializer">
            <summary>
            Asset serializer implementation based on <see cref="T:UnityEngine.JsonUtility"/> and a set of utility methods from
            <see cref="T:Quantum.JsonUtilityExtensions"/>. Can use surrogates to replace asset types with more efficient
            representations (<see cref="M:Quantum.QuantumUnityJsonSerializer.RegisterSurrogate``2(System.Func{``0,``1})"/>. Additionally, any Unity-object references
            are serialized as null by default (<see cref="P:Quantum.QuantumUnityJsonSerializer.NullifyUnityObjectReferences"/>).
            <p/>
            The output can be deserialized with Newtonsoft.Json-based deserializer from Quantum.Json assembly. If this interoperability is
            needed, consider enabling <see cref="P:Quantum.QuantumUnityJsonSerializer.IntegerEnquotingMinDigits"/> to ensure that large integers are enquoted and not treated as
            floating points.
            </summary>
        </member>
        <member name="P:Quantum.QuantumUnityJsonSerializer.PrettyPrintEnabled">
            <summary>
            No longer used.
            </summary>
        </member>
        <member name="P:Quantum.QuantumUnityJsonSerializer.EntityViewPrefabResolvingEnabled">
            <summary>
            No longer used.
            </summary>
        </member>
        <member name="P:Quantum.QuantumUnityJsonSerializer.DecompressBinaryDataOnDeserialization">
            <summary>
            If true, all BinaryData assets will be decompressed during deserialization.
            </summary>
        </member>
        <member name="P:Quantum.QuantumUnityJsonSerializer.CompressBinaryDataOnSerializationThreshold">
            <summary>
            If set to a positive value, all uncompressed BinaryData assets with size over the value will be compressed
            during serialization.
            </summary>
        </member>
        <member name="P:Quantum.QuantumUnityJsonSerializer.IntegerEnquotingMinDigits">
            <summary>
            How many digits should a number have to be enquoted.
            Some JSON parsers deserialize all numbers as floating points,  which in case of large integers (e.g. entity ids) can lead to precision loss.
            If this property is set to true (default), all integers with <see cref="P:Quantum.QuantumUnityJsonSerializer.IntegerEnquotingMinDigits"/> or more digits
            are enquoted.
            </summary>
        </member>
        <member name="P:Quantum.QuantumUnityJsonSerializer.NullifyUnityObjectReferences">
             <summary>
             Should all UnityEngine.Object references be nullified in the resulting JSON?
             If true, all UnityEngine.Object references will be serialized as null. Otherwise,
             they are serialized as { "instanceId": &lt;value&gt; }.
            
             True by default.
             </summary>
        </member>
        <member name="P:Quantum.QuantumUnityJsonSerializer.EntityViewPrefabResolver">
             <summary>
             Custom resolver for EntityView prefabs.
            
             EntityViews are serialized without prefab references (as they are not JSON serializable). Resolving
             takes place during deserialization, by looking up the prefab in the global DB.
             </summary>
        </member>
        <member name="P:Quantum.QuantumUnityJsonSerializer.TypeResolver">
             <summary>
             Custom type resolver to be used during deserialization.
            
             If not set, <see cref="M:System.Type.GetType(System.String,System.Boolean)"/> will be used and an exception will be thrown on missing type.
             If set and returns null, the type object will be skipped and returned as null.
             </summary>
        </member>
        <member name="M:Quantum.QuantumUnityJsonSerializer.#ctor">
            <summary>
            Creates a new instance of <see cref="T:Quantum.QuantumUnityJsonSerializer"/>.
            </summary>
        </member>
        <member name="M:Quantum.QuantumUnityJsonSerializer.RegisterSurrogate``2(System.Func{``0,``1})">
            <summary>
            Registers a surrogate type for the provided asset type. Surrogates are types that are serialized and deserialized instead of
            the original asset type. By default, the serializer only provides surrogates for <see cref="T:Quantum.EntityView"/> and
            <see cref="T:Quantum.BinaryData"/>, for a more efficient serialization.
            </summary>
            <param name="factory">Delegate to be used when an instance of a surrogate is needed.</param>
        </member>
        <member name="M:Quantum.QuantumUnityJsonSerializer.ResolvePrefab(Quantum.AssetGuid)">
            <summary>
            Resolves the prefab associated with the provided AssetGuid by looking it up in the global DB.
            </summary>
            <param name="guid">The AssetGuid of the prefab to be resolved.</param>
            <returns>Returns the GameObject associated with the provided AssetGuid.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when the prefab associated with the provided AssetGuid cannot be found.</exception>
        </member>
        <member name="M:Quantum.QuantumUnityJsonSerializer.CreateReader(System.IO.Stream)">
            <summary>
            Creates a new instance of <see cref="T:System.IO.StreamReader"/> with UTF8 encoding. The underlying stream is not closed.
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.QuantumUnityJsonSerializer.CreateWriter(System.IO.Stream)">
            <summary>
            Creates a new instance of <see cref="T:System.IO.StreamWriter"/> with UTF8 encoding. The underlying stream is not closed.
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.QuantumUnityJsonSerializer.SerializeConfig(System.IO.Stream,Quantum.IRuntimeConfig)">
            <inheritdoc cref="M:Quantum.IAssetSerializer.SerializeConfig(System.IO.Stream,Quantum.IRuntimeConfig)"/>
        </member>
        <member name="M:Quantum.QuantumUnityJsonSerializer.SerializePlayer(System.IO.Stream,Quantum.IRuntimePlayer)">
            <inheritdoc cref="M:Quantum.IAssetSerializer.SerializePlayer(System.IO.Stream,Quantum.IRuntimePlayer)"/>
        </member>
        <member name="M:Quantum.QuantumUnityJsonSerializer.SerializeResult(System.IO.Stream,Quantum.IGameResult)">
            <inheritdoc cref="M:Quantum.IAssetSerializer.SerializeResult(System.IO.Stream,Quantum.IGameResult)"/>
        </member>
        <member name="M:Quantum.QuantumUnityJsonSerializer.SerializeAssets(System.IO.Stream,Quantum.AssetObject[])">
            <inheritdoc cref="M:Quantum.IAssetSerializer.SerializeAssets(System.IO.Stream,Quantum.AssetObject[])"/>
        </member>
        <member name="M:Quantum.QuantumUnityJsonSerializer.DeserializeConfig(System.IO.Stream)">
            <inheritdoc cref="M:Quantum.IAssetSerializer.DeserializeConfig(System.IO.Stream)"/>
        </member>
        <member name="M:Quantum.QuantumUnityJsonSerializer.DeserializePlayer(System.IO.Stream)">
            <inheritdoc cref="M:Quantum.IAssetSerializer.DeserializePlayer(System.IO.Stream)"/>
        </member>
        <member name="M:Quantum.QuantumUnityJsonSerializer.DeserializeResult(System.IO.Stream)">
            <inheritdoc cref="M:Quantum.IAssetSerializer.DeserializeResult(System.IO.Stream)"/>
        </member>
        <member name="M:Quantum.QuantumUnityJsonSerializer.DeserializeAssets(System.IO.Stream)">
            <inheritdoc cref="M:Quantum.IAssetSerializer.DeserializeAssets(System.IO.Stream)"/>
        </member>
        <member name="M:Quantum.QuantumUnityJsonSerializer.PrintObject(System.Object)">
            <inheritdoc cref="M:Quantum.IAssetSerializer.PrintObject(System.Object)"/>
        </member>
        <member name="T:Quantum.QuantumUnityJsonSerializer.AssetObjectSurrogate">
            <summary>
            Base class for asset object surrogates.
            </summary>
        </member>
        <member name="F:Quantum.QuantumUnityJsonSerializer.AssetObjectSurrogate.Identifier">
            <summary>
            Asset identifier.
            </summary>
        </member>
        <member name="M:Quantum.QuantumUnityJsonSerializer.AssetObjectSurrogate.CreateAsset(Quantum.QuantumUnityJsonSerializer)">
            <summary>
            Creates an asset object from the surrogate.
            </summary>
            <param name="serializer"></param>
            <returns></returns>
        </member>
        <member name="T:Quantum.QuantumUnityJsonSerializer.EntityViewSurrogate">
            <summary>
            <see cref="T:Quantum.EntityView"/> surrogate. Does not serialize the prefab reference, but only the identifier.
            <see cref="M:Quantum.QuantumUnityJsonSerializer.ResolvePrefab(Quantum.AssetGuid)"/> is used to resolve the prefab during deserialization.
            </summary>
        </member>
        <member name="M:Quantum.QuantumUnityJsonSerializer.EntityViewSurrogate.CreateAsset(Quantum.QuantumUnityJsonSerializer)">
            <inheritdoc cref="M:Quantum.QuantumUnityJsonSerializer.AssetObjectSurrogate.CreateAsset(Quantum.QuantumUnityJsonSerializer)"/>
        </member>
        <member name="T:Quantum.QuantumUnityJsonSerializer.BinaryDataSurrogate">
            <summary>
            <see cref="T:Quantum.BinaryData"/> surrogate. Compresses the data if it is larger than the threshold and replaces the data with a base64 encoded string.
            </summary>
        </member>
        <member name="F:Quantum.QuantumUnityJsonSerializer.BinaryDataSurrogate.IsCompressed">
            <summary>
            Is the data compressed.
            </summary>
        </member>
        <member name="F:Quantum.QuantumUnityJsonSerializer.BinaryDataSurrogate.Data">
            <summary>
            Binary data as a base64 encoded string.
            </summary>
        </member>
        <member name="M:Quantum.QuantumUnityJsonSerializer.BinaryDataSurrogate.Create(Quantum.BinaryData,System.Nullable{System.Int32})">
            <summary>
            Creates a surrogate from the asset. Optionally compresses the data if it is larger than the threshold.
            </summary>
            <param name="asset"></param>
            <param name="compressThreshold"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.QuantumUnityJsonSerializer.BinaryDataSurrogate.CreateAsset(Quantum.QuantumUnityJsonSerializer)">
            <inheritdoc cref="M:Quantum.QuantumUnityJsonSerializer.AssetObjectSurrogate.CreateAsset(Quantum.QuantumUnityJsonSerializer)"/>
        </member>
        <member name="T:Quantum.QuantumMemoryStats">
            <summary>
            A script that displays memory stats of the Quantum heap.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMemoryStats.TotalMemory">
            <summary>
            The total memory in MB.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMemoryStats.TotalPages">
            <summary>
            The number of pages in the heap.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMemoryStats.TotalUsage">
            <summary>
            The percentage of memory used.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMemoryStats.PagesFree">
            <summary>
            The pages that are free.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMemoryStats.PagesFull">
            <summary>
            The pages that are full.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMemoryStats.PagesUsed">
            <summary>
            The pages used.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMemoryStats.BytesAllocated">
            <summary>
            The total amount of bytes allocated in KB.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMemoryStats.BytesReserved">
            <summary>
            The total amount of bytes reserved in KB.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMemoryStats.BytesCommited">
            <summary>
            The total amount of bytes commited in KB.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMemoryStats.EntityCount">
            <summary>
            The entity count.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMemoryStats.EntityMemory">
            <summary>
            The memory used by entities in KB.
            </summary>
        </member>
        <member name="T:Quantum.IQuantumViewComponent">
            <summary>
            The interface that the <see cref="T:Quantum.QuantumEntityViewUpdater"/> uses to control the view components (<see cref="T:Quantum.QuantumViewComponent`1"/>).
            </summary>
        </member>
        <member name="M:Quantum.IQuantumViewComponent.Initialize(System.Collections.Generic.Dictionary{System.Type,Quantum.IQuantumViewContext})">
            <summary>
            Is called when the entity view is enabled for the first time.
            </summary>
            <param name="contexts">All view contexts</param>
        </member>
        <member name="M:Quantum.IQuantumViewComponent.Activate(Quantum.Frame,Quantum.QuantumGame,Quantum.QuantumEntityView)">
            <summary>
            Is called when the entity view is activated after being created or reused from the pool.
            </summary>
            <param name="frame">Frame</param>
            <param name="game">Quantum game</param>
            <param name="entityView">Associated entity view</param>
        </member>
        <member name="M:Quantum.IQuantumViewComponent.Deactivate">
            <summary>
            Is called when the entity view is destroyed or returned to the pool.
            </summary>
        </member>
        <member name="M:Quantum.IQuantumViewComponent.UpdateView">
            <summary>
            Is called when the entity view is updated from the Unity update loop.
            </summary>
        </member>
        <member name="M:Quantum.IQuantumViewComponent.LateUpdateView">
            <summary>
            Is call on all entity views Unity late update.
            </summary>
        </member>
        <member name="M:Quantum.IQuantumViewComponent.GameChanged(Quantum.QuantumGame)">
            <summary>
            Is called when the game has changed in the <see cref="T:Quantum.QuantumEntityViewUpdater"/>.
            </summary>
            <param name="game"></param>
        </member>
        <member name="P:Quantum.IQuantumViewComponent.IsActive">
            <summary>
            Is toggled during <see cref="M:Quantum.IQuantumViewComponent.Activate(Quantum.Frame,Quantum.QuantumGame,Quantum.QuantumEntityView)"/> and <see cref="M:Quantum.IQuantumViewComponent.Deactivate"/>."/>
            </summary>
        </member>
        <member name="T:Quantum.QuantumCallbackHandler_FrameDiffer">
            <summary>
            A handler object to subscribe to Quantum callbacks to open the frame dump differ in builds
            after receiving a checksum error frame dumps.
            </summary>
        </member>
        <member name="M:Quantum.QuantumCallbackHandler_FrameDiffer.Initialize">
            <summary>
            Init and subscribe to Quantum callbacks.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Quantum.QuantumEntityView">
            <summary>
            The Quantum entity view component is the representation of the entity inside Unity.
            Instances will be created by the <see cref="P:Quantum.QuantumEntityView.EntityViewUpdater"/>.
            Quantum entity with the <see cref="T:Quantum.View"/> component will references a Quantum <see cref="T:Quantum.EntityView"/> asset which will in turn be instantiated as 
            <see cref="F:Quantum.EntityView.Prefab"/> and the resulting game object includes this script.
            </summary>
        </member>
        <member name="T:Quantum.QuantumEntityView.EntityUnityEvent">
            <summary>
            Wrapping UnityEvent(QuantumGame) into a class. Is used by the QuantumEntityView to make create and destroy publish Unity events.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityView.AssetGuid">
            <summary>
            Will set to the <see cref="P:Quantum.AssetObject.Guid"/> that the underlying <see cref="T:Quantum.EntityView"/> asset has.
            Or receives a new Guid when binding this view script to a scene entity.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityView.EntityRef">
            <summary>
            References the Quantum entity that this view script is liked to.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityView.BindBehaviour">
            <summary>
            Set the entity view bind behaviour. If set to <see cref="F:Quantum.QuantumEntityViewBindBehaviour.NonVerified"/> then the view is created during a predicted frame.
            Entity views created at that time can be subject to changes and even be destroyed because of misprediction.
            Entity views created during <see cref="F:Quantum.QuantumEntityViewBindBehaviour.Verified"/> will be more stable but are always created at a later time, when the input has been confirmed by the server.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityView.ManualDisposal">
            <summary>
            If enabled the QuantumEntityViewUpdater will not destroy (or disable, in case of map entities) this instance, and you are responsible for removing it from the game world yourself.\n\nYou will still receive the OnEntityDestroyed callback.
            </summary>
        </member>
        <member name="P:Quantum.QuantumEntityView.ManualDiposal">
            <summary>
            Obsolete property, use ManualDisposal
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityView.ViewFlags">
            <summary>
            Set the <see cref="T:Quantum.QuantumEntityViewFlags"/> to further configure the entity view.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityView.InterpolationMode">
            <summary>
            Set the <see cref="T:Quantum.QuantumEntityViewInterpolationMode"/> allowing the view timing to be switched between prediction and snapshot-interpolation.
            Requires the QuantumEntityViewFlags.SnapshotInterpolationEnabled flag to be set to have an effect.
            AUTO selects the mode dynamically based on the prediction-culled state of the entity. 
            </summary>
        </member>
        <member name="P:Quantum.QuantumEntityView.GameObjectNameIsEntityRef">
            <summary>
            If set to true, the game object will be renamed to the EntityRef number.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityView.ErrorCorrectionRateMin">
            <summary>
              <para>
                A factor with dimension of 1/s (Hz) that works as a lower limit for how much
                of the accumulated prediction error is corrected every frame.
                This factor affects both the position and the rotation correction.
                Suggested values are greater than zero and smaller than
                <see cref="F:Quantum.QuantumEntityView.ErrorCorrectionRateMax">ErrorCorrectionRateMax</see>.
              </para>
              <para>
                E.g.: ErrorCorrectionRateMin = 3, rendering delta time = (1/60)s: at least 5% (3 * 1/60) of the accumulated error
                will be corrected on this rendered frame.
              </para>
              <para>
                This threshold might not be respected if the resultant correction magnitude is
                below the <see cref="F:Quantum.QuantumEntityView.ErrorPositionMinCorrection">ErrorPositionMinCorrection</see>
                or above the <see cref="F:Quantum.QuantumEntityView.ErrorPositionTeleportDistance">ErrorPositionTeleportDistance</see>, for the position error,
                or above the <see cref="F:Quantum.QuantumEntityView.ErrorRotationTeleportDistance">ErrorRotationTeleportDistance</see>, for the rotation error.
              </para>
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityView.ErrorCorrectionRateMax">
            <summary>
              <para>
                A factor with dimension of 1/s (Hz) that works as a upper limit for how much
                of the accumulated prediction error is corrected every frame.
                This factor affects both the position and the rotation correction.
                Suggested values are greater than <see cref="F:Quantum.QuantumEntityView.ErrorCorrectionRateMin">ErrorCorrectionRateMin</see>
                and smaller than half of a target rendering rate.
              </para>
              <para>
                E.g.: ErrorCorrectionRateMax = 15, rendering delta time = (1/60)s: at maximum 25% (15 * 1/60) of the accumulated
                error
                will be corrected on this rendered frame.
              </para>
              <para>
                This threshold might not be respected if the resultant correction magnitude is
                below the <see cref="F:Quantum.QuantumEntityView.ErrorPositionMinCorrection">ErrorPositionMinCorrection</see> or
                above the <see cref="F:Quantum.QuantumEntityView.ErrorPositionTeleportDistance">ErrorPositionTeleportDistance</see>, for the position error,
                or above the <see cref="F:Quantum.QuantumEntityView.ErrorRotationTeleportDistance">ErrorRotationTeleportDistance</see>, for the rotation error.
              </para>
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityView.ErrorPositionBlendStart">
            <summary>
              <para>
                The reference for the magnitude of the accumulated position error, in meters,
                at which the position error will be corrected at the
                <see cref="F:Quantum.QuantumEntityView.ErrorCorrectionRateMin">ErrorCorrectionRateMin</see>.
                Suggested values are greater than <see cref="F:Quantum.QuantumEntityView.ErrorPositionMinCorrection">ErrorPositionMinCorrection</see>
                and smaller than <see cref="F:Quantum.QuantumEntityView.ErrorPositionBlendEnd">ErrorPositionBlendEnd</see>.
              </para>
              <para>
                In other words, if the magnitude of the accumulated error is equal to or smaller than this threshold,
                it will be corrected at the <see cref="F:Quantum.QuantumEntityView.ErrorCorrectionRateMin">ErrorCorrectionRateMin</see>.
                If, instead, the magnitude is between this threshold and
                <see cref="F:Quantum.QuantumEntityView.ErrorPositionBlendEnd">ErrorPositionBlendEnd</see>,
                the error is corrected at a rate between <see cref="F:Quantum.QuantumEntityView.ErrorCorrectionRateMin">ErrorCorrectionRateMin</see>
                and <see cref="F:Quantum.QuantumEntityView.ErrorCorrectionRateMax">ErrorCorrectionRateMax</see>, proportionally.
                If it is equal to or greater than <see cref="F:Quantum.QuantumEntityView.ErrorPositionBlendEnd">ErrorPositionBlendEnd</see>,
                it will be corrected at the <see cref="F:Quantum.QuantumEntityView.ErrorCorrectionRateMax">ErrorCorrectionRateMax</see>.
              </para>
              <para>
                Note: as the factor is expressed in distance units (meters), it might need to be scaled
                proportionally to the overall scale of objects in the scene and speeds at which they move,
                which are factors that affect the expected magnitude of prediction errors.
              </para>
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityView.ErrorPositionBlendEnd">
            <summary>
              <para>
                The reference for the magnitude of the accumulated position error, in meters,
                at which the position error will be corrected at the
                <see cref="F:Quantum.QuantumEntityView.ErrorCorrectionRateMax">ErrorCorrectionRateMax</see>.
                Suggested values are greater than <see cref="F:Quantum.QuantumEntityView.ErrorPositionBlendStart">ErrorPositionBlendStart</see>
                and smaller than <see cref="F:Quantum.QuantumEntityView.ErrorPositionTeleportDistance">ErrorPositionTeleportDistance</see>.
              </para>
              <para>
                In other words, if the magnitude of the accumulated error is equal to or greater than this threshold,
                it will be corrected at the <see cref="F:Quantum.QuantumEntityView.ErrorCorrectionRateMax">ErrorCorrectionRateMax</see>.
                If, instead, the magnitude is between <see cref="F:Quantum.QuantumEntityView.ErrorPositionBlendStart">ErrorPositionBlendStart</see> and this
                threshold,
                the error is corrected at a rate between <see cref="F:Quantum.QuantumEntityView.ErrorCorrectionRateMin">ErrorCorrectionRateMin</see>
                and <see cref="F:Quantum.QuantumEntityView.ErrorCorrectionRateMax">ErrorCorrectionRateMax</see>, proportionally.
                If it is equal to or smaller than <see cref="F:Quantum.QuantumEntityView.ErrorPositionBlendStart">ErrorPositionBlendStart</see>,
                it will be corrected at the <see cref="F:Quantum.QuantumEntityView.ErrorCorrectionRateMin">ErrorCorrectionRateMin</see>.
              </para>
              <para>
                Note: as the factor is expressed in distance units (meters), it might need to be scaled
                proportionally to the overall scale of objects in the scene and speeds at which they move,
                which are factors that affect the expected magnitude of prediction errors.
              </para>
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityView.ErrorRotationBlendStart">
            <summary>
              <para>
                The reference for the magnitude of the accumulated rotation error, in radians,
                at which the rotation error will be corrected at the
                <see cref="F:Quantum.QuantumEntityView.ErrorCorrectionRateMin">ErrorCorrectionRateMin</see>.
                Suggested values are smaller than <see cref="F:Quantum.QuantumEntityView.ErrorRotationBlendEnd">ErrorRotationBlendEnd</see>.
              </para>
              <para>
                In other words, if the magnitude of the accumulated error is equal to or smaller than this threshold,
                it will be corrected at the <see cref="F:Quantum.QuantumEntityView.ErrorCorrectionRateMin">ErrorCorrectionRateMin</see>.
                If, instead, the magnitude is between this threshold and
                <see cref="F:Quantum.QuantumEntityView.ErrorRotationBlendEnd">ErrorRotationBlendEnd</see>,
                the error is corrected at a rate between <see cref="F:Quantum.QuantumEntityView.ErrorCorrectionRateMin">ErrorCorrectionRateMin</see>
                and <see cref="F:Quantum.QuantumEntityView.ErrorCorrectionRateMax">ErrorCorrectionRateMax</see>, proportionally.
                If it is equal to or greater than <see cref="F:Quantum.QuantumEntityView.ErrorRotationBlendEnd">ErrorRotationBlendEnd</see>,
                it will be corrected at the <see cref="F:Quantum.QuantumEntityView.ErrorCorrectionRateMax">ErrorCorrectionRateMax</see>.
              </para>
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityView.ErrorRotationBlendEnd">
            <summary>
              <para>
                The reference for the magnitude of the accumulated rotation error, in radians,
                at which the rotation error will be corrected at the
                <see cref="F:Quantum.QuantumEntityView.ErrorCorrectionRateMax">ErrorCorrectionRateMax</see>.
                Suggested values are greater than <see cref="F:Quantum.QuantumEntityView.ErrorRotationBlendStart">ErrorRotationBlendStart</see>
                and smaller than <see cref="F:Quantum.QuantumEntityView.ErrorRotationTeleportDistance">ErrorRotationTeleportDistance</see>.
              </para>
              <para>
                In other words, if the magnitude of the accumulated error is equal to or greater than this threshold,
                it will be corrected at the <see cref="F:Quantum.QuantumEntityView.ErrorCorrectionRateMax">ErrorCorrectionRateMax</see>.
                If, instead, the magnitude is between <see cref="F:Quantum.QuantumEntityView.ErrorRotationBlendStart">ErrorRotationBlendStart</see> and this
                threshold,
                the error is corrected at a rate between <see cref="F:Quantum.QuantumEntityView.ErrorCorrectionRateMin">ErrorCorrectionRateMin</see>
                and <see cref="F:Quantum.QuantumEntityView.ErrorCorrectionRateMax">ErrorCorrectionRateMax</see>, proportionally.
                If it is equal to or smaller than <see cref="F:Quantum.QuantumEntityView.ErrorRotationBlendStart">ErrorRotationBlendStart</see>,
                it will be corrected at the <see cref="F:Quantum.QuantumEntityView.ErrorCorrectionRateMin">ErrorCorrectionRateMin</see>.
              </para>
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityView.ErrorPositionMinCorrection">
            <summary>
              <para>
                The value, in meters, that represents the minimum magnitude of the accumulated position error
                that will be corrected in a single frame, until it is fully corrected.
              </para>
              <para>
                This setting has priority over the resultant correction rate, i.e. the restriction
                will be respected even if it makes the effective correction rate be different than
                the one computed according to the min/max rates and start/end blend values.
                Suggested values are greater than zero and smaller than
                <see cref="F:Quantum.QuantumEntityView.ErrorPositionBlendStart">ErrorPositionBlendStart</see>.
              </para>
              <para>
                Note: as the factor is expressed in distance units (meters), it might need to be scaled
                proportionally to the overall scale of objects in the scene and speeds at which they move,
                which are factors that affect the expected magnitude of prediction errors.
              </para>
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityView.ErrorPositionTeleportDistance">
            <summary>
              <para>
                The value, in meters, that represents the magnitude of the accumulated
                position error above which the error will be instantaneously corrected,
                effectively teleporting the rendered object to its correct position.
                Suggested values are greater than <see cref="F:Quantum.QuantumEntityView.ErrorPositionBlendEnd">ErrorPositionBlendEnd</see>.
              </para>
              <para>
                This setting has priority over the resultant correction rate, i.e. the restriction
                will be respected even if it makes the effective correction rate be different than
                the one computed according to the min/max rates and start/end blend values.
              </para>
              <para>
                Note: as the factor is expressed in distance units (meters), it might need to be scaled
                proportionally to the overall scale of objects in the scene and speeds at which they move,
                which are factors that affect the expected magnitude of prediction errors.
              </para>
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityView.ErrorRotationTeleportDistance">
            <summary>
              <para>
                The value, in radians, that represents the magnitude of the accumulated
                rotation error above which the error will be instantaneously corrected,
                effectively teleporting the rendered object to its correct orientation.
                Suggested values are greater than <see cref="F:Quantum.QuantumEntityView.ErrorRotationBlendEnd">ErrorRotationBlendEnd</see>.
              </para>
              <para>
                This setting has priority over the resultant correction rate, i.e. the restriction
                will be respected even if it makes the effective correction rate be different than
                the one computed according to the min/max rates and start/end blend values.
              </para>
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityView.OnEntityInstantiated">
            <summary>
            Is called after the entity view has been instantiated.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityView.OnEntityDestroyed">
            <summary>
            Is called before the entity view is destroyed.
            </summary>
        </member>
        <member name="P:Quantum.QuantumEntityView.ViewComponents">
            <summary>
            Access the entity view components registered to this entity view.
            All view components found on this game object during creation are used.
            </summary>
        </member>
        <member name="P:Quantum.QuantumEntityView.EntityViewUpdater">
            <summary>
            A reference to the entity view updater that controls this entity view.
            </summary>
        </member>
        <member name="P:Quantum.QuantumEntityView.Game">
            <summary>
            A reference to the current game that this entity view belongs to <see cref="P:Quantum.QuantumEntityViewUpdater.ObservedGame"/>.
            </summary>
        </member>
        <member name="P:Quantum.QuantumEntityView.ViewContexts">
            <summary>
            All contexts found on the <see cref="P:Quantum.QuantumEntityView.EntityViewUpdater"/> game object accessible by their type.
            </summary>
        </member>
        <member name="M:Quantum.QuantumEntityView.SetViewFlag(Quantum.QuantumEntityViewFlags,System.Boolean)">
            <summary>
            Set the <see cref="T:Quantum.QuantumEntityViewFlags"/> to further configure the entity view.
            </summary>
            <param name="flag">The flag enum value</param>
            <param name="isEnabled">Set or unset the flag.</param>
        </member>
        <member name="M:Quantum.QuantumEntityView.HasViewFlag(Quantum.QuantumEntityViewFlags)">
            <summary>
            Test if a view flag is set.
            </summary>
            <param name="flag"></param>
            <returns></returns>
        </member>
        <member name="P:Quantum.QuantumEntityView.Transform">
            <summary>
            Access the transform of the entity view.
            In play mode the transform object will be cached to improve the performance.
            </summary>
        </member>
        <member name="T:Quantum.QuantumEntityView.UpdatePositionParameter">
            <summary>
            The struct is used to gather all transform and interpolation data to apply new transform data to the entity view.
            <see cref="M:Quantum.QuantumEntityView.ApplyTransform(Quantum.QuantumEntityView.UpdatePositionParameter@)"/>.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityView.UpdatePositionParameter.NewPosition">
            <summary>
            The new position.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityView.UpdatePositionParameter.NewRotation">
            <summary>
            The new rotation.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityView.UpdatePositionParameter.UninterpolatedPosition">
            <summary>
            The un-interpolated position.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityView.UpdatePositionParameter.UninterpolatedRotation">
            <summary>
            The un-interpolated rotation.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityView.UpdatePositionParameter.ErrorVisualVector">
            <summary>
            The position error correction.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityView.UpdatePositionParameter.ErrorVisualQuaternion">
            <summary>
            The rotation error correction.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityView.UpdatePositionParameter.PositionErrorTeleport">
            <summary>
            Is there a position error induced by misprediction.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityView.UpdatePositionParameter.RotationErrorTeleport">
            <summary>
            Is there a rotation error induced by misprediction.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityView.UpdatePositionParameter.PositionTeleport">
            <summary>
            Is this a position teleport.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityView.UpdatePositionParameter.RotationTeleport">
            <summary>
            Is this a rotation teleport.
            </summary>
        </member>
        <member name="M:Quantum.QuantumEntityView.OnInitialize">
            <summary>
            A callback to override to add custom logic to the initialization of this entity view.
            </summary>
        </member>
        <member name="M:Quantum.QuantumEntityView.OnActivate(Quantum.Frame)">
            <summary>
            A callback to override to add custom logic the activation of this entity view.
            </summary>
            <param name="frame">Frame</param>
        </member>
        <member name="M:Quantum.QuantumEntityView.OnDeactivate">
            <summary>
            A callback to override to add custom logic to the deactivation of this entity view.
            </summary>
        </member>
        <member name="M:Quantum.QuantumEntityView.OnUpdateView">
            <summary>
            A callback to override to add custom logic to the update method.
            </summary>
        </member>
        <member name="M:Quantum.QuantumEntityView.OnLateUpdateView">
            <summary>
            A callback to override to add custom logic to the late update method.
            </summary>
        </member>
        <member name="M:Quantum.QuantumEntityView.OnGameChanged">
            <summary>
            A callback to override to add custom logic when the associate game has changed on the connected <see cref="T:Quantum.QuantumEntityViewUpdater"/>.
            </summary>
        </member>
        <member name="M:Quantum.QuantumEntityView.TryGetTransform3DData(Quantum.QuantumEntityViewTimeReference,Quantum.QuantumEntityView.UpdatePositionParameter@,System.Int32@,Quantum.Transform3D@,System.Boolean)">
            <summary>
            There are two sources how to get the transform 3D data from an entity.
            Using the Quantum predicted frames or a snapshot interpolation. Toggle the setting on <see cref="F:Quantum.QuantumEntityView.InterpolationMode"/>.
            </summary>
            <param name="timeRef">Time reference context</param>
            <param name="param">Transform parameter to be filled out</param>
            <param name="frameNumber">Resulting frame number</param>
            <param name="transform">Resulting transform</param>
            <param name="isSpawning">Is the entity spawning</param>
            <returns>True if data could be retrieved</returns>
        </member>
        <member name="M:Quantum.QuantumEntityView.UpdateFromTransform3D(Quantum.QuantumGame,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Apply new transform 3D data and interpolation.
            </summary>
            <param name="game">Game</param>
            <param name="useClockAliasingInterpolation">Use clock aliasing interpolation</param>
            <param name="useErrorCorrectionInterpolation">Use error correction interpolation</param>
            <param name="isSpawning">Is the entity just spawning</param>
        </member>
        <member name="M:Quantum.QuantumEntityView.TryGetTransform2DData(Quantum.QuantumEntityViewTimeReference,Quantum.QuantumEntityView.UpdatePositionParameter@,System.Int32@,Quantum.Transform2D@,Quantum.Transform2DVertical@,System.Boolean@,System.Boolean)">
            <summary>
            There are two sources how to get the transform 3D data from an entity.
            Using the Quantum predicted frames or a snapshot interpolation. Toggle the setting on <see cref="F:Quantum.QuantumEntityView.InterpolationMode"/>.
            </summary>
            <param name="timeRef">Time reference context</param>
            <param name="param">Transform parameter to be filled out</param>
            <param name="frameNumber">Resulting frame number</param>
            <param name="transform">Resulting transform</param>
            <param name="transformVertical">Transform vertical component</param>
            <param name="hasVertical">Has a transform vertical 2D component</param>
            <param name="isSpawning">Is the entity spawning</param>
            <returns>True if data could be retrieved</returns>
            <returns></returns>
        </member>
        <member name="M:Quantum.QuantumEntityView.UpdateFromTransform2D(Quantum.QuantumGame,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Apply new transform 2D data and interpolation.
            </summary>
            <param name="game">Game</param>
            <param name="useClockAliasingInterpolation">Use clock aliasing interpolation</param>
            <param name="useErrorCorrectionInterpolation">Use error correction interpolation</param>
            <param name="isSpawning">Is the entity just spawning</param>
        </member>
        <member name="M:Quantum.QuantumEntityView.ApplyTransform(Quantum.QuantumEntityView.UpdatePositionParameter@)">
            <summary>
            The method to override to apply the final position and rotation interpolation to the view transform.
            </summary>
            <param name="param"></param>
        </member>
        <member name="T:Quantum.QuantumStaticTerrainCollider3D">
            <summary>
            The script will create a static 3D terrain collider during Quantum map baking.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticTerrainCollider3D.Asset">
            <summary>
            The Quantum terrain collider asset.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticTerrainCollider3D.Settings">
            <summary>
            Additional static collider settings.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticTerrainCollider3D.SmoothSphereMeshCollisions">
            <summary>
            The physics solver will resolve sphere and capsule shapes against terrain collisions as if it was a regular flat and smooth plane.
            </summary>
        </member>
        <member name="T:Quantum.QuantumDefaultConfigs">
            <summary>
            This class represents a collection of Quantum config assets that are used when no explicit simulation config was assigned to a simulation (through RuntimeConfig).
            It's also implementing QuantumGlobalScriptableObject to have one instance globally accessible.
            </summary>
        </member>
        <member name="F:Quantum.QuantumDefaultConfigs.DefaultPath">
            <summary>
            The default location of the global QuantumDefaultConfigs asset.
            </summary>
        </member>
        <member name="F:Quantum.QuantumDefaultConfigs.SimulationConfig">
            <summary>
            The simulation config.
            </summary>
        </member>
        <member name="F:Quantum.QuantumDefaultConfigs.PhysicsMaterial">
            <summary>
            The default physics material assigned inside <see cref="F:Quantum.QuantumDefaultConfigs.SimulationConfig"/> to use if no explicit physics material was assigned to Quantum colliders.
            </summary>
        </member>
        <member name="F:Quantum.QuantumDefaultConfigs.CharacterController2DConfig">
            <summary>
            The default KCC2D config assigned inside <see cref="F:Quantum.QuantumDefaultConfigs.SimulationConfig"/>.
            </summary>
        </member>
        <member name="F:Quantum.QuantumDefaultConfigs.CharacterController3DConfig">
            <summary>
            The default KCC3D config assigned inside <see cref="F:Quantum.QuantumDefaultConfigs.SimulationConfig"/>.
            </summary>
        </member>
        <member name="F:Quantum.QuantumDefaultConfigs.NavMeshAgentConfig">
            <summary>
            The default NavMeshAgent config assigned inside <see cref="F:Quantum.QuantumDefaultConfigs.SimulationConfig"/>.
            </summary>
        </member>
        <member name="F:Quantum.QuantumDefaultConfigs.SystemsConfig">
            <summary>
            The default systems config to be used for <see cref="F:Quantum.RuntimeConfig.SystemsConfig"/>.
            </summary>
        </member>
        <member name="P:Quantum.QuantumRunner.DefaultGame">
            <summary>
            Access the QuantumGame from the default runner or null.
            </summary>
        </member>
        <member name="P:Quantum.QuantumRunner.Default">
            <summary>
            Return the global static default runner.
            </summary>
        </member>
        <member name="P:Quantum.QuantumRunner.ActiveRunners">
            <summary>
            Return all active QuantumRunners.
            </summary>
        </member>
        <member name="M:Quantum.QuantumRunner.FindRunner(System.String)">
            <summary>
            Find a QuantumRunner by id.
            </summary>
            <param name="id">Runner id</param>
            <returns>The QuantumRunner or null</returns>
        </member>
        <member name="M:Quantum.QuantumRunner.FindRunner(Photon.Deterministic.IDeterministicGame)">
            <summary>
            Find a QuantumRunner by game.
            </summary>
            <param name="game">Game</param>
            <returns>The runner that holds the input game or null.</returns>
        </member>
        <member name="M:Quantum.QuantumRunner.ShutdownAll">
            <summary>
            Shutdown all runners.
            </summary>
        </member>
        <member name="M:Quantum.QuantumRunner.ShutdownAllAsync">
            <summary>
            Shutdown all runners asynchronously.
            </summary>
            <returns>Task to shutdown all runners</returns>
        </member>
        <member name="M:Quantum.QuantumRunner.StartGame(Quantum.SessionRunner.Arguments)">
            <summary>
            Create and start a new QuantumRunner.
            Will set missing arguments to default values: CallbackDispatcher, AssetSerializer, EventDispatcher, ResourceManager and RunnerFactory.
            </summary>
            <param name="arguments">Start arguments</param>
            <returns>New QuantumRunner</returns>
        </member>
        <member name="M:Quantum.QuantumRunner.StartGameAsync(Quantum.SessionRunner.Arguments)">
            <summary>
            Create a start a new QuantumRunner asynchronously.
            The task will return only after the connection protocol is completed.
            Will set missing arguments to default values: CallbackDispatcher, AssetSerializer, EventDispatcher, ResourceManager and RunnerFactory.
            </summary>
            <param name="arguments">Start arguments</param>
            <returns>A task that creates and starts the QuantumRunner.</returns>
        </member>
        <member name="F:Quantum.QuantumRunner.IsSessionUpdateDisabled">
            <summary>
              Disable updating the runner completely. Useful when ticking the simulation by other means.
            </summary>
        </member>
        <member name="P:Quantum.QuantumRunner.Game">
            <summary>
              Access the QuantumGame.
            </summary>
        </member>
        <member name="P:Quantum.QuantumRunner.HideGizmos">
            <summary>
              Hide Gizmos toggle.
            </summary>
        </member>
        <member name="P:Quantum.QuantumRunner.GizmoSettings">
            <summary>
              Gizmo settings for this runner.
            </summary>
        </member>
        <member name="P:Quantum.QuantumRunner.NetworkClient">
            <summary>
              Access the network client through the Communicator.
            </summary>
        </member>
        <member name="P:Quantum.QuantumRunner.UnityObject">
            <summary>
              The reference to the Unity object that is updating this runner.
            </summary>
        </member>
        <member name="M:Quantum.QuantumRunner.#ctor(Quantum.QuantumRunnerBehaviour)">
            <summary>
            Is used by the QuantumRunnerUnityFactory to create a new QuantumRunner that will be owned by the UnityObject.
            </summary>
            <param name="runnerScript">Unity script</param>
        </member>
        <member name="M:Quantum.QuantumRunner.OnShutdown(Quantum.ShutdownCause)">
            <summary>
            The runner shutdown callback is used to destroy the UnityObject.
            </summary>
            <param name="cause">Shutdown cause</param>
        </member>
        <member name="M:Quantum.QuantumRunner.Update">
            <summary>
            The runner update method.
            </summary>
        </member>
        <member name="T:Quantum.QuantumStaticMeshCollider3D">
            <summary>
            The script will create a static 3D mesh collider during Quantum map baking.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticMeshCollider3D.Mesh">
            <summary>
            The Unity mesh to convert into a Quantum static mesh colliders.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticMeshCollider3D.Settings">
            <summary>
            Additional static collider settings.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticMeshCollider3D.SmoothSphereMeshCollisions">
            <summary>
            The physics solver will resolve sphere and capsule shapes against mesh collisions as if the mesh was a regular flat and smooth plane.
            </summary>
        </member>
        <member name="M:Quantum.QuantumStaticMeshCollider3D.CreateMeshTriangles">
            <summary>
            Create mesh triangles from the Unity mesh.
            </summary>
            <returns>The resulting <see cref="T:Quantum.MeshTriangleVerticesCcw"/>.</returns>
        </member>
        <member name="T:Quantum.QuantumAssetSourceAddressable`1">
            <summary>
            An Addressables-based implementation of the asset source pattern. The asset is loaded from the Addressables system.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Quantum.QuantumAssetSourceAddressable`1.Address">
            <see cref="F:Quantum.QuantumAssetSourceAddressable`1.RuntimeKey"/>
        </member>
        <member name="F:Quantum.QuantumAssetSourceAddressable`1.RuntimeKey">
            <summary>
            Addressables runtime key. Can be used in any form Addressables supports, such as asset name, label, or address.
            </summary>
        </member>
        <member name="M:Quantum.QuantumAssetSourceAddressable`1.Acquire(System.Boolean)">
            <inheritdoc cref="M:Quantum.QuantumAssetSourceResource`1.Acquire(System.Boolean)"/>
        </member>
        <member name="M:Quantum.QuantumAssetSourceAddressable`1.Release">
            <inheritdoc cref="M:Quantum.QuantumAssetSourceResource`1.Release"/>
        </member>
        <member name="P:Quantum.QuantumAssetSourceAddressable`1.IsCompleted">
            <inheritdoc cref="P:Quantum.QuantumAssetSourceResource`1.IsCompleted"/>
        </member>
        <member name="M:Quantum.QuantumAssetSourceAddressable`1.WaitForResult">
            <inheritdoc cref="M:Quantum.QuantumAssetSourceResource`1.WaitForResult"/>
        </member>
        <member name="P:Quantum.QuantumAssetSourceAddressable`1.Description">
            <inheritdoc cref="P:Quantum.QuantumAssetSourceResource`1.Description"/>
        </member>
        <member name="P:Quantum.QuantumAssetSourceAddressable`1.EditorInstance">
            <inheritdoc cref="P:Quantum.QuantumAssetSourceResource`1.EditorInstance"/>
        </member>
        <member name="T:Quantum.QuantumAssetSourceResource`1">
            <summary>
            Resources-based implementation of the asset source pattern.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Quantum.QuantumAssetSourceResource`1.ResourcePath">
            <summary>
            Resource path. Note that this is a Unity resource path, not a file path.
            </summary>
        </member>
        <member name="F:Quantum.QuantumAssetSourceResource`1.SubObjectName">
            <summary>
            Sub-object name. If empty, the main object is loaded.
            </summary>
        </member>
        <member name="M:Quantum.QuantumAssetSourceResource`1.Acquire(System.Boolean)">
            <summary>
            Loads the asset. In synchronous mode, the asset is loaded immediately. In asynchronous mode, the asset is loaded in the background.
            </summary>
            <param name="synchronous"></param>
        </member>
        <member name="M:Quantum.QuantumAssetSourceResource`1.Release">
            <summary>
            Unloads the asset. If the asset is not loaded, an exception is thrown. If the asset is loaded multiple times, it is only
            unloaded when the last acquire is released.
            </summary>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="P:Quantum.QuantumAssetSourceResource`1.IsCompleted">
            <summary>
            Returns <see langword="true"/> if the asset is loaded.
            </summary>
        </member>
        <member name="M:Quantum.QuantumAssetSourceResource`1.WaitForResult">
            <summary>
            Blocks until the asset is loaded. If the asset is not loaded, an exception is thrown.
            </summary>
            <returns>The loaded asset</returns>
        </member>
        <member name="P:Quantum.QuantumAssetSourceResource`1.Description">
            <summary>
            The description of the asset source. Used for debugging.
            </summary>
        </member>
        <member name="P:Quantum.QuantumAssetSourceResource`1.EditorInstance">
            <summary>
            Returns the asset instance for Editor purposes. Does not call <see cref="M:Quantum.QuantumAssetSourceResource`1.Acquire(System.Boolean)"/>.
            </summary>
        </member>
        <member name="T:Quantum.QuantumAssetSourceStatic`1">
            <summary>
            Hard reference-based implementation of the asset source pattern. This asset source forms a hard reference to the asset and never releases it.
            This type is meant to be used at runtime. For edit-time, prefer <see cref="T:Quantum.QuantumAssetSourceStaticLazy`1"/>, as it delays
            actually loading the asset, improving the editor performance.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Quantum.QuantumAssetSourceStatic`1.Object">
            <summary>
            The asset reference. Can point to an asset or to a runtime-created object.
            </summary>
        </member>
        <member name="P:Quantum.QuantumAssetSourceStatic`1.Prefab">
            <see cref="F:Quantum.QuantumAssetSourceStatic`1.Object"/>
        </member>
        <member name="P:Quantum.QuantumAssetSourceStatic`1.IsCompleted">
            <summary>
            Returns <see langword="true"/>.
            </summary>
        </member>
        <member name="M:Quantum.QuantumAssetSourceStatic`1.Acquire(System.Boolean)">
            <summary>
            Does nothing, the asset is always loaded.
            </summary>
        </member>
        <member name="M:Quantum.QuantumAssetSourceStatic`1.Release">
            <summary>
            Does nothing, the asset is always loaded.
            </summary>
        </member>
        <member name="M:Quantum.QuantumAssetSourceStatic`1.WaitForResult">
            <summary>
            Returns <seealso cref="F:Quantum.QuantumAssetSourceStatic`1.Object"/> or throws an exception if the reference is missing.
            </summary>
        </member>
        <member name="P:Quantum.QuantumAssetSourceStatic`1.Description">
            <inheritdoc cref="P:Quantum.QuantumAssetSourceResource`1.Description"/>
        </member>
        <member name="P:Quantum.QuantumAssetSourceStatic`1.EditorInstance">
            <summary>
            Returns <seealso cref="F:Quantum.QuantumAssetSourceStatic`1.Object"/>.
            </summary>
        </member>
        <member name="T:Quantum.QuantumAssetSourceStaticLazy`1">
            <summary>
            An edit-time optimised version of <see cref="T:Quantum.QuantumAssetSourceStatic`1"/>, taking advantage of Unity's lazy loading of
            assets. At runtime, this type behaves exactly like <see cref="T:Quantum.QuantumAssetSourceStatic`1"/>, except for the inability
            to use runtime-created objects.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Quantum.QuantumAssetSourceStaticLazy`1.Object">
            <summary>
            The asset reference. Can only point to an asset, runtime-created objects will not work.
            </summary>
        </member>
        <member name="P:Quantum.QuantumAssetSourceStaticLazy`1.Prefab">
            <inheritdoc cref="P:Quantum.QuantumAssetSourceStatic`1.Prefab"/>
        </member>
        <member name="P:Quantum.QuantumAssetSourceStaticLazy`1.IsCompleted">
            <inheritdoc cref="P:Quantum.QuantumAssetSourceStatic`1.IsCompleted"/>
        </member>
        <member name="M:Quantum.QuantumAssetSourceStaticLazy`1.Acquire(System.Boolean)">
            <inheritdoc cref="M:Quantum.QuantumAssetSourceStatic`1.Acquire(System.Boolean)"/>
        </member>
        <member name="M:Quantum.QuantumAssetSourceStaticLazy`1.Release">
            <inheritdoc cref="M:Quantum.QuantumAssetSourceStatic`1.Release"/>
        </member>
        <member name="M:Quantum.QuantumAssetSourceStaticLazy`1.WaitForResult">
            <inheritdoc cref="M:Quantum.QuantumAssetSourceStatic`1.WaitForResult"/>
        </member>
        <member name="P:Quantum.QuantumAssetSourceStaticLazy`1.Description">
            <inheritdoc cref="P:Quantum.QuantumAssetSourceStatic`1.Description"/>
        </member>
        <member name="P:Quantum.QuantumAssetSourceStaticLazy`1.EditorInstance">
            <inheritdoc cref="P:Quantum.QuantumAssetSourceStatic`1.EditorInstance"/>
        </member>
        <member name="T:Quantum.QuantumGlobalScriptableObjectAddressAttribute">
            <summary>
            If applied at the assembly level, allows <see cref="T:Quantum.QuantumGlobalScriptableObject`1"/> to be loaded with Addressables.
            </summary>
        </member>
        <member name="M:Quantum.QuantumGlobalScriptableObjectAddressAttribute.#ctor(System.Type,System.String)">
            <param name="objectType">The type this attribute will attempt to load.</param>
            <param name="address">The address to load from.</param>
        </member>
        <member name="P:Quantum.QuantumGlobalScriptableObjectAddressAttribute.Address">
            <summary>
            The address to load from.
            </summary>
        </member>
        <member name="M:Quantum.QuantumGlobalScriptableObjectAddressAttribute.Load(System.Type)">
            <summary>
            Loads the asset from the <see cref="P:Quantum.QuantumGlobalScriptableObjectAddressAttribute.Address"/>. Uses WaitForCompletion internally, so platforms that do not support it need
            to preload the address prior to loading.
            </summary>
        </member>
        <member name="T:Quantum.QuantumGlobalScriptableObjectResourceAttribute">
            <summary>
            If applied at the assembly level, allows <see cref="T:Quantum.QuantumGlobalScriptableObject`1"/> to be loaded with Resources.
            There is a default registration for this attribute, which attempts to load the asset from Resources using path from
            <see cref="T:Quantum.QuantumGlobalScriptableObjectAttribute"/>.
            </summary>
        </member>
        <member name="M:Quantum.QuantumGlobalScriptableObjectResourceAttribute.#ctor(System.Type,System.String)">
            <param name="objectType">The type this attribute will attempt to load.</param>
            <param name="resourcePath">Resources path or <see langword="null"/>/empty if path from <see cref="T:Quantum.QuantumGlobalScriptableObjectAttribute"/>
            is to be used.</param>
        </member>
        <member name="P:Quantum.QuantumGlobalScriptableObjectResourceAttribute.ResourcePath">
            <summary>
            Path in Resources.
            </summary>
        </member>
        <member name="P:Quantum.QuantumGlobalScriptableObjectResourceAttribute.InstantiateIfLoadedInEditor">
            <summary>
            If loaded in the editor, should the result be instantiated instead of returning the asset itself? The default is <see langword="true"/>. 
            </summary>
        </member>
        <member name="M:Quantum.QuantumGlobalScriptableObjectResourceAttribute.Load(System.Type)">
            <summary>
            Loads the asset from Resources synchronously.
            </summary>
        </member>
        <member name="T:Quantum.QuantumSceneViewComponent`1">
            <summary>
            The SceneViewComponent is able to attach itself to the <see cref="T:Quantum.QuantumEntityViewUpdater"/> and received updates from it.
            <para>Set <see cref="F:Quantum.QuantumSceneViewComponent`1.Updater"/> explicitly, or set <see cref="F:Quantum.QuantumSceneViewComponent`1.UseFindUpdater"/> or make this script a child of <see cref="T:Quantum.QuantumEntityViewUpdater"/>.</para>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Quantum.QuantumSceneViewComponent`1.Updater">
            <summary>
            Will attach this view component to this EntityViewUpdater so it receives update callbacks from there.
            This field will not be set unless set explicitly or <see cref="F:Quantum.QuantumSceneViewComponent`1.UseFindUpdater"/> is true.
            </summary>
        </member>
        <member name="F:Quantum.QuantumSceneViewComponent`1.UseFindUpdater">
            <summary>
            Uses UnityEngine.Object.FindObjectOfType/FindObjectByType to find the <see cref="F:Quantum.QuantumSceneViewComponent`1.Updater"/>. This is very slow and not recommended.
            </summary>
        </member>
        <member name="M:Quantum.QuantumSceneViewComponent`1.OnEnable">
            <summary>
            Unity OnEnabled, will try to attach this script to the <see cref="F:Quantum.QuantumSceneViewComponent`1.Updater"/>.
            </summary>
        </member>
        <member name="M:Quantum.QuantumSceneViewComponent`1.OnDisable">
            <summary>
            Unity OnDisabled, will try to detach the script from the <see cref="F:Quantum.QuantumSceneViewComponent`1.Updater"/>.
            </summary>
        </member>
        <member name="T:Quantum.QuantumSceneViewComponent">
            <summary>
            A Quantum scene view component without context.
            The SceneViewComponent is able to attach itself to the <see cref="T:Quantum.QuantumEntityViewUpdater"/> and received updates from it.
            </summary>
        </member>
        <member name="T:Quantum.QuantumFrameDiffer">
            <summary>
            The frame differ shows the frame dumps of all clients in a game and allows to compare them after a checksum error.
            This class renders the GUI on the screen and is usable in builds.
            </summary>
        </member>
        <member name="F:Quantum.QuantumFrameDiffer.State">
            <summary>
            The state saves the frame dumps to be displayed.
            </summary>
        </member>
        <member name="M:Quantum.QuantumFrameDiffer.Show">
            <summary>
            Find and or create a new <see cref="T:Quantum.QuantumFrameDiffer"/> component and show the GUI.
            </summary>
            <returns>The frame differ component.</returns>
        </member>
        <member name="M:Quantum.QuantumFrameDiffer.TryGetPhotonNickname(Photon.Realtime.RealtimeClient,System.Int32)">
            <summary>
            A helper method to try to get the Photon nickname of a player using its Photon actor id.
            </summary>
            <param name="client">Client connection object</param>
            <param name="actorId">Photon actor id</param>
            <returns>A nickname or null</returns>
        </member>
        <member name="T:Quantum.QuantumStats">
            <summary>
            Measures and display basic Quantum statistics on a UI element.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStats.FrameVerified">
            <summary>
            Current verified frame.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStats.FramePredicted">
            <summary>
            Current predicted frame.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStats.Predicted">
            <summary>
            Number of predicted frames.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStats.Resimulated">
            <summary>
            Number of resimulated frames.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStats.SimulateTime">
            <summary>
            The last simulation time.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStats.SimulationState">
            <summary>
            The state of the simulation.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStats.NetworkPing">
            <summary>
            The network ping measured by the simulation.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStats.NetworkIn">
            <summary>
            The bytes received per second.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStats.NetworkOut">
            <summary>
            The bytes send per second.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStats.InputOffset">
            <summary>
            The current input offset.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStats.ToggleButtonText">
            <summary>
            Toggle button text.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStats.Toggles">
            <summary>
            The UI objects to toggle on/off.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStats.StartEnabled">
            <summary>
            Start the game with an open stats window.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStats.UseCurrentBandwidth">
            <summary>
            Use only the last second to measure <see cref="F:Quantum.QuantumStats.NetworkOut"/> and <see cref="F:Quantum.QuantumStats.NetworkOut"/> instead of the total time.
            </summary>
        </member>
        <member name="M:Quantum.QuantumStats.ResetNetworkStats">
            <summary>
            Resets the bandwidth stats measurement.
            </summary>
        </member>
        <member name="M:Quantum.QuantumStats.Toggle">
            <summary>
            Toggle the stats window.
            </summary>
        </member>
        <member name="M:Quantum.QuantumStats.Show">
            <summary>
            Find or load the stats windows and enable it.
            </summary>
        </member>
        <member name="M:Quantum.QuantumStats.Hide">
            <summary>
            Find or load the stats windows and disable it.
            </summary>
        </member>
        <member name="M:Quantum.QuantumStats.GetObject">
            <summary>
            Find or create the stats window.
            </summary>
            <returns>The stats window object</returns>
        </member>
        <member name="T:Quantum.QuantumUnityDB">
            <summary>
            At runtime, servers as the default implementation of <see cref="T:Quantum.IResourceManager"/> for Unity. During edit time,
            it collects and keeps track of all the <see cref="T:Quantum.AssetObject"/> assets in the project. Collected assets are stored as
            <see cref="T:Quantum.IQuantumAssetObjectSource"/> references, avoiding forming hard-references to the actual assets (if possible).
            </summary>
        </member>
        <member name="F:Quantum.QuantumUnityDB.DefaultPath">
            <summary>
            The default location of the DB asset.
            </summary>
        </member>
        <member name="F:Quantum.QuantumUnityDB.NestedPathSeparator">
            <summary>
            Character used to separate nested assets names from their parents path.
            </summary>
        </member>
        <member name="F:Quantum.QuantumUnityDB._entries">
            <summary>
            All the assets that are managed by this DB.
            </summary>
        </member>
        <member name="F:Quantum.QuantumUnityDB._guidToIndex">
            <summary>
            AssetGuid to index in <see cref="F:Quantum.QuantumUnityDB._entries"/> mapping.
            </summary>
        </member>
        <member name="F:Quantum.QuantumUnityDB._pathToIndex">
            <summary>
            Path to index in <see cref="F:Quantum.QuantumUnityDB._entries"/> mapping.
            </summary>
        </member>
        <member name="F:Quantum.QuantumUnityDB._allocator">
            <summary>
            Allocator used for assets initialization and disposal.
            </summary>
        </member>
        <member name="F:Quantum.QuantumUnityDB._disposeQueue">
            <summary>
            Assets are disposed on the main thread, but the disposal is scheduled from the worker threads.
            </summary>
        </member>
        <member name="F:Quantum.QuantumUnityDB._workedThreadLoadQueue">
            <summary>
            When loading assets on the main thread, the loading is scheduled from the worker threads.
            </summary>
        </member>
        <member name="F:Quantum.QuantumUnityDB._mainThreadId">
            <summary>
            Actual loading is done on the main thread, but the loading is scheduled from the worker threads.
            </summary>
        </member>
        <member name="F:Quantum.QuantumUnityDB._version">
            <summary>
            Increased every time the DB is updated.
            </summary>
        </member>
        <member name="P:Quantum.QuantumUnityDB.Entries">
            <summary>
            Exposes the list of entries in the DB. Can be used to iterate asset sources at both runtime and edit time.
            </summary>
        </member>
        <member name="E:Quantum.QuantumUnityDB.AssetObjectDisposing">
            <summary>
            Raised when an asset is unloaded.
            </summary>
        </member>
        <member name="M:Quantum.QuantumUnityDB.OnEnable">
            <summary>
            Initializes the DB with asset sources collected from the project.
            </summary>
        </member>
        <member name="M:Quantum.QuantumUnityDB.OnDisable">
            <summary>
            Disposes all the assets that have been loaded by the DB.
            </summary>
        </member>
        <member name="M:Quantum.QuantumUnityDB.UpdateGlobal">
            <summary>
            Updates <see cref="P:Quantum.QuantumUnityDB.Global"/> DB, if loaded. Must be called from the main thread. Call periodically, if assets are
            loaded/unloaded without the simulation running.
            </summary>
        </member>
        <member name="M:Quantum.QuantumUnityDB.UnloadGlobal">
            <summary>
            Unloads <see cref="P:Quantum.QuantumUnityDB.Global" />, if already loaded and unloads any asset that has been loaded.
            Next call to <see cref="P:Quantum.QuantumUnityDB.Global"/> will load the DB again.
            </summary>
        </member>
        <member name="M:Quantum.QuantumUnityDB.OnUnloadedAsGlobal(System.Boolean)">
            <summary>
            Unloads all the assets that have been loaded by the <see cref="P:Quantum.QuantumUnityDB.Global"/> DB.
            </summary>
            <param name="destroyed"></param>
        </member>
        <member name="P:Quantum.QuantumUnityDB.Version">
            <summary>
            A version number that is increased every time an asset is added or removed.
            </summary>
        </member>
        <member name="M:Quantum.QuantumUnityDB.AddSource(Quantum.IQuantumAssetObjectSource,Quantum.AssetGuid,System.String)">
            <summary>
            Registers a source for the asset with the given <paramref name="guid"/> and an optional <paramref name="path"/>.
            </summary>
            <param name="source"></param>
            <param name="guid"></param>
            <param name="path"></param>
        </member>
        <member name="M:Quantum.QuantumUnityDB.AddAsset(Quantum.AssetObject)">
            <summary>
            Registers a static asset. This is equivalent to calling <see cref="M:Quantum.QuantumUnityDB.AddSource(Quantum.IQuantumAssetObjectSource,Quantum.AssetGuid,System.String)"/> with a <see cref="T:Quantum.QuantumAssetObjectSourceStatic"/>.
            </summary>
            <param name="asset"></param>
        </member>
        <member name="M:Quantum.QuantumUnityDB.RemoveSource(Quantum.AssetGuid,System.ValueTuple{Quantum.IQuantumAssetObjectSource,System.Boolean}@)">
            <summary>
            Removes the source for the asset with the given <paramref name="guid"/>.
            </summary>
            <param name="guid"></param>
            <param name="result"></param>
            <returns><c>true</c> if there was a matching source to remove</returns>
        </member>
        <member name="M:Quantum.QuantumUnityDB.RemoveSource(Quantum.AssetGuid)">
            <summary>
            Removes the source for the asset with the given <paramref name="guid"/>.
            </summary>
            <param name="guid"></param>
            <returns><c>true</c> if there was a matching source to remove</returns>
        </member>
        <member name="P:Quantum.QuantumUnityDB.Global">
            <summary>
            Returns the global DB. If the DB is not loaded, it will be loaded.
            </summary>
        </member>
        <member name="M:Quantum.QuantumUnityDB.DisposeGlobalAsset(Quantum.AssetGuid,System.Boolean)">
            <inheritdoc cref="M:Quantum.QuantumUnityDB.DisposeAsset(Quantum.AssetGuid,System.Boolean)"/>
        </member>
        <member name="M:Quantum.QuantumUnityDB.FindGlobalAssetGuid(Quantum.AssetObjectQuery)">
            <summary>
            Finds the asset GUID based on the provided query.
            </summary>
            <param name="query">The query to filter the assets.</param>
            <returns>The asset GUID.</returns>
        </member>
        <member name="M:Quantum.QuantumUnityDB.FindGlobalAssetGuids(Quantum.AssetObjectQuery,System.Collections.Generic.List{Quantum.AssetGuid})">
            <summary>
            Finds the asset GUIDs based on the provided query.
            </summary>
            <param name="query">The query to filter the assets.</param>
            <param name="result">The list to store results.</param>
        </member>
        <member name="M:Quantum.QuantumUnityDB.FindGlobalAssetGuids(Quantum.AssetObjectQuery)">
            <summary>
            Finds the asset GUIDs based on the provided query.
            </summary>
            <param name="query">The query to filter the assets.</param>
            <returns>The list of asset GUIDs.</returns>
        </member>
        <member name="M:Quantum.QuantumUnityDB.GetGlobalAssetSource(Quantum.AssetGuid)">
            <inheritdoc cref="M:Quantum.QuantumUnityDB.GetAssetSource(Quantum.AssetGuid)"/>
        </member>
        <member name="M:Quantum.QuantumUnityDB.GetGlobalAssetSource(System.String)">
            <inheritdoc cref="M:Quantum.QuantumUnityDB.GetAssetSource(System.String)"/>
        </member>
        <member name="M:Quantum.QuantumUnityDB.GetGlobalAssetPath(Quantum.AssetGuid)">
            <inheritdoc cref="M:Quantum.QuantumUnityDB.GetAssetPath(Quantum.AssetGuid)"/>
        </member>
        <member name="M:Quantum.QuantumUnityDB.GetGlobalAssetGuid(System.String)">
            <inheritdoc cref="M:Quantum.QuantumUnityDB.GetAssetGuid(System.String)"/>
        </member>
        <member name="M:Quantum.QuantumUnityDB.GetGlobalAssetState(Quantum.AssetGuid)">
            <inheritdoc cref="M:Quantum.QuantumUnityDB.GetAssetState(Quantum.AssetGuid)"/>
        </member>
        <member name="M:Quantum.QuantumUnityDB.GetGlobalAssetType(Quantum.AssetGuid)">
            <inheritdoc cref="M:Quantum.QuantumUnityDB.GetAssetType(Quantum.AssetGuid)"/>
        </member>
        <member name="M:Quantum.QuantumUnityDB.GetGlobalAsset(Quantum.AssetRef)">
            <inheritdoc cref="M:Quantum.QuantumUnityDB.GetAsset(Quantum.AssetGuid)"/>
        </member>
        <member name="M:Quantum.QuantumUnityDB.GetGlobalAsset``1(Quantum.AssetRef{``0})">
            <inheritdoc cref="M:Quantum.QuantumUnityDB.GetAsset(Quantum.AssetGuid)"/>
            <returns>The loaded asset object or <c>null</c>, if not found or its type does not match <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:Quantum.QuantumUnityDB.GetGlobalAsset(System.String)">
            <summary>
            Gets an asset based on its path.
            </summary>
            <param name="assetPath">The path of the asset.</param>
            <returns>The asset object.</returns>
        </member>
        <member name="M:Quantum.QuantumUnityDB.TryGetGlobalAsset``1(Quantum.AssetGuid,``0@)">
            <summary>
            Tries to get an asset of type T from the global DB. Note that if type T is not the same as the asset type,
            the asset will remain loaded in the memory until it is disposed.
            </summary>
            <param name="assetGuid">The guid of the asset.</param>
            <param name="result">The result asset object.</param>
            <returns><see langword="true"/> if the asset of type T exists.</returns>
        </member>
        <member name="M:Quantum.QuantumUnityDB.TryGetGlobalAsset``1(Quantum.AssetRef,``0@)">
            <inheritdoc cref="M:Quantum.QuantumUnityDB.TryGetGlobalAsset``1(Quantum.AssetGuid,``0@)"/>
        </member>
        <member name="M:Quantum.QuantumUnityDB.TryGetGlobalAsset``1(Quantum.AssetRef{``0},``0@)">
            <inheritdoc cref="M:Quantum.QuantumUnityDB.TryGetGlobalAsset``1(Quantum.AssetGuid,``0@)"/>
        </member>
        <member name="M:Quantum.QuantumUnityDB.TryGetGlobalAsset``1(System.String,``0@)">
            <summary>
            Tries to get an asset of type T from the global DB. Note that if type T is not the same as the asset type,
            the asset will remain loaded in the memory until it is disposed.
            </summary>
            <param name="assetPath">The path of the asset.</param>
            <param name="result">The result asset object.</param>
            <returns><see langword="true"/> if the asset of type T exists.</returns>
        </member>
        <member name="M:Quantum.QuantumUnityDB.GetAssetSource(Quantum.AssetGuid)">
            <summary>
            Returns the asset source with the given <paramref name="assetGuid"/>. Asset does not get loaded in the process.
            </summary>
            <param name="assetGuid"></param>
            <returns>Asset source or <c>null</c> if the asset is not found</returns>
        </member>
        <member name="M:Quantum.QuantumUnityDB.GetAssetSource(System.String)">
            <summary>
            Returns the asset source with the given <paramref name="assetPath"/>. Asset does not get loaded in the process.
            </summary>
            <param name="assetPath"></param>
            <returns>Asset source or <c>null</c> if the asset is not found</returns>
        </member>
        <member name="M:Quantum.QuantumUnityDB.GetAssetGuid(System.String)">
            <summary>
            Converts a Quantum asset path to a Quantum asset guid.
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.QuantumUnityDB.GetAssetPath(Quantum.AssetGuid)">
            <summary>
            Returns path for the asset with the given <paramref name="assetGuid"/>. Asset does not get loaded in the process.
            </summary>
            <param name="assetGuid"></param>
            <returns>Asset path or an empty string, if not found</returns>
        </member>
        <member name="M:Quantum.QuantumUnityDB.DisposeAsset(Quantum.AssetGuid,System.Boolean)">
            <summary>
            Disposes the asset with the given <paramref name="guid"/>. If <paramref name="immediate"/> is <c>true</c>, the asset
            is disposed immediately, otherwise it's scheduled for disposal during the next update.
            </summary>
            <param name="guid"></param>
            <param name="immediate"></param>
            <returns><c>false</c> if the asset is not found</returns> 
            <exception cref="T:System.InvalidOperationException">If called from non-main thread</exception>
        </member>
        <member name="M:Quantum.QuantumUnityDB.DisposeAllAssetsImmediate">
            <summary>
            Disposes all the assets that have been loaded by the DB.
            </summary>
            <exception cref="T:System.InvalidOperationException">If called from non-main thread</exception>
        </member>
        <member name="M:Quantum.QuantumUnityDB.GetAsset(Quantum.AssetGuid)">
            <summary>
            Loads the asset with the given <paramref name="guid"/> synchronously.
            </summary>
            <param name="guid">Guid of the asset to load</param>
            <returns>Asset reference or <c>null</c> if the asset is not found</returns>
        </member>
        <member name="M:Quantum.QuantumUnityDB.LoadAssetAsync(Quantum.AssetGuid)">
            <summary>
            Loads the asset with the given <paramref name="guid"/> asynchronously.
            </summary>
            <param name="guid">Guid of the asset to load</param>
            <returns><c>false</c> if the asset is not found, <c>true</c> otherwise</returns>
        </member>
        <member name="M:Quantum.QuantumUnityDB.FindNextAssetGuid(Quantum.AssetObjectQuery@,Quantum.AssetGuid@)">
            <inheritdoc cref="M:Quantum.IResourceManager.FindNextAssetGuid(Quantum.AssetObjectQuery@,Quantum.AssetGuid@)"/>
        </member>
        <member name="M:Quantum.QuantumUnityDB.GetAssetState(Quantum.AssetGuid)">
            <inheritdoc cref="M:Quantum.IResourceManager.GetAssetState(Quantum.AssetGuid)"/>
        </member>
        <member name="M:Quantum.QuantumUnityDB.GetAssetType(Quantum.AssetGuid)">
            <summary>
            Returns the type of the asset with the given <paramref name="guid"/>. 
            </summary>
            <param name="guid">Guid of the asset to find</param>
            <returns><c>null</c> if the asset is not found or its source does not have type info, type instance otherwise.</returns>
        </member>
        <member name="T:Quantum.QuantumUnityDB.Entry">
            <summary>
            Internal representation of an asset in the DB. Serialized data remains immutable, while the runtime data is mutable.
            </summary>
        </member>
        <member name="F:Quantum.QuantumUnityDB.Entry.Path">
            <summary>
            Path of the asset. Optional or unique among all the assets.
            </summary>
        </member>
        <member name="F:Quantum.QuantumUnityDB.Entry.Guid">
            <summary>
            Guid of the asset. Unique among all the assets.
            </summary>
        </member>
        <member name="F:Quantum.QuantumUnityDB.Entry.LoadedAsset">
            <summary>
            Loaded asset instance.
            </summary>
        </member>
        <member name="F:Quantum.QuantumUnityDB.Entry.Source">
            <summary>
            Asset source.
            </summary>
        </member>
        <member name="F:Quantum.QuantumUnityDB.Entry.State">
            <summary>
            State of the asset.
            </summary>
        </member>
        <member name="M:Quantum.QuantumUnityDB.GetGlobalAssetEditorInstance(Quantum.AssetRef)">
            <inheritdoc cref="M:Quantum.QuantumUnityDB.GetAssetEditorInstance(Quantum.AssetRef)"/>
        </member>
        <member name="M:Quantum.QuantumUnityDB.GetGlobalAssetEditorInstance``1(Quantum.AssetRef{``0})">
            <inheritdoc cref="M:Quantum.QuantumUnityDB.GetAssetEditorInstance``1(Quantum.AssetRef{``0})"/>
        </member>
        <member name="M:Quantum.QuantumUnityDB.GetGlobalAssetEditorInstance``1(Quantum.AssetRef)">
            <inheritdoc cref="M:Quantum.QuantumUnityDB.GetAssetEditorInstance``1(Quantum.AssetRef)"/>
        </member>
        <member name="M:Quantum.QuantumUnityDB.GetAssetEditorInstance(Quantum.AssetRef)">
            <summary>
            Returns the editor instance of the asset with the given <paramref name="assetRef"/>. Use in editor code only, for inspectors
            and editors. Returned asset will not have its <see cref="M:Quantum.AssetObject.Loaded(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)"/> called, as instances are obtained
            from <see cref="P:Quantum.IQuantumAssetObjectSource.EditorInstance"/>.
            </summary>
            <param name="assetRef"></param>
            <returns>Asset instance or <c>null</c> if not found.</returns>
        </member>
        <member name="M:Quantum.QuantumUnityDB.GetAssetEditorInstance``1(Quantum.AssetRef{``0})">
            <inheritdoc cref="M:Quantum.QuantumUnityDB.GetAssetEditorInstance(Quantum.AssetRef)"/>
        </member>
        <member name="M:Quantum.QuantumUnityDB.GetAssetEditorInstance``1(Quantum.AssetRef)">
            <summary>
            Returns the editor instance of the asset with the given <paramref name="assetRef"/>. Use in editor code only, for inspectors
            and editors. Returned asset will not have its <see cref="M:Quantum.AssetObject.Loaded(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)"/> called, as instances are obtained
            from <see cref="P:Quantum.IQuantumAssetObjectSource.EditorInstance"/>.
            </summary>
            <param name="assetRef"></param>
            <returns>Asset instance or <c>null</c> if not found or the type does not match.</returns>
        </member>
        <member name="M:Quantum.QuantumUnityDB.TryGetGlobalAssetEditorInstance``1(Quantum.AssetRef,``0@)">
            <inheritdoc cref="M:Quantum.QuantumUnityDB.TryGetGlobalAssetEditorInstance``1(Quantum.AssetRef,``0@)"/>
        </member>
        <member name="M:Quantum.QuantumUnityDB.TryGetGlobalAssetEditorInstance``1(Quantum.AssetRef{``0},``0@)">
            <inheritdoc cref="M:Quantum.QuantumUnityDB.TryGetGlobalAssetEditorInstance``1(Quantum.AssetRef{``0},``0@)"/>
        </member>
        <member name="M:Quantum.QuantumUnityDB.TryGetAssetObjectEditorInstance``1(Quantum.AssetRef{``0},``0@)">
            <inheritdoc cref="M:Quantum.QuantumUnityDB.TryGetAssetObjectEditorInstance``1(Quantum.AssetRef,``0@)"/>
        </member>
        <member name="M:Quantum.QuantumUnityDB.TryGetAssetObjectEditorInstance``1(Quantum.AssetRef,``0@)">
            <summary>
            Attempts to get the editor instance of the asset with the given <paramref name="assetRef"/>. Use in editor code only, for inspectors
            and editors. Returned asset will not have its <see cref="M:Quantum.AssetObject.Loaded(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)"/> called, as instances are obtained
            from <see cref="P:Quantum.IQuantumAssetObjectSource.EditorInstance"/>.
            </summary>
            <param name="assetRef"></param>
            <param name="result"></param>
            <typeparam name="T"></typeparam>
            <returns><c>true</c> if the asset was found and the type matches, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Quantum.QuantumUnityDB.CreateAssetPathFromUnityPath(System.String,System.String)">
            <summary>
            Creates Quantum asset path based on the Unity asset path. The resulting path will have its extension removed.
            If the path is not in the "Assets" folder, it will be made relative to it.
            </summary>
            <param name="unityAssetPath"></param>
            <param name="nestedName"></param>
            <returns></returns>
        </member>
        <member name="T:Quantum.QuantumViewComponent`1">
            <summary>
            The base class to inherit entity view components from.
            Entity view components can be used to add features to entity views and gain simple access to all relevant Quantum game API and the Quantum entity.
            </summary>
            <typeparam name="T">The type of the custom view context used by this view component. Can be `IQuantumEntityViewContext` if not required.</typeparam>
        </member>
        <member name="P:Quantum.QuantumViewComponent`1.Game">
            <summary>
            The Game that the entity belongs to. This can change after the <see cref="M:Quantum.QuantumViewComponent`1.OnGameChanged"/> callback.
            Set before calling <see cref="M:Quantum.QuantumViewComponent`1.OnActivate(Quantum.Frame)"/>.
            </summary>
        </member>
        <member name="P:Quantum.QuantumViewComponent`1.PredictedFrame">
            <summary>
            The newest predicted frame.
            Set before calling <see cref="M:Quantum.QuantumViewComponent`1.OnActivate(Quantum.Frame)"/>.
            </summary>
        </member>
        <member name="P:Quantum.QuantumViewComponent`1.VerifiedFrame">
            <summary>
            The newest verified frame.
            Set before calling <see cref="M:Quantum.QuantumViewComponent`1.OnActivate(Quantum.Frame)"/>.
            </summary>
        </member>
        <member name="P:Quantum.QuantumViewComponent`1.PredictedPreviousFrame">
            <summary>
            The newest predicted previous frame.
            Set before calling <see cref="M:Quantum.QuantumViewComponent`1.OnActivate(Quantum.Frame)"/>.
            </summary>
        </member>
        <member name="P:Quantum.QuantumViewComponent`1.ViewContext">
            <summary>
            The view context of the <see cref="T:Quantum.QuantumEntityViewUpdater"/> associated with this entity view component.
            </summary>
        </member>
        <member name="P:Quantum.QuantumViewComponent`1.IsActive">
            <summary>
            Is the view component currently activated.
            </summary>
        </member>
        <member name="P:Quantum.QuantumViewComponent`1.IsInitialized">
            <summary>
            Returns true if the view component has been initialized.
            </summary>
        </member>
        <member name="F:Quantum.QuantumViewComponent`1._game">
            <summary>
            Cached game object is updated during <see cref="M:Quantum.QuantumViewComponent`1.Activate(Quantum.Frame,Quantum.QuantumGame,Quantum.QuantumEntityView)"/> and <see cref="M:Quantum.QuantumViewComponent`1.GameChanged(Quantum.QuantumGame)"/>.
            </summary>
        </member>
        <member name="F:Quantum.QuantumViewComponent`1._entityView">
            <summary>
            Cached entity view is updated during <see cref="M:Quantum.QuantumViewComponent`1.Activate(Quantum.Frame,Quantum.QuantumGame,Quantum.QuantumEntityView)"/>.
            </summary>
        </member>
        <member name="M:Quantum.QuantumViewComponent`1.OnInitialize">
            <summary>
            Is called when the entity view is enabled for the first time.
            The <see cref="P:Quantum.QuantumViewComponent`1.ViewContext"/> is already set if available.
            Access to <see cref="P:Quantum.QuantumViewComponent`1.Game"/>, <see cref="P:Quantum.QuantumViewComponent`1.VerifiedFrame"/>, <see cref="P:Quantum.QuantumViewComponent`1.PredictedFrame"/> and <see cref="P:Quantum.QuantumViewComponent`1.PredictedPreviousFrame"/> is not available yet.
            </summary>
        </member>
        <member name="M:Quantum.QuantumViewComponent`1.OnActivate(Quantum.Frame)">
            <summary>
            Is called when the entity view is activated and the entity was created.
            </summary>
            <param name="frame">The frame that the entity was created with, can be predicted or verified base on the <see cref="T:Quantum.QuantumEntityViewBindBehaviour"></see></param>.
        </member>
        <member name="M:Quantum.QuantumViewComponent`1.OnDeactivate">
            <summary>
            Is called when the view component is deactivated.
            </summary>
        </member>
        <member name="M:Quantum.QuantumViewComponent`1.OnUpdateView">
            <summary>
            Is called from the <see cref="T:Quantum.QuantumEntityViewUpdater"/> on a Unity update.
            </summary>
        </member>
        <member name="M:Quantum.QuantumViewComponent`1.OnLateUpdateView">
            <summary>
            Is called from the <see cref="T:Quantum.QuantumEntityViewUpdater"/> on a Unity late update.
            </summary>
        </member>
        <member name="M:Quantum.QuantumViewComponent`1.OnGameChanged">
            <summary>
            Is called from the <see cref="T:Quantum.QuantumEntityViewUpdater"/> then the observed game is changed.
            </summary>
        </member>
        <member name="M:Quantum.QuantumViewComponent`1.Initialize(System.Collections.Generic.Dictionary{System.Type,Quantum.IQuantumViewContext})">
            <summary>
            Is only called internally.
            Sets the view context of this entity view component.
            </summary>
            <param name="contexts">All of the different contexts of the EntityViewUpdater, will select the matching type.</param>
        </member>
        <member name="M:Quantum.QuantumViewComponent`1.Activate(Quantum.Frame,Quantum.QuantumGame,Quantum.QuantumEntityView)">
            <summary>
            Is only called internally.
            Sets the entity view parent.
            </summary>
            <param name="frame"></param>
            <param name="game"></param>
            <param name="entityView"></param>
        </member>
        <member name="M:Quantum.QuantumViewComponent`1.Deactivate">
            <summary>
            Is only called internally.
            </summary>
        </member>
        <member name="M:Quantum.QuantumViewComponent`1.UpdateView">
            <summary>
            Is only called internally.
            </summary>
        </member>
        <member name="M:Quantum.QuantumViewComponent`1.LateUpdateView">
            <summary>
            Is only called internally.
            </summary>
        </member>
        <member name="M:Quantum.QuantumViewComponent`1.GameChanged(Quantum.QuantumGame)">
            <summary>
            Is only called internally.
            </summary>
        </member>
        <member name="T:Quantum.QuantumMultiClientRunner">
            <summary>
              The script will can manage multiple online clients and Quantum players in your Editor. This means the remote view of
              your player can be visualized in the same Unity instance.
              Minimum settings:
              * Requires a valid AppId and working network settings in Photon Server Settings
              * Drag the QuantumMultiClientRunner prefab into you Quantum game scene (this works similar to the default Runner except it does not reload the Unity scene)
              * Add game objects that belong to the regular Quantum scene to DisableOnStart (QuantumDefaultRunner, QuantumEntityViewUpdater, Your Input Script, CustomCallbacks)
              * The PlayerInputTemplate is instantiated for each client to gather input by firing the Unity message PollInput(CallbackPollInput c). Implement input in the format below.
              * Press "New Client" to add additional online players
              I = toggle input of the player
              V = toggle view of the player
              G = toggle gizmos of the player
              X = quit player
              0-9 = Add a local player slot
              SHIFT+0-9 = remove local player slot
              * If you don't experience ghosting try a different cloud that if farther away from you (Fixed Region 'sa' for example)
              * Enable AddAsLocalPlayers to add new players as local players instead of each having a separate connection.
            </summary>
            <example><code>
            public class QuantumMultiClientTestInput : QuantumMonoBehaviour {
              private void PollInput(CallbackPollInput c) {
                var i = new Quantum.Input();
                i.Direction.X = 1;
                i.Direction.Y = 0;
                c.SetInput(i, DeterministicInputFlags.Repeatable);
              }
            }
            </code></example>
        </member>
        <member name="F:Quantum.QuantumMultiClientRunner.PlayerViewTemplate">
            <summary>
            Get instantiated for each client and makes connection controls for that client available.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMultiClientRunner.CreatePlayerBtn">
            <summary>
            The button to create a new client connection.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMultiClientRunner.DisableOnStart">
            <summary>
            Quantum scripts in your game scene that are part of the regular setup like QuantumEntityViewUpdater,
            Input and CustomCallbacks need to be disabled when using the MultiClientRunner, add them here.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMultiClientRunner.GizmosSettings">
            <summary>
            Optionally provide non-default editor settings for all additional clients after the first one (to change the gizmo colors for example).
            </summary>
        </member>
        <member name="F:Quantum.QuantumMultiClientRunner.ServerSettings">
            <summary>
            Optionally provide different non-default server app settings.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMultiClientRunner.SessionConfig">
            <summary>
            Add a session config here.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMultiClientRunner.RuntimeConfig">
            <summary>
            Add custom runtime config settings here
            </summary>
        </member>
        <member name="F:Quantum.QuantumMultiClientRunner.PlayerCount">
            <summary>
            Set the max player count
            </summary>
        </member>
        <member name="F:Quantum.QuantumMultiClientRunner.InitialClientCount">
            <summary>
            How many clients to start with when starting the app.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMultiClientRunner.InitialPlayerCount">
            <summary>
            How many additional players per client to start with when starting the app.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMultiClientRunner.InitialPlayerDelayInSec">
            <summary>
            Start initial clients and players with an extra delay.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMultiClientRunner.RuntimePlayer">
            <summary>
            Add custom runtime player settings here.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMultiClientRunner.PlayerInputTemplate">
            <summary>
            Provide a player input template that is instantiated for the clients. 
            A Unity script that has to implement void Unity message PollInput(CallbackPollInput c).
            </summary>
        </member>
        <member name="F:Quantum.QuantumMultiClientRunner.EntityViewUpdaterTemplate">
            <summary>
            Optionally provide a custom QuantumEntityViewUpdater game object template that is instantiated for the clients 
            (otherwise a new instance of QuantumEntityViewUpdater is created for each player).
            </summary>
        </member>
        <member name="F:Quantum.QuantumMultiClientRunner.UseRandomMatchmaking">
            <summary>
            Use random matchmaking or let subsequent players join the primary players room.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMultiClientRunner.UsePrivateAppVersion">
            <summary>
            Use a private AppVersion when connecting to isolate matchmaking players
            </summary>
        </member>
        <member name="M:Quantum.QuantumMultiClientRunner.Start">
            <summary>
            Unity Start method. 
            Toggles game objects and create initial clients.
            </summary>
        </member>
        <member name="M:Quantum.QuantumMultiClientRunner.OnEnable">
            <summary>
            Unity OnEnabled method, subscribes to relevant Quantum callbacks.
            </summary>
        </member>
        <member name="M:Quantum.QuantumMultiClientRunner.OnDisable">
            <summary>
            Unity OnDisabled method.
            Removes subscriptions from GUI buttons.
            Quantum subscriptions are automatically removed.
            </summary>
        </member>
        <member name="M:Quantum.QuantumMultiClientRunner.CreateNewClient">
            <summary>
            Create a new client.
            </summary>
        </member>
        <member name="M:Quantum.QuantumMultiClientRunner.CreateNewConnectedPlayer">
            <summary>
            Create and connect a new client.
            </summary>
        </member>
        <member name="M:Quantum.QuantumMultiClientRunner.CreateNewLocalPlayer(Quantum.QuantumMultiClientPlayer)">
            <summary>
            Create a new player for a connected client.
            </summary>
            <param name="mainPlayer">The connection that the player should be added to</param>
        </member>
        <member name="M:Quantum.QuantumMultiClientRunner.DestroyPlayer(Quantum.QuantumMultiClientPlayer)">
            <summary>
            MultiClientPlayer class uses this to signal a player quits.
            </summary>
            <param name="player">Player class</param>
        </member>
        <member name="M:Quantum.QuantumMultiClientRunner.OnRunnerShutdown(Quantum.ShutdownCause,Quantum.SessionRunner)">
            <summary>
            Is called when the QuantumRunner terminates, on request or any connection error.
            </summary>
            <param name="cause">The shutdown cause</param>
            <param name="runner">The associated QuantumRunner</param>
        </member>
        <member name="T:Quantum.UnityCallbackId">
            <summary>
            IDs for Unity-specific callbacks.
            </summary>
        </member>
        <member name="F:Quantum.UnityCallbackId.UnitySceneLoadBegin">
            <summary>
            Scene load begins.
            </summary>
        </member>
        <member name="F:Quantum.UnityCallbackId.UnitySceneLoadDone">
            <summary>
            Scene load is done.
            </summary>
        </member>
        <member name="F:Quantum.UnityCallbackId.UnitySceneUnloadBegin">
            <summary>
            Scene unload begins.
            </summary>
        </member>
        <member name="F:Quantum.UnityCallbackId.UnitySceneUnloadDone">
            <summary>
            Scene unload is done.
            </summary>
        </member>
        <member name="F:Quantum.UnityCallbackId.UserCallbackIdStart">
            <summary>
            Callback ID start for user callbacks.
            </summary>
        </member>
        <member name="T:Quantum.ICallbackUnityScene">
            <summary>
            An interface for callbacks that are related to Unity scenes.
            </summary>
        </member>
        <member name="P:Quantum.ICallbackUnityScene.SceneName">
            <summary>
            Name of the scene.
            </summary>
        </member>
        <member name="T:Quantum.CallbackUnitySceneLoadBegin">
            <summary>
            Callback sent when a Unity scene load begins.
            To enable this feature <see cref="F:Quantum.SimulationConfig.AutoLoadSceneFromMap"/> must be toggled on.
            </summary>
        </member>
        <member name="F:Quantum.CallbackUnitySceneLoadBegin.ID">
            <summary>
            ID of the callback.
            </summary>
        </member>
        <member name="M:Quantum.CallbackUnitySceneLoadBegin.#ctor(Quantum.QuantumGame)">
            <summary>
            Initializes a new instance.
            </summary>
            <param name="game"></param>
        </member>
        <member name="P:Quantum.CallbackUnitySceneLoadBegin.SceneName">
            <inheritdoc cref="P:Quantum.ICallbackUnityScene.SceneName"/>
        </member>
        <member name="T:Quantum.CallbackUnitySceneLoadDone">
            <summary>
            Callback sent when a Unity scene load is done.
            </summary>
        </member>
        <member name="F:Quantum.CallbackUnitySceneLoadDone.ID">
            <summary>
            ID of the callback.
            </summary>
        </member>
        <member name="M:Quantum.CallbackUnitySceneLoadDone.#ctor(Quantum.QuantumGame)">
            <summary>
            Initializes a new instance.
            </summary>
            <param name="game"></param>
        </member>
        <member name="P:Quantum.CallbackUnitySceneLoadDone.SceneName">
            <inheritdoc cref="P:Quantum.ICallbackUnityScene.SceneName"/>
        </member>
        <member name="T:Quantum.CallbackUnitySceneUnloadBegin">
            <summary>
            Callback sent when a Unity scene unload begins.
            </summary>
        </member>
        <member name="F:Quantum.CallbackUnitySceneUnloadBegin.ID">
            <summary>
            ID of the callback.
            </summary>
        </member>
        <member name="M:Quantum.CallbackUnitySceneUnloadBegin.#ctor(Quantum.QuantumGame)">
            <summary>
            Initializes a new instance.
            </summary>
            <param name="game"></param>
        </member>
        <member name="P:Quantum.CallbackUnitySceneUnloadBegin.SceneName">
            <inheritdoc cref="P:Quantum.ICallbackUnityScene.SceneName"/>
        </member>
        <member name="T:Quantum.CallbackUnitySceneUnloadDone">
            <summary>
            Callback sent when a Unity scene unload is done.
            </summary>
        </member>
        <member name="F:Quantum.CallbackUnitySceneUnloadDone.ID">
            <summary>
            ID of the callback.
            </summary>
        </member>
        <member name="M:Quantum.CallbackUnitySceneUnloadDone.#ctor(Quantum.QuantumGame)">
            <summary>
            Initializes a new instance.
            </summary>
            <param name="game"></param>
        </member>
        <member name="P:Quantum.CallbackUnitySceneUnloadDone.SceneName">
            <inheritdoc cref="P:Quantum.ICallbackUnityScene.SceneName"/>
        </member>
        <member name="T:Quantum.QuantumDebugInput">
            <summary>
            A Unity script that creates empty input for any Quantum game.
            </summary>
        </member>
        <member name="M:Quantum.QuantumDebugInput.PollInput(Quantum.CallbackPollInput)">
            <summary>
            Set an empty input when polled by the simulation.
            </summary>
            <param name="callback"></param>
        </member>
        <member name="T:Quantum.NavMeshBakerBenchmarkerProgressBar">
            <summary>
            An implementation of the <see cref="T:Quantum.IProgressBar"/> used for the navmesh baking.
            The internal baking process will set additional information on this class.
            The progress bar is only showed when the LogLevel is set to Debug.
            </summary>
        </member>
        <member name="T:Quantum.NavMeshBakerBenchmarkerProgressBar.BakeSection">
            <summary>
            Navmesh bake section used to display information on the progress bar.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBakerBenchmarkerProgressBar.BakeSection.Name">
            <summary>
            The section name.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBakerBenchmarkerProgressBar.BakeSection.TimeInMs">
            <summary>
            The time spent in milliseconds in this section.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBakerBenchmarkerProgressBar.EnableProgressBar">
            <summary>
            Set to disable the Unity progress bar.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBakerBenchmarkerProgressBar.EnableResultLog">
            <summary>
            Set to disable the result log.
            </summary>
        </member>
        <member name="M:Quantum.NavMeshBakerBenchmarkerProgressBar.#ctor(System.String)">
            <summary>
            Create a new instance of the progress bar.
            </summary>
            <param name="name">Progress bar name</param>
        </member>
        <member name="M:Quantum.NavMeshBakerBenchmarkerProgressBar.SetInfo(System.String)">
            <summary>
            Complete the current section, add a new section to the progress bar and restart the timer.
            </summary>
            <param name="v">Section name</param>
        </member>
        <member name="M:Quantum.NavMeshBakerBenchmarkerProgressBar.SetProgress(System.Single)">
            <summary>
            Set the progress of the current section.
            </summary>
            <param name="v">Progress between 0..1</param>
        </member>
        <member name="M:Quantum.NavMeshBakerBenchmarkerProgressBar.Dispose">
            <summary>
            Complete, dispose the progress bar and logs a result.
            </summary>
        </member>
        <member name="T:Quantum.QuantumCallback">
            <summary>
            Quantum callbacks are special types of events that are triggered internally by the Quantum simulation.
            For example CallbackUpdateView for Unity updates, CallbackPollInput that polls for player input.
            Use this class to subscribe and unsubscribe from Quantum callbacks.
            </summary>
            <example><code>
            // Use this signature when subscribing from a MonoBehaviour, the subscription will be automatically removed when the MonoBehaviour is destroyed.
            QuantumCallback.Subscribe(this, (CallbackUpdateView c) => { Log.Debug(c.Game.Frames.Verified.Number); });
            // Use this signature when manually disposing the subscription.
            var subscription = QuantumCallback.SubscribeManual((CallbackUpdateView c) => { Log.Debug(c.Game.Frames.Verified.Number); });
            subscription.Dispose();
            </code></example>
        </member>
        <member name="T:Quantum.QuantumUnityCallbackDispatcher">
            <summary>
            <see cref="T:Quantum.CallbackDispatcher"/> implementation for Unity. Adds Unity specific callback types. Additional user callback
            types can be added via partial method. 
            </summary>
        </member>
        <member name="M:Quantum.QuantumUnityCallbackDispatcher.#ctor">
            <summary>
            Initializes the dispatcher with the built-in and user defined callback types.
            </summary>
        </member>
        <member name="M:Quantum.QuantumUnityCallbackDispatcher.GetListenerStatus(System.Object,System.UInt32)">
            <inheritdoc cref="M:Quantum.IQuantumUnityDispatcherExtensions.GetUnityListenerStatus(Quantum.IQuantumUnityDispatcher,System.Object,System.UInt32)"/>
        </member>
        <member name="T:Quantum.QuantumStaticCapsuleCollider2D">
            <summary>
            The script will create a static 2D capsule collider during Quantum map baking.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticCapsuleCollider2D.SourceCollider">
            <summary>
            Link a Unity capsule collider to copy its size and position of during Quantum map baking.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticCapsuleCollider2D.Size">
            <summary>
            Define the capsule size if not source collider exists. The x-axis is the diameter and the y-axis is the height.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticCapsuleCollider2D.PositionOffset">
            <summary>
            The position offset added to the <see cref="P:UnityEngine.Transform.position"/> during baking.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticCapsuleCollider2D.RotationOffset">
            <summary>
            The rotation offset added to the <see cref="P:UnityEngine.Transform.rotation"/> during baking.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticCapsuleCollider2D.Settings">
            <summary>
            Additional static collider settings.
            </summary>
        </member>
        <member name="M:Quantum.QuantumStaticCapsuleCollider2D.UpdateFromSourceCollider">
            <summary>
            Copy collider configuration from source collider if exist. 
            </summary>
        </member>
        <member name="M:Quantum.QuantumStaticCapsuleCollider2D.BeforeBake">
            <summary>
            Callback before baking the collider.
            </summary>
        </member>
        <member name="T:Quantum.QuantumUnityStaticDispatcherAdapter`2">
            <summary>
            Adapter for static dispatchers in Unity. Provides utility static methods, internal worker that removes dead listeners and means for creating a dispatcher.
            </summary>
            <typeparam name="TDispatcher"></typeparam>
            <typeparam name="TDispatchableBase"></typeparam>
        </member>
        <member name="P:Quantum.QuantumUnityStaticDispatcherAdapter`2.Dispatcher">
            <summary>
            The dispatcher instance.
            </summary>
        </member>
        <member name="M:Quantum.QuantumUnityStaticDispatcherAdapter`2.Clear">
            <summary>
            Removes all listeners and destroys the worker object.
            </summary>
        </member>
        <member name="M:Quantum.QuantumUnityStaticDispatcherAdapter`2.RemoveDeadListeners">
            <summary>
            Removes dead listeners from the dispatcher.
            </summary>
        </member>
        <member name="M:Quantum.QuantumUnityStaticDispatcherAdapter`2.Subscribe``1(UnityEngine.Object,Quantum.DispatchableHandler{``0},Quantum.DispatchableFilter,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Creates a subscription. The subscription lifetime is tied to the listener object, unless explicitly unsubscribed.
            </summary>
            <typeparam name="TDispatchable"></typeparam>
            <param name="listener">An object listening. Used to unsubscribe all subscriptions when the object is destroyed.</param>
            <param name="handler">Actual event handler.</param>
            <param name="once">Call <paramref name="handler"/> only once.</param>
            <param name="filter">Optional event filter. If returns false, handler will not be invoked.</param>
            <param name="onlyIfActiveAndEnabled">Only invoke handler if the listener is active and enabled</param>
            <param name="onlyIfEntityViewBound">Only invoke handler if the listener <see cref="T:Quantum.QuantumEntityView"/> component and it is bound to an entity</param>
            <returns>Subscription that can be stored and used in <see cref="M:Quantum.QuantumUnityStaticDispatcherAdapter`2.Unsubscribe(Quantum.DispatcherSubscription)"/></returns>
        </member>
        <member name="M:Quantum.QuantumUnityStaticDispatcherAdapter`2.Subscribe``1(UnityEngine.Object,Quantum.DispatchableHandler{``0},Photon.Deterministic.DeterministicGameMode,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Creates a subscription. The subscription lifetime is tied to the listener object, unless explicitly unsubscribed.
            </summary>
            <typeparam name="TDispatchable"></typeparam>
            <param name="listener">An object listening. Used to unsubscribe all subscriptions when the object is destroyed.</param>
            <param name="handler">Actual event handler.</param>
            <param name="once">Call <paramref name="handler"/> only once.</param>
            <param name="gameMode">Only invoke for a specific game mode</param>
            <param name="exclude">If true, the handler will be invoked for all game modes except the specified one</param>
            <param name="onlyIfActiveAndEnabled">Only invoke handler if the listener is active and enabled</param>
            <param name="onlyIfEntityViewBound">Only invoke handler if the listener <see cref="T:Quantum.QuantumEntityView"/> component and it is bound to an entity</param>
            <returns>Subscription that can be stored and used in <see cref="M:Quantum.QuantumUnityStaticDispatcherAdapter`2.Unsubscribe(Quantum.DispatcherSubscription)"/></returns>
        </member>
        <member name="M:Quantum.QuantumUnityStaticDispatcherAdapter`2.Subscribe``1(UnityEngine.Object,Quantum.DispatchableHandler{``0},Photon.Deterministic.DeterministicGameMode[],System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Creates a subscription. The subscription lifetime is tied to the listener object, unless explicitly unsubscribed.
            </summary>
            <typeparam name="TDispatchable"></typeparam>
            <param name="listener">An object listening. Used to unsubscribe all subscriptions when the object is destroyed.</param>
            <param name="handler">Actual event handler.</param>
            <param name="once">Call <paramref name="handler"/> only once.</param>
            <param name="gameModes">Only invoke for specific game modes</param>
            <param name="exclude">If true, the handler will be invoked for all game modes except the specified ones</param>
            <param name="onlyIfActiveAndEnabled">Only invoke handler if the listener is active and enabled</param>
            <param name="onlyIfEntityViewBound">Only invoke handler if the listener <see cref="T:Quantum.QuantumEntityView"/> component and it is bound to an entity</param>
            <returns>Subscription that can be stored and used in <see cref="M:Quantum.QuantumUnityStaticDispatcherAdapter`2.Unsubscribe(Quantum.DispatcherSubscription)"/></returns>
        </member>
        <member name="M:Quantum.QuantumUnityStaticDispatcherAdapter`2.Subscribe``1(UnityEngine.Object,Quantum.DispatchableHandler{``0},System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Creates a subscription. The subscription lifetime is tied to the listener object, unless explicitly unsubscribed.
            </summary>
            <typeparam name="TDispatchable"></typeparam>
            <param name="listener">An object listening. Used to unsubscribe all subscriptions when the object is destroyed.</param>
            <param name="handler">Actual event handler.</param>
            <param name="once">Call <paramref name="handler"/> only once.</param>
            <param name="runnerId">Only invoke for a QuantumRunner with a specific ID</param>
            <param name="onlyIfActiveAndEnabled">Only invoke handler if the listener is active and enabled</param>
            <param name="onlyIfEntityViewBound">Only invoke handler if the listener <see cref="T:Quantum.QuantumEntityView"/> component and it is bound to an entity</param>
            <returns>Subscription that can be stored and used in <see cref="M:Quantum.QuantumUnityStaticDispatcherAdapter`2.Unsubscribe(Quantum.DispatcherSubscription)"/></returns>
        </member>
        <member name="M:Quantum.QuantumUnityStaticDispatcherAdapter`2.Subscribe``1(UnityEngine.Object,Quantum.DispatchableHandler{``0},Quantum.QuantumRunner,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Creates a subscription. The subscription lifetime is tied to the listener object, unless explicitly unsubscribed.
            </summary>
            <typeparam name="TDispatchable"></typeparam>
            <param name="listener">An object listening. Used to unsubscribe all subscriptions when the object is destroyed.</param>
            <param name="handler">Actual event handler.</param>
            <param name="once">Call <paramref name="handler"/> only once.</param>
            <param name="runner">Only invoke for a QuantumRunner instance</param>
            <param name="onlyIfActiveAndEnabled">Only invoke handler if the listener is active and enabled</param>
            <param name="onlyIfEntityViewBound">Only invoke handler if the listener <see cref="T:Quantum.QuantumEntityView"/> component and it is bound to an entity</param>
            <returns>Subscription that can be stored and used in <see cref="M:Quantum.QuantumUnityStaticDispatcherAdapter`2.Unsubscribe(Quantum.DispatcherSubscription)"/></returns>
        </member>
        <member name="M:Quantum.QuantumUnityStaticDispatcherAdapter`2.Subscribe``1(UnityEngine.Object,Quantum.DispatchableHandler{``0},Quantum.QuantumGame,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Creates a subscription. The subscription lifetime is tied to the listener object, unless explicitly unsubscribed.
            </summary>
            <typeparam name="TDispatchable"></typeparam>
            <param name="listener">An object listening. Used to unsubscribe all subscriptions when the object is destroyed.</param>
            <param name="handler">Actual event handler.</param>
            <param name="once">Call <paramref name="handler"/> only once.</param>
            <param name="game">Only invoke for a QuantumGame instance</param>
            <param name="onlyIfActiveAndEnabled">Only invoke handler if the listener is active and enabled</param>
            <param name="onlyIfEntityViewBound">Only invoke handler if the listener <see cref="T:Quantum.QuantumEntityView"/> component and it is bound to an entity</param>
            <returns>Subscription that can be stored and used in <see cref="M:Quantum.QuantumUnityStaticDispatcherAdapter`2.Unsubscribe(Quantum.DispatcherSubscription)"/></returns>
        </member>
        <member name="M:Quantum.QuantumUnityStaticDispatcherAdapter`2.SubscribeManual``1(System.Object,Quantum.DispatchableHandler{``0},Quantum.DispatchableFilter,System.Boolean)">
            <inheritdoc cref="M:Quantum.DispatcherBase.SubscribeManual``1(System.Object,Quantum.DispatchableHandler{``0},System.Boolean,Quantum.DispatchableFilter)"/>
        </member>
        <member name="M:Quantum.QuantumUnityStaticDispatcherAdapter`2.SubscribeManual``1(Quantum.DispatchableHandler{``0},Quantum.DispatchableFilter,System.Boolean)">
            <inheritdoc cref="M:Quantum.DispatcherBase.SubscribeManual``1(Quantum.DispatchableHandler{``0},System.Boolean,Quantum.DispatchableFilter)"/>
        </member>
        <member name="M:Quantum.QuantumUnityStaticDispatcherAdapter`2.Unsubscribe(Quantum.DispatcherSubscription)">
            <inheritdoc cref="M:Quantum.DispatcherBase.Unsubscribe(Quantum.DispatcherSubscription)"/>
        </member>
        <member name="M:Quantum.QuantumUnityStaticDispatcherAdapter`2.UnsubscribeListener(System.Object)">
            <inheritdoc cref="M:Quantum.DispatcherBase.UnsubscribeListener(System.Object)"/>
        </member>
        <member name="M:Quantum.QuantumUnityStaticDispatcherAdapter`2.UnsubscribeListener``1(System.Object)">
            <inheritdoc cref="M:Quantum.DispatcherBase.UnsubscribeListener``1(System.Object)"/>
        </member>
        <member name="T:Quantum.QuantumInspectorAttribute">
            <summary>
            Obsolete attribute for Quantum 2 compatibility. Non functional in Quantum 3.
            </summary>
        </member>
        <member name="T:Quantum.QuantumGlobalScriptableObject`1">
            <inheritdoc cref="T:Quantum.QuantumGlobalScriptableObject`1"/>
        </member>
        <member name="P:Quantum.QuantumGlobalScriptableObject`1.Instance">
            <summary>
            Obsolete
            </summary>
        </member>
        <member name="P:Quantum.QuantumGlobalScriptableObject`1.Global">
            <summary>
            Get or set the Global instance of the scriptable object.
            </summary>
        </member>
        <member name="M:Quantum.QuantumGlobalScriptableObject`1.TryGetGlobal(`0@)">
            <summary>
            Try get or load the global instance.
            </summary>
            <param name="global">Resulting global instance</param>
            <returns>True if the global instance was found</returns>
        </member>
        <member name="P:Quantum.QuantumGlobalScriptableObject`1.IsGlobal">
            <summary>
            Is this instance a global instance.
            </summary>
        </member>
        <member name="M:Quantum.QuantumGlobalScriptableObject`1.OnLoadedAsGlobal">
            <summary>
            Invoked when the instance is loaded as global.
            </summary>
        </member>
        <member name="M:Quantum.QuantumGlobalScriptableObject`1.OnUnloadedAsGlobal(System.Boolean)">
            <summary>
            Invoked when the instance is unloaded as global.
            </summary>
            <param name="destroyed"></param>
        </member>
        <member name="M:Quantum.QuantumGlobalScriptableObject`1.OnDisable">
            <summary>
            If the current instance is global, unsets <see cref="P:Quantum.QuantumGlobalScriptableObject`1.IsGlobal"/> and calls <see cref="M:Quantum.QuantumGlobalScriptableObject`1.OnUnloadedAsGlobal(System.Boolean)"/>
            </summary>
        </member>
        <member name="P:Quantum.QuantumGlobalScriptableObject`1.GlobalInternal">
            <summary>
            A singleton instance-like property. Loads or returns the current global instance. Derived classes can package it in a property
            with a different name. Throws if loading an instance failed.
            </summary>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="P:Quantum.QuantumGlobalScriptableObject`1.IsGlobalLoadedInternal">
            <summary>
            Returns true if a global instance is loaded. Compared to <see cref="P:Quantum.QuantumGlobalScriptableObject`1.GlobalInternal"/>, it does not attempt to load an instance.
            </summary>
        </member>
        <member name="M:Quantum.QuantumGlobalScriptableObject`1.TryGetGlobalInternal(`0@)">
            <summary>
            Loads or returns the current global instance. Returns <see langword="null"/> if loading an instance failed.
            </summary>
            <param name="global"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.QuantumGlobalScriptableObject`1.UnloadGlobalInternal">
            <summary>
            Unloads the global instance if it is loaded.
            </summary>
            <returns><see langword="true"/> if an instance was unloaded</returns>
        </member>
        <member name="T:Quantum.QuantumInstantReplaySeekMode">
            <summary>
            A mode to seek running instant replays to a desired frame.
            </summary>
        </member>
        <member name="F:Quantum.QuantumInstantReplaySeekMode.Disabled">
            <summary>
            Feature disabled.
            </summary>
        </member>
        <member name="F:Quantum.QuantumInstantReplaySeekMode.FromStartSnapshot">
            <summary>
            Start from the first snapshot and seek to the desired frame.
            </summary>
        </member>
        <member name="F:Quantum.QuantumInstantReplaySeekMode.FromIntermediateSnapshots">
            <summary>
            Start from intermediate snapshots if available.
            </summary>
        </member>
        <member name="T:Quantum.QuantumInstantReplay">
            <summary>
            The instant replay feature.
            It can be used as is or used as a base class for custom instant replay implementations.
            </summary>
        </member>
        <member name="F:Quantum.QuantumInstantReplay.InitialFramesToSimulation">
            <summary>
            We need this to fast forward the simulation and wait until is fully initialized.
            </summary>
        </member>
        <member name="P:Quantum.QuantumInstantReplay.StartFrame">
            <summary>
            Returns the frame number the instant replay started from.
            </summary>
        </member>
        <member name="P:Quantum.QuantumInstantReplay.CurrentFrame">
            <summary>
            Returns current frame number of the replay.
            </summary>
        </member>
        <member name="P:Quantum.QuantumInstantReplay.EndFrame">
            <summary>
            Returns the last frame number of the replay which is usually the end frame of the original game when the instant replay was started.
            </summary>
        </member>
        <member name="P:Quantum.QuantumInstantReplay.CanSeek">
            <summary>
            Returns true if the instant replay can seek to a desired frame.
            </summary>
        </member>
        <member name="P:Quantum.QuantumInstantReplay.IsRunning">
            <summary>
            Returns true is the instant replay is running.
            </summary>
        </member>
        <member name="P:Quantum.QuantumInstantReplay.LiveGame">
            <summary>
            Returns the live Quantum Game.
            </summary>
        </member>
        <member name="P:Quantum.QuantumInstantReplay.ReplayGame">
            <summary>
            Returns the replay Quantum Game or null.
            </summary>
        </member>
        <member name="P:Quantum.QuantumInstantReplay.NormalizedTime">
            <summary>
            Returns the progress or normalized time [0..1] of the instant replay.
            </summary>
        </member>
        <member name="M:Quantum.QuantumInstantReplay.#ctor(Quantum.QuantumGame,System.Single,Quantum.QuantumInstantReplaySeekMode,System.Boolean)">
            <summary>
            Create and start an instant replay.
            </summary>
            <param name="liveGame">The original game.</param>
            <param name="length">The time in seconds to rewind the original game and start the instant replay from.</param>
            <param name="seekMode">An optional seek mode to seek and rewind the running instant replay.</param>
            <param name="loop">Automatically loop the instant replay and never stop.</param>
            <exception cref="T:System.ArgumentNullException">Is raised when the live game is null.</exception>
            <exception cref="T:System.ArgumentException">Is raised when no valid snapshot was found to start the replay from.</exception>
        </member>
        <member name="M:Quantum.QuantumInstantReplay.Dispose">
            <summary>
            Stop and dispose the instant replay by clearing cached snapshots and shutting down the replay runner.
            </summary>
        </member>
        <member name="M:Quantum.QuantumInstantReplay.SeekFrame(System.Int32)">
            <summary>
            Seek to a desired frame number during the running instant replay.
            </summary>
            <param name="frameNumber">Desired frame number.</param>
            <exception cref="T:System.InvalidOperationException">Is raised when the replay is not seek-able.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Is raised when the desired frame could not be reached by the cached snapshots.</exception>
        </member>
        <member name="M:Quantum.QuantumInstantReplay.SeekNormalizedTime(System.Single)">
            <summary>
            Seek the replay by inputting a normalized time [0..1].
            </summary>
            <param name="normalizedTime">Replay progress between 0 and 1.</param>
        </member>
        <member name="M:Quantum.QuantumInstantReplay.Update(System.Single)">
            <summary>
            Updates the instant replay session. Will loop the replay if enabled.
            </summary>
            <param name="deltaTime">Passed delta time in seconds.</param>
            <returns>Returns true is the replay is complete.</returns>
        </member>
        <member name="T:Quantum.GameObjectUtils">
            <summary>
            Unity game object utility methods for Quantum.
            </summary>
        </member>
        <member name="M:Quantum.GameObjectUtils.Show(UnityEngine.GameObject[])">
            <summary>
            Showing will <see cref="M:UnityEngine.GameObject.SetActive(System.Boolean)"/> to true on all game objects in the array.
            </summary>
            <param name="gameObjects">List of game objects to process</param>
        </member>
        <member name="M:Quantum.GameObjectUtils.Hide(UnityEngine.GameObject[])">
            <summary>
            Hiding will <see cref="M:UnityEngine.GameObject.SetActive(System.Boolean)"/> to false on all game objects in the array.
            </summary>
            <param name="gameObjects">List of game objects to process</param>
        </member>
        <member name="M:Quantum.GameObjectUtils.Show(UnityEngine.GameObject)">
            <summary>
            Will <see cref="M:UnityEngine.GameObject.SetActive(System.Boolean)"/> to true if the game object is not null and not already active.
            </summary>
            <param name="gameObject">Game object to show</param>
        </member>
        <member name="M:Quantum.GameObjectUtils.Hide(UnityEngine.GameObject)">
            <summary>
            Will <see cref="M:UnityEngine.GameObject.SetActive(System.Boolean)"/> to false if the game object is not null and is active."/>
            </summary>
            <param name="gameObject">Game object to hide</param>
        </member>
        <member name="M:Quantum.GameObjectUtils.Toggle(UnityEngine.GameObject)">
            <summary>
            Toggle the game object's active state after checking for null.
            </summary>
            <param name="gameObject">Game object to toggle</param>
            <returns>Returns the final state of the game object active state of false if null</returns>
        </member>
        <member name="M:Quantum.GameObjectUtils.Toggle(UnityEngine.GameObject,System.Boolean)">
            <summary>
            Set game object active state into the desired state after checking for null.
            </summary>
            <param name="gameObject">Game object to toggle</param>
            <param name="state">The state to toggle into </param>
            <returns>Returns the final game object active state or false when null</returns>
        </member>
        <member name="M:Quantum.GameObjectUtils.Toggle(UnityEngine.Component,System.Boolean)">
            <summary>
            Set the component's game object active state into the desired state after checking for null.
            </summary>
            <param name="component">Component to toggle its game object</param>
            <param name="state">The desired active state</param>
            <returns>The final active state of the components game object or false if null</returns>
        </member>
        <member name="M:Quantum.GameObjectUtils.Show(UnityEngine.Component)">
            <summary>
            Sets the component game object to active after checking for null.
            </summary>
            <param name="component">Input component</param>
        </member>
        <member name="M:Quantum.GameObjectUtils.Show(UnityEngine.UI.Image,UnityEngine.Sprite)">
            <summary>
            Sets the image sprite and sets the game object to active after checking the component for null.
            </summary>
            <param name="component">Image component</param>
            <param name="sprite">Sprite to set</param>
        </member>
        <member name="M:Quantum.GameObjectUtils.Hide(UnityEngine.Component)">
            <summary>
            Set the component game object to inactive after checking for null.
            </summary>
            <param name="component">Input component</param>
        </member>
        <member name="M:Quantum.GameObjectUtils.Show``1(``0[])">
            <summary>
            Set all game objects found the component list to active after checking for null.
            </summary>
            <typeparam name="T">Type must be derived from component</typeparam>
            <param name="components">Component list to enabled game objects on</param>
        </member>
        <member name="M:Quantum.GameObjectUtils.Hide``1(``0[])">
            <summary>
            Set all game objects found the component list to in-active after checking for null.
            </summary>
            <typeparam name="T">Type must be derived from component</typeparam>
            <param name="components">Component list to disable game objects on</param>
        </member>
        <member name="T:Quantum.QuantumRunnerBehaviour">
            <summary>
            A unity script that updates the Quantum runner.
            Also manages calls to Gizmos and DebugDraw required to render Quantum debug gizmos.
            If you are writing a custom SRP, you must call RenderPipeline.EndCameraRendering to trigger OnPostRenderInternal().
            </summary>
        </member>
        <member name="F:Quantum.QuantumRunnerBehaviour.Runner">
            <summary>
            The runner object set during <see cref="M:Quantum.QuantumRunner.StartGame(Quantum.SessionRunner.Arguments)"/>
            </summary>
        </member>
        <member name="M:Quantum.QuantumRunnerBehaviour.OnEnable">
            <summary>
            Unity OnEnable event is required to register to global camera callbacks for gizmos rendering.  
            </summary>
        </member>
        <member name="M:Quantum.QuantumRunnerBehaviour.OnDisable">
            <summary>
            Unity OnDisable event is used to unsubscribe the global camera callbacks.
            </summary>
        </member>
        <member name="M:Quantum.QuantumRunnerBehaviour.Update">
            <summary>
            Unity Update event triggers the runner updates and ticks the Quantum simulation.
            </summary>
        </member>
        <member name="T:Quantum.QUnityComponentPrototypeRef">
            <summary>
            Obsolete, still defined to prevent data loss.
            </summary>
        </member>
        <member name="T:Quantum.QUnityComponentPrototypeRef`1">
            <summary>
            Obsolete, still defined to prevent data loss.
            </summary>
        </member>
        <member name="F:Quantum.QUnityComponentPrototypeRef`1.AssetPrototype">
            <summary>
            Asset prototype.
            </summary>
        </member>
        <member name="F:Quantum.QUnityComponentPrototypeRef`1.AssetComponentType">
            <summary>
            Asset component type.
            </summary>
        </member>
        <member name="F:Quantum.QUnityComponentPrototypeRef`1.ScenePrototype">
            <summary>
            Scene prototype.
            </summary>
        </member>
        <member name="T:Quantum.IQuantumEntityViewPool">
            <summary>
            Interface to create custom implementation of the entity view pool that can be assigned to the <see cref="P:Quantum.QuantumEntityViewUpdater.Pool"/>.
            </summary>
        </member>
        <member name="P:Quantum.IQuantumEntityViewPool.PooledCount">
            <summary>
            Returns how many items are inside the pool in total.
            </summary>
        </member>
        <member name="P:Quantum.IQuantumEntityViewPool.BorrowedCount">
            <summary>
            Returns how many pooled items are currently in use.
            </summary>
        </member>
        <member name="M:Quantum.IQuantumEntityViewPool.Create``1(``0,System.Boolean,System.Boolean)">
            <summary>
            Create a pooled game object and return the component of chose type.
            </summary>
            <typeparam name="T">Component type</typeparam>
            <param name="prefab">Prefab to instantiate</param>
            <param name="activate">Call SetActive() on the game object</param>
            <param name="createIfEmpty">Create a new entity if there is no suitable one found in the pool</param>
            <returns>Component on the created prefab instance, can be null</returns>
        </member>
        <member name="M:Quantum.IQuantumEntityViewPool.Create(UnityEngine.GameObject,System.Boolean,System.Boolean)">
            <summary>
            Create a pooled game object.
            </summary>
            <param name="prefab">Prefab to instantiate</param>
            <param name="activate">Call SetActive() on the game object</param>
            <param name="createIfEmpty">Create a new entity if there is no suitable one found in the pool</param>
            <returns>An instance of the prefab</returns>
        </member>
        <member name="M:Quantum.IQuantumEntityViewPool.Create``1(``0,UnityEngine.Transform,System.Boolean,System.Boolean)">
            <summary>
            Create a pooled game object and return the component of chose type.
            </summary>
            <typeparam name="T">Component type</typeparam>
            <param name="prefab">Prefab to instantiate</param>
            <param name="parent">Calls SetParent(parent) on the new game object transform when set</param>
            <param name="activate">Call SetActive() on the game object</param>
            <param name="createIfEmpty">Create a new entity if there is no suitable one found in the pool</param>
            <returns>Component on the created prefab instance, can be null</returns>
        </member>
        <member name="M:Quantum.IQuantumEntityViewPool.Create(UnityEngine.GameObject,UnityEngine.Transform,System.Boolean,System.Boolean)">
            <summary>
            Create a pooled game object.
            </summary>
            <param name="prefab">Prefab to instantiate</param>
            <param name="parent">Calls SetParent(parent) on the new game object transform when set</param>
            <param name="activate">Call SetActive() on the game object</param>
            <param name="createIfEmpty">Create a new entity if there is no suitable one found in the pool</param>
            <returns>An instance of the prefab</returns>
        </member>
        <member name="M:Quantum.IQuantumEntityViewPool.Destroy(UnityEngine.Component,System.Boolean)">
            <summary>
            Destroy or return the pooled game object that the component is attached to.
            </summary>
            <param name="component">Component that belongs to the pooled game object.</param>
            <param name="deactivate">Call SetActive(false) on the pooled game object before returning it to the pool</param>
        </member>
        <member name="M:Quantum.IQuantumEntityViewPool.Destroy(UnityEngine.GameObject,System.Boolean)">
            <summary>
            Destroy or return the pooled game object.
            </summary>
            <param name="instance">Poole game object</param>
            <param name="deactivate">Call SetActive(false) on the pooled game object before returning it to the pool</param>
        </member>
        <member name="M:Quantum.IQuantumEntityViewPool.Destroy(UnityEngine.GameObject,System.Single)">
            <summary>
            Destroy or return the pooled game object after a delay.
            </summary>
            <param name="instance">Poole game object</param>
            <param name="delay">Delay in seconds to complete returning it to the pool</param>
        </member>
        <member name="M:Quantum.IQuantumEntityViewPool.Prepare(UnityEngine.GameObject,System.Int32)">
            <summary>
            Create prefab instances and fill the pool.
            </summary>
            <param name="prefab">Prefab to created pooled instances</param>
            <param name="desiredCount">The number of instances to create and add to the pool</param>
        </member>
        <member name="T:Quantum.QuantumCallbackHandler_StartRecording">
            <summary>
            A handler object that subscribes to Quantum callbacks to start recording input and checksums.
            </summary>
        </member>
        <member name="M:Quantum.QuantumCallbackHandler_StartRecording.Initialize">
            <summary>
            Init and subscribe to Quantum callbacks.
            </summary>
            <returns>An object to dispose to unsubscribe from the callbacks</returns>
        </member>
        <member name="T:Quantum.QuantumGlobalScriptableObject">
            <summary>
            A base class for ScriptableObjects that are meant to be globally accessible, at edit-time and runtime. The way such objects
            are loaded is driven by usages of <see cref="T:Quantum.QuantumGlobalScriptableObjectSourceAttribute"/> attributes. 
            </summary>
        </member>
        <member name="T:Quantum.QuantumGlobalScriptableObjectAttribute">
            <summary>
            Provides additional information for a global scriptable object.
            </summary>
        </member>
        <member name="M:Quantum.QuantumGlobalScriptableObjectAttribute.#ctor(System.String)">
            <summary>
            Creates a new instance.
            </summary>
            <param name="defaultPath">The default path for the asset.</param>
        </member>
        <member name="P:Quantum.QuantumGlobalScriptableObjectAttribute.DefaultPath">
            <summary>
            The default path for the asset.
            </summary>
        </member>
        <member name="P:Quantum.QuantumGlobalScriptableObjectAttribute.DefaultContents">
            <summary>
            The default contents for the asset, if it is a TextAsset.
            </summary>
        </member>
        <member name="P:Quantum.QuantumGlobalScriptableObjectAttribute.DefaultContentsGeneratorMethod">
            <summary>
            Name of the method that is used to generate the default contents for the asset.
            </summary>
        </member>
        <member name="T:Quantum.QuantumGlobalScriptableObjectSourceAttribute">
            <summary>
            Base class for all attributes that can be used to load <see cref="T:Quantum.QuantumGlobalScriptableObject"/>.
            Attributes need to be registered at the assembly level. For instance, this snippet is used to register a default loader,
            that attempts to load from Resources based on <see cref="P:Quantum.QuantumGlobalScriptableObjectAttribute.DefaultPath"/>:
            <code>
            [assembly: Quantum.QuantumGlobalScriptableObjectResource(typeof(Quantum.QuantumGlobalScriptableObject), Order = 2000, AllowFallback = true)]
            </code>
            </summary>
            <seealso cref="T:Quantum.QuantumGlobalScriptableObjectAddressAttribute"/>
            <seealso cref="T:Quantum.QuantumGlobalScriptableObjectResourceAttribute"/>
        </member>
        <member name="M:Quantum.QuantumGlobalScriptableObjectSourceAttribute.#ctor(System.Type)">
            <param name="objectType">Type or the base type of <see cref="T:Quantum.QuantumGlobalScriptableObject"/> that this loader supports.</param>
        </member>
        <member name="P:Quantum.QuantumGlobalScriptableObjectSourceAttribute.ObjectType">
            <summary>
            Type or the base type of <see cref="T:Quantum.QuantumGlobalScriptableObject"/> that this loader supports.
            </summary>
        </member>
        <member name="P:Quantum.QuantumGlobalScriptableObjectSourceAttribute.Order">
            <summary>
            Order in which this loader will be executed. Lower values are executed first.
            </summary>
        </member>
        <member name="P:Quantum.QuantumGlobalScriptableObjectSourceAttribute.AllowEditMode">
            <summary>
            Can this loader be used in edit mode.
            </summary>
        </member>
        <member name="P:Quantum.QuantumGlobalScriptableObjectSourceAttribute.AllowFallback">
            <summary>
            Does this loader allow fallback to the next loader?
            </summary>
        </member>
        <member name="M:Quantum.QuantumGlobalScriptableObjectSourceAttribute.Load(System.Type)">
            <summary>
            Attempt to load the object of the specified type. Return <see langword="default"/> if the object cannot be loaded.
            </summary>
            <param name="type">The requested type</param>
        </member>
        <member name="T:Quantum.QuantumGlobalScriptableObjectUnloadDelegate">
            <summary>
            A delegate that can be used to unload a <see cref="T:Quantum.QuantumGlobalScriptableObject"/>.
            </summary>
        </member>
        <member name="T:Quantum.QuantumGlobalScriptableObjectLoadResult">
            <summary>
            The result of <see cref="M:Quantum.QuantumGlobalScriptableObjectSourceAttribute.Load(System.Type)"/>. Contains the loaded object and an optional
            unloader delegate.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGlobalScriptableObjectLoadResult.Object">
            <summary>
            Object instance.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGlobalScriptableObjectLoadResult.Unloader">
            <summary>
            An optional delegate that is used to unload <see cref="F:Quantum.QuantumGlobalScriptableObjectLoadResult.Object"/>.
            </summary>
        </member>
        <member name="M:Quantum.QuantumGlobalScriptableObjectLoadResult.#ctor(Quantum.QuantumGlobalScriptableObject,Quantum.QuantumGlobalScriptableObjectUnloadDelegate)">
            <param name="obj">Object instance.</param>
            <param name="unloader">An optional delegate that is used to unload <paramref name="obj"/>.</param>
        </member>
        <member name="M:Quantum.QuantumGlobalScriptableObjectLoadResult.op_Implicit(Quantum.QuantumGlobalScriptableObject)~Quantum.QuantumGlobalScriptableObjectLoadResult">
            <summary>
            Implicitly converts a <see cref="T:Quantum.QuantumGlobalScriptableObject"/> to a <see cref="T:Quantum.QuantumGlobalScriptableObjectLoadResult"/>.
            </summary>
        </member>
        <member name="T:Quantum.QuantumScriptableObject">
            <summary>
            Base class for all Quantum scriptable objects.
            </summary>
        </member>
        <member name="T:Quantum.QuantumGameGizmosSettings">
            <summary>
            The gizmo settings for the Quantum game.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameGizmosSettings.ID">
            <summary>
            The Unity overlay UI id used for the Quantum gizmos.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameGizmosSettings.IconScale">
            <summary>
            Global scale for all gizmos.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameGizmosSettings.SelectedBrightness">
            <summary>
            How bright the gizmos are when selected.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameGizmosSettings.PredictionArea">
            <summary>
            Draw the prediction area. Only available at runtime.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameGizmosSettings.CharacterController">
            <summary>
            Draw the CharacterController3D and CharacterController2D components.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameGizmosSettings.StaticColliders">
            <summary>
            Draw the colliders that are currently static.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameGizmosSettings.DynamicColliders">
            <summary>
            Draw the colliders that are currently dynamic.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameGizmosSettings.KinematicColliders">
            <summary>
            Draw the colliders that are currently kinematic.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameGizmosSettings.AsleepColliders">
            <summary>
            Draw the colliders that are asleep.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameGizmosSettings.DisabledColliders">
            <summary>
            Draw the colliders that are disabled.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameGizmosSettings.PhysicsArea">
            <summary>
            Draw the map's physics area.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameGizmosSettings.PhysicsBuckets">
            <summary>
            Draw the map's physics buckets.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameGizmosSettings.StaticMeshNormals">
            <summary>
            Draw the baked static mesh vertices.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameGizmosSettings.StaticMeshTriangles">
            <summary>
            Draw the baked static mesh vertices.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameGizmosSettings.SceneMeshCells">
            <summary>
            Draw the cells of the scene mesh.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameGizmosSettings.SceneMeshTriangles">
            <summary>
            Draw the triangles of the scene mesh.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameGizmosSettings.PhysicsJoints">
            <summary>
            Draw the entity's physics joints.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameGizmosSettings.ScaleComponentsWithAgentRadius">
            <summary>
            Should NavMesh components be scaled with the agent radius?
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameGizmosSettings.NavMesh">
            <summary>
            Draw the NavMesh. The QuantumMap game object will trigger DrawOnlySelected.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameGizmosSettings.NavMeshBorders">
            <summary>
            Draw the border of the NavMesh.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameGizmosSettings.NavMeshArea">
            <summary>
            Draw the NavMesh area. The QuantumMap game object will trigger DrawOnlySelected.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameGizmosSettings.NavMeshGrid">
            <summary>
            Draw the NavMesh grid. The QuantumMap game object will trigger DrawOnlySelected.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameGizmosSettings.NavMeshLinks">
            <summary>
            Draw the NavMesh links.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameGizmosSettings.NavMeshVertexNormals">
            <summary>
            Draw the vertex normals of the NavMesh.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameGizmosSettings.NavMeshTriangleIds">
            <summary>
            Draw the triangle ids of the NavMesh.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameGizmosSettings.NavMeshRegionIds">
            <summary>
            Draw the region ids of the NavMesh.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameGizmosSettings.NavMeshVertexIds">
            <summary>
            Draw the numerical vertex ids of the NavMesh.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameGizmosSettings.NavMeshPathfinder">
            <summary>
            Draw the NavMesh pathfinder component. Only available at runtime.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameGizmosSettings.NavMeshSteeringAgent">
            <summary>
            Draw the NavMesh steering agent component. Only available at runtime.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameGizmosSettings.NavMeshAvoidanceAgent">
            <summary>
            Draw the NavMesh avoidance agent component. Only available at runtime.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameGizmosSettings.NavMeshAvoidanceObstacles">
            <summary>
            Draw the NavMesh avoidance obstacles component. Only available at runtime.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameGizmosSettings.PathfinderRawPath">
            <summary>
            Draw the pathfinder path. Only available at runtime.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameGizmosSettings.PathfinderRawTrianglePath">
            <summary>
            Draw the raw pathfinder triangle path. Only available at runtime.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameGizmosSettings.PathfinderFunnel">
            <summary>
            Draw the pathfinder funnel. Only available at runtime.
            </summary>
        </member>
        <member name="M:Quantum.QuantumGameGizmosSettings.GetEntryForPhysicsEntity3D(Quantum.Frame,Quantum.EntityRef)">
            <summary>
            Get the gizmo entry for a specific physics3d entity.
            </summary>
            <param name="frame"></param>
            <param name="handle"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.QuantumGameGizmosSettings.GetEntryForPhysicsEntity2D(Quantum.Frame,Quantum.EntityRef)">
            <summary>
            Get the gizmo entry for a specific physics2d entity.
            </summary>
            <param name="frame"></param>
            <param name="handle"></param>
            <returns></returns>
        </member>
        <member name="T:Quantum.IQuantumViewContext">
            <summary>
            Use this interface to create view context classes that can be used inside concrete <see cref="T:Quantum.QuantumEntityViewComponent`1"/>.
            </summary>
        </member>
        <member name="M:Quantum.QuantumUnityComponentPrototype.CreatePrototype(Quantum.QuantumEntityPrototypeConverter)">
            <summary>
            </summary>
            <param name="converter"></param>
            <returns></returns>
        </member>
        <member name="T:Quantum.QuantumRunnerLocalDebug">
            <summary>
              A debug script that starts the Quantum simulation for <see cref="F:Quantum.QuantumRunnerLocalDebug.MaxPlayerCount" /> players when starting the game
              from a gameplay scene.
              Will add <see cref="F:Quantum.QuantumRunnerLocalDebug.LocalPlayers" /> as local players during simulation start.
              The script will disable itself when it detects that other scene were loaded before this (to delegate adding players
              to a menu scene / game bootstrap).
            </summary>
        </member>
        <member name="F:Quantum.QuantumRunnerLocalDebug.DeltaTypeType">
            <summary>
            Set the <see cref="F:Quantum.QuantumRunnerLocalDebug.DeltaTypeType" /> to <see cref="F:Quantum.SimulationUpdateTime.EngineDeltaTime" /> to not progress the
            simulation during break points.
            Has to be set before starting the runner and can only be changed on the runner directly during runtime: <see cref="P:Quantum.SessionRunner.DeltaTimeType"/>.
            </summary>
        </member>
        <member name="F:Quantum.QuantumRunnerLocalDebug.RecordingFlags">
            <summary>
            Set RecordingFlags of the local simulation to enable saving a replay.
            Caveat: Input recording allocates during runtime.
            </summary>
        </member>
        <member name="F:Quantum.QuantumRunnerLocalDebug.InstantReplayConfig">
            <summary>
            Set InstantReplaySettings to enable instant replays.
            </summary>
        </member>
        <member name="F:Quantum.QuantumRunnerLocalDebug.RuntimeConfig">
            <summary>
            Configure the RuntimeConfig used for the local simulation.
            </summary>
        </member>
        <member name="F:Quantum.QuantumRunnerLocalDebug.SessionConfig">
            <summary>
            Select the SessionConfig used for the local simulation. Will revert to the global default if not set.
            </summary>
        </member>
        <member name="F:Quantum.QuantumRunnerLocalDebug.LocalPlayers">
            <summary>
            Configure the players added to the game after the simulation has started.
            </summary>
        </member>
        <member name="F:Quantum.QuantumRunnerLocalDebug.MaxPlayerCount">
            <summary>
            Overwrite the max player count for this simulation otherwise Quantum.Constants.PLAYER_COUNT is used. Default is 0.
            </summary>
        </member>
        <member name="F:Quantum.QuantumRunnerLocalDebug.SimulationSpeedMultiplier">
            <summary>
            Set a factor to increase or decrease the simulation speed and update the simulation during Update(). Default is 1.
            </summary>
        </member>
        <member name="F:Quantum.QuantumRunnerLocalDebug.DisplaySaveAndReloadButton">
            <summary>
            Show the reload simulation button.
            </summary>
        </member>
        <member name="F:Quantum.QuantumRunnerLocalDebug.PreloadAddressables">
            <summary>
            Enabled loading Addressables before simulation start.
            </summary>
        </member>
        <member name="F:Quantum.QuantumRunnerLocalDebug.IsTaskProfilerEnabled">
            <summary>
            Enable the Quantum task profiler. Must be set before starting. Works with debug and release Quantum dlls.
            </summary>
        </member>
        <member name="F:Quantum.QuantumRunnerLocalDebug.DynamicAssetDB">
            <summary>
            Set a dynamic asset db.
            </summary>
        </member>
        <member name="F:Quantum.QuantumRunnerLocalDebug.OnBeforeStart">
            <summary>
            Unity event that is called before the Quantum simulation is started.
            </summary>
        </member>
        <member name="M:Quantum.QuantumRunnerLocalDebug.Start">
            <summary>
            Unity start event, will start the Quantum simulation.
            </summary>
        </member>
        <member name="M:Quantum.QuantumRunnerLocalDebug.StartWithFrame(System.Int32,System.Byte[])">
            <summary>
            Start the Quantum simulation with a specific frame number and frame data.
            </summary>
            <param name="frameNumber">Frame number</param>
            <param name="frameData">Frame data to start from</param>
            <exception cref="T:System.Exception">Is raised when no map was found in the scene.</exception>
        </member>
        <member name="M:Quantum.QuantumRunnerLocalDebug.OnGUI">
            <summary>
            Unity OnGUI event updates the debug runner UI.
            </summary>
        </member>
        <member name="M:Quantum.QuantumRunnerLocalDebug.Update">
            <summary>
            Unity update event. Will update the simulation if a custom <see cref="F:Quantum.QuantumRunnerLocalDebug.SimulationSpeedMultiplier" /> was set.
            </summary>
        </member>
        <member name="T:Quantum.QuantumRunnerLocalDebug.DynamicAssetDBSettings">
            <summary>
            Settings used to initialize the dynamic db.
            </summary>
        </member>
        <member name="T:Quantum.QuantumRunnerLocalDebug.DynamicAssetDBSettings.InitialDynamicAssetsRequestedUnityEvent">
            <summary>
            A unity event passing the dynamic asset db.
            </summary>
        </member>
        <member name="F:Quantum.QuantumRunnerLocalDebug.DynamicAssetDBSettings.OnInitialDynamicAssetsRequested">
            <summary>
            A callback called after the dynamic asset db was created.
            </summary>
        </member>
        <member name="F:Quantum.QuantumRunnerLocalDebug.DynamicAssetDBSettings.IsLegacyModeEnabled">
            <inheritdoc cref="F:Quantum.DynamicAssetDB.IsLegacyModeEnabled"/>
        </member>
        <member name="T:Quantum.Demo.QuantumSimpleConnectionGUI">
            <summary>
            A Unity script that demonstrates how to connect to a Quantum cloud and start a Quantum game session.
            </summary>
        </member>
        <member name="F:Quantum.Demo.QuantumSimpleConnectionGUI.RuntimeConfig">
            <summary>
            The RuntimeConfig to use for the Quantum game session. The RuntimeConfig describes custom game properties.
            </summary>
        </member>
        <member name="F:Quantum.Demo.QuantumSimpleConnectionGUI.RuntimePlayers">
            <summary>
            The RuntimePlayers to add to the Quantum game session. The RuntimePlayers describe individual custom player properties.
            </summary>
        </member>
        <member name="F:Quantum.Demo.QuantumSimpleConnectionGUI.Client">
            <summary>
            The Photon RealtimeClient object that represents the connection to the Quantum cloud.
            </summary>
        </member>
        <member name="F:Quantum.Demo.QuantumSimpleConnectionGUI.OverwritePlayerCount">
            <summary>
            Set this number as maximum Quantum player count. If 0, the default value is used. Default is Quantum.Input.MAX_COUNT.
            </summary>
        </member>
        <member name="F:Quantum.Demo.QuantumSimpleConnectionGUI.OverwriteAppVersion">
            <summary>
            Overwrite the AppVersion used by the global <see cref="F:Quantum.PhotonServerSettings.AppSettings"/>.
            </summary>
        </member>
        <member name="T:Quantum.QuantumCallbackHandler_GameResult">
            <summary>
            A handler object that subscribes to Quantum callbacks to send game results to the server.
            </summary>
        </member>
        <member name="M:Quantum.QuantumCallbackHandler_GameResult.Initialize">
            <summary>
            Init and subscribe to Quantum callbacks.
            </summary>
            <returns>A disposable object to unsubscribe from callbacks again.</returns>
        </member>
        <member name="T:Quantum.QuantumEntityViewPool">
            <summary>
            An implementation of a EntityView pool to be used with the <see cref="P:Quantum.QuantumEntityViewUpdater.Pool"/>.
            Add this behaviour to the same game object that the <see cref="T:Quantum.QuantumEntityViewUpdater"/> behaviour is on.
            Using QuantumCallback.Subscribe() with pooled objects as listener needs to use the onlyIfActiveAndEnabled option to not be callbacks from disabled pooled objects.
            </summary>
        </member>
        <member name="P:Quantum.QuantumEntityViewPool.PooledCount">
            <summary>
            Returns how many items are inside the pool in total.
            </summary>
        </member>
        <member name="P:Quantum.QuantumEntityViewPool.BorrowedCount">
            <summary>
            Returns how many pooled items are currently in use.
            </summary>
        </member>
        <member name="M:Quantum.QuantumEntityViewPool.Create``1(``0,System.Boolean,System.Boolean)">
            <summary>
            Create a pooled game object and return the component of chose type.
            </summary>
            <typeparam name="T">Component type</typeparam>
            <param name="prefab">Prefab to instantiate</param>
            <param name="activate">Call SetActive() on the game object</param>
            <param name="createIfEmpty">Create a new entity if there is no suitable one found in the pool</param>
            <returns>Component on the created prefab instance, can be null</returns>
        </member>
        <member name="M:Quantum.QuantumEntityViewPool.Create(UnityEngine.GameObject,System.Boolean,System.Boolean)">
            <summary>
            Create a pooled game object.
            </summary>
            <param name="prefab">Prefab to instantiate</param>
            <param name="activate">Call SetActive() on the game object</param>
            <param name="createIfEmpty">Create a new entity if there is no suitable one found in the pool</param>
            <returns>An instance of the prefab</returns>
        </member>
        <member name="M:Quantum.QuantumEntityViewPool.Create``1(``0,UnityEngine.Transform,System.Boolean,System.Boolean)">
            <summary>
            Create a pooled game object and return the component of chose type.
            </summary>
            <typeparam name="T">Component type</typeparam>
            <param name="prefab">Prefab to instantiate</param>
            <param name="parent">Calls SetParent(parent) on the new game object transform when set</param>
            <param name="activate">Call SetActive() on the game object</param>
            <param name="createIfEmpty">Create a new entity if there is no suitable one found in the pool</param>
            <returns>Component on the created prefab instance, can be null</returns>
        </member>
        <member name="M:Quantum.QuantumEntityViewPool.Create(UnityEngine.GameObject,UnityEngine.Transform,System.Boolean,System.Boolean)">
            <summary>
            Create a pooled game object.
            </summary>
            <param name="prefab">Prefab to instantiate</param>
            <param name="parent">Calls SetParent(parent) on the new game object transform when set</param>
            <param name="activate">Call SetActive() on the game object</param>
            <param name="createIfEmpty">Create a new entity if there is no suitable one found in the pool</param>
            <returns>An instance of the prefab</returns>
        </member>
        <member name="M:Quantum.QuantumEntityViewPool.Destroy(UnityEngine.Component,System.Boolean)">
            <summary>
            Destroy or return the pooled game object that the component is attached to.
            </summary>
            <param name="component">Component that belongs to the pooled game object.</param>
            <param name="deactivate">Call SetActive(false) on the pooled game object before returning it to the pool</param>
        </member>
        <member name="M:Quantum.QuantumEntityViewPool.Destroy(UnityEngine.GameObject,System.Boolean)">
            <summary>
            Destroy or return the pooled game object.
            </summary>
            <param name="instance">Poole game object</param>
            <param name="deactivate">Call SetActive(false) on the pooled game object before returning it to the pool</param>
        </member>
        <member name="M:Quantum.QuantumEntityViewPool.Destroy(UnityEngine.GameObject,System.Single)">
            <summary>
            Destroy or return the pooled game object after a delay.
            </summary>
            <param name="instance">Poole game object</param>
            <param name="delay">Delay in seconds to complete returning it to the pool</param>
        </member>
        <member name="M:Quantum.QuantumEntityViewPool.Prepare(UnityEngine.GameObject,System.Int32)">
            <summary>
            Create prefab instances and fill the pool.
            </summary>
            <param name="prefab">Prefab to created pooled instances</param>
            <param name="desiredCount">The number of instances to create and add to the pool</param>
        </member>
        <member name="M:Quantum.QuantumEntityViewPool.Awake">
            <summary>
            Create pre cached pooled game objects during Awake().
            </summary>
        </member>
        <member name="M:Quantum.QuantumEntityViewPool.OnDestroy">
            <summary>
            Shutdown the pool.
            </summary>
        </member>
        <member name="M:Quantum.QuantumEntityViewPool.Update">
            <summary>
            Update is used to track deferred pooled game object destroy requests.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityViewPool.PooledObject.Count">
            <summary>
            The number of game objects instances to pre allocate.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityViewPool.PooledObject.GameObject">
            <summary>
            The prefab to instantiate pooled game objects from.
            </summary>
        </member>
        <member name="T:Quantum.GizmoUtils">
            <summary>
            Utility class for drawing gizmos.
            </summary>
        </member>
        <member name="M:Quantum.GizmoUtils.Alpha(UnityEngine.Color,System.Single)">
            <summary>
            Adjusts the alpha channel of the color.
            </summary>
            <param name="color">The color to adjust.</param>
            <param name="a">The new alpha value.</param>
            <returns>The color with the alpha value adjusted.</returns>
        </member>
        <member name="M:Quantum.GizmoUtils.Brightness(UnityEngine.Color,System.Single)">
            <summary>
            Adjusts the brightness of a color.
            </summary>
            <param name="color">The color to adjust.</param>
            <param name="brightness">The brightness value. Values greater than 1 will increase brightness, while values less than 1 will decrease brightness.</param>
            <returns>The adjusted color with the specified brightness.</returns>
        </member>
        <member name="F:Quantum.GizmoUtils.DefaultArrowHeadLength">
            <summary>
            The default arrow head length.
            </summary>
        </member>
        <member name="F:Quantum.GizmoUtils.DefaultArrowHeadAngle">
            <summary>
            The default arrow head angle.
            </summary>
        </member>
        <member name="M:Quantum.GizmoUtils.DrawGizmosBox(UnityEngine.Transform,UnityEngine.Vector3,UnityEngine.Color,UnityEngine.Vector3,Quantum.QuantumGizmoStyle)">
            <summary>
            Draws a gizmo box in the scene using the specified parameters.
            </summary>
            <param name="transform">The transform of the gizmo box.</param>
            <param name="size">The size of the gizmo box.</param>
            <param name="color">The color of the gizmo box.</param>
            <param name="offset">The offset position for the gizmo box (default: Vector3.zero).</param>
            <param name="style">The gizmo style to apply (default: QuantumGizmoStyle default value).</param>
        </member>
        <member name="M:Quantum.GizmoUtils.DrawGizmosBox(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Color,System.Nullable{UnityEngine.Quaternion},Quantum.QuantumGizmoStyle)">
            <summary>
            Draws a box gizmo with the given center, size, color, rotation, and style.
            </summary>
            <param name="center">The center position of the box.</param>
            <param name="size">The size of the box.</param>
            <param name="color">The color of the box.</param>
            <param name="rotation">The rotation of the box. Defaults to identity rotation if not provided.</param>
            <param name="style">The style of the gizmo. Defaults to default style if not provided.</param>
        </member>
        <member name="M:Quantum.GizmoUtils.DrawGizmosCapsule2D(UnityEngine.Vector3,System.Single,System.Single,UnityEngine.Color,System.Nullable{UnityEngine.Quaternion},Quantum.QuantumGizmoStyle)">
            <summary>
            Draws a 2D capsule gizmo.
            </summary>
            <param name="center">The center of the capsule.</param>
            <param name="radius">The radius of the capsule.</param>
            <param name="height">The height of the capsule.</param>
            <param name="color">The color of the gizmo.</param>
            <param name="rotation">The rotation of the capsule. If null, identity rotation is used.</param>
            <param name="style">The style of the gizmo. If not provided, default style is used.</param>
        </member>
        <member name="M:Quantum.GizmoUtils.DrawGizmosBox(UnityEngine.Matrix4x4,UnityEngine.Vector3,UnityEngine.Color,Quantum.QuantumGizmoStyle)">
            <summary>
            Draws a box gizmo in the scene using the specified parameters.
            </summary>
            <param name="matrix">The matrix of the gizmo box.</param>
            <param name="size">The size of the box.</param>
            <param name="color">The color of the box.</param>
            <param name="style">The style of the gizmo. (Optional)</param>
        </member>
        <member name="M:Quantum.GizmoUtils.DrawGizmosCircle(UnityEngine.Vector3,System.Single,UnityEngine.Color,System.Single,Quantum.QuantumGizmoStyle)">
            <summary>
            Draws a gizmo circle at the specified position with the given radius and color.
            </summary>
            <param name="position">The position of the circle.</param>
            <param name="radius">The radius of the circle.</param>
            <param name="color">The color of the circle.</param>
            <param name="height">The height of the circle. Default is 0.0.</param>
            <param name="style">The style of the gizmo. Default is QuantumGizmoStyle's default value.</param>
        </member>
        <member name="M:Quantum.GizmoUtils.DrawGizmosSphere(UnityEngine.Vector3,System.Single,UnityEngine.Color,Quantum.QuantumGizmoStyle)">
            <summary>
            Draws a sphere gizmo in the scene.
            </summary>
            <param name="position">The position of the sphere.</param>
            <param name="radius">The radius of the sphere.</param>
            <param name="color">The color of the sphere.</param>
            <param name="style">The style of the gizmo.</param>
        </member>
        <member name="M:Quantum.GizmoUtils.DrawGizmosTriangle(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Color)">
            <summary>
            Draws a triangle gizmo using the given vertices and color.
            </summary>
            <param name="A">The first vertex of the triangle.</param>
            <param name="B">The second vertex of the triangle.</param>
            <param name="C">The third vertex of the triangle.</param>
            <param name="color">The color of the triangle.</param>
        </member>
        <member name="M:Quantum.GizmoUtils.DrawGizmoGrid(Photon.Deterministic.FPVector2,System.Int32,System.Int32,System.Int32,UnityEngine.Color)">
            <summary>
            Draws a grid of gizmos in the Unity editor.
            </summary>
            <param name="bottomLeft">The bottom-left corner of the grid.</param>
            <param name="width">The number of horizontal nodes in the grid.</param>
            <param name="height">The number of vertical nodes in the grid.</param>
            <param name="nodeSize">The size of each grid node.</param>
            <param name="color">The color of the grid gizmos.</param>
        </member>
        <member name="M:Quantum.GizmoUtils.DrawGizmoGrid(UnityEngine.Vector3,System.Int32,System.Int32,System.Int32,UnityEngine.Color)">
            <summary>
            Draw a grid of gizmos starting from a bottom-left position.
            </summary>
            <param name="bottomLeft">The bottom-left position of the grid.</param>
            <param name="width">The width of the grid in number of nodes.</param>
            <param name="height">The height of the grid in number of nodes.</param>
            <param name="nodeSize">The size of each individual node in the grid.</param>
            <param name="color">The color of the grid gizmos.</param>
        </member>
        <member name="M:Quantum.GizmoUtils.DrawGizmoGrid(UnityEngine.Vector3,System.Int32,System.Int32,System.Single,System.Single,UnityEngine.Color)">
            <summary>
            Draws a grid of gizmos in the scene.
            </summary>
            <param name="bottomLeft">The bottom left corner of the grid.</param>
            <param name="width">The number of columns in the grid.</param>
            <param name="height">The number of rows in the grid.</param>
            <param name="nodeWidth">The width of each grid node.</param>
            <param name="nodeHeight">The height of each grid node.</param>
            <param name="color">The color of the grid lines.</param>
        </member>
        <member name="M:Quantum.GizmoUtils.DrawGizmoPolygon2D(UnityEngine.Vector3,UnityEngine.Quaternion,Photon.Deterministic.FPVector2[],System.Single,UnityEngine.Color,Quantum.QuantumGizmoStyle)">
            <summary>
            Draws a 2D polygon gizmo in the scene.
            </summary>
            <param name="position">The position of the polygon.</param>
            <param name="rotation">The rotation of the polygon.</param>
            <param name="vertices">The vertices of the polygon.</param>
            <param name="height">The height of the polygon.</param>
            <param name="color">The color of the polygon.</param>
            <param name="style">The style of the gizmo.</param>
        </member>
        <member name="M:Quantum.GizmoUtils.DrawGizmoPolygon2D(UnityEngine.Vector3,UnityEngine.Quaternion,Photon.Deterministic.FPVector2[],System.Single,System.Boolean,UnityEngine.Color,Quantum.QuantumGizmoStyle)">
            <summary>
            Draws a 2D polygon gizmo in the scene.
            </summary>
            <param name="position">The position of the polygon.</param>
            <param name="rotation">The rotation of the polygon.</param>
            <param name="vertices">The array of vertices that define the polygon shape.</param>
            <param name="height">The height of the polygon.</param>
            <param name="drawNormals">Whether to draw normals for the polygon.</param>
            <param name="color">The color of the polygon.</param>
            <param name="style">The style of the gizmo.</param>
        </member>
        <member name="M:Quantum.GizmoUtils.DrawGizmoPolygon2D(UnityEngine.Transform,Photon.Deterministic.FPVector2[],System.Single,System.Boolean,UnityEngine.Color,Quantum.QuantumGizmoStyle)">
            <summary>
            Draws a 2D polygon gizmo with the given parameters.
            </summary>
            <param name="transform">The transform of the polygon.</param>
            <param name="vertices">The vertices of the polygon.</param>
            <param name="height">The height of the polygon.</param>
            <param name="drawNormals">Whether to draw the polygon normal.</param>
            <param name="color">The color of the polygon.</param>
            <param name="style">The style of the gizmo.</param>
        </member>
        <member name="M:Quantum.GizmoUtils.DrawGizmoPolygon2D(UnityEngine.Matrix4x4,Photon.Deterministic.FPVector2[],System.Single,System.Boolean,UnityEngine.Color,Quantum.QuantumGizmoStyle)">
            <inheritdoc cref="M:Quantum.GizmoUtils.DrawGizmoPolygon2D(UnityEngine.Vector3,UnityEngine.Quaternion,Photon.Deterministic.FPVector2[],System.Single,System.Boolean,UnityEngine.Color,Quantum.QuantumGizmoStyle)"/>
        </member>
        <member name="M:Quantum.GizmoUtils.DrawGizmoPolygon2DInternal(UnityEngine.Vector3[],System.Single,System.Boolean,UnityEngine.Color,Quantum.QuantumGizmoStyle)">
            <summary>
            Draws a 2D polygon gizmo.
            </summary>
            <param name="vertices">The vertices of the polygon in world space.</param>
            <param name="height">The height of the polygon.</param>
            <param name="drawNormals">Determines whether to draw normal.</param>
            <param name="color">The color of the polygon.</param>
            <param name="style">The gizmo style.</param>
        </member>
        <member name="M:Quantum.GizmoUtils.DrawGizmoDiamond(UnityEngine.Vector3,UnityEngine.Vector2)">
            <summary>
            Draws a diamond gizmo with the given center and size.
            </summary>
            <param name="center">The center position of the diamond.</param>
            <param name="size">The size of the diamond.</param>
        </member>
        <member name="M:Quantum.GizmoUtils.DrawGizmoVector3D(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Single)">
            <summary>
            Draws a 3D vector gizmo with an arrowhead from the specified start to end points.
            </summary>
            <param name="start">The starting point of the vector.</param>
            <param name="end">The ending point of the vector.</param>
            <param name="arrowHeadLength">The length of the arrowhead.</param>
            <param name="arrowHeadAngle">The angle of the arrowhead.</param>
        </member>
        <member name="M:Quantum.GizmoUtils.DrawGizmoVector(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Single)">
            <summary>
            Draws a vector gizmo from the specified start point to the specified end point.
            </summary>
            <param name="start">The starting point of the vector.</param>
            <param name="end">The ending point of the vector.</param>
            <param name="arrowHeadLength">The length of the arrow head (default is DefaultArrowHeadLength).</param>
            <param name="arrowHeadAngle">The angle of the arrow head (default is DefaultArrowHeadAngle).</param>
        </member>
        <member name="M:Quantum.GizmoUtils.DrawGizmoArc(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Single,UnityEngine.Color,System.Single,Quantum.QuantumGizmoStyle)">
            <summary>
            Draws a gizmo arc in the Unity editor.
            </summary>
            <param name="position">The position of the arc.</param>
            <param name="normal">The normal vector of the arc.</param>
            <param name="from">The starting direction vector of the arc.</param>
            <param name="angle">The angle of the arc.</param>
            <param name="radius">The radius of the arc.</param>
            <param name="color">The color of the arc.</param>
            <param name="alphaRatio">The alpha ratio of the arc.</param>
            <param name="style">The style of the arc.</param>
        </member>
        <member name="M:Quantum.GizmoUtils.DrawGizmoDisc(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Color,System.Single,Quantum.QuantumGizmoStyle)">
            <summary>
            Draws a gizmo disc at the specified position and orientation.
            </summary>
            <param name="position">The position of the disc.</param>
            <param name="normal">The orientation of the disc.</param>
            <param name="radius">The radius of the disc.</param>
            <param name="color">The color of the disc.</param>
            <param name="alphaRatio">The alpha ratio for the disc's color.</param>
            <param name="style">The style of the gizmo.</param>
        </member>
        <member name="M:Quantum.GizmoUtils.DrawGizmosEdge(UnityEngine.Vector3,UnityEngine.Vector3,System.Single,UnityEngine.Color,Quantum.QuantumGizmoStyle)">
            <summary>
            Draws a gizmo edge from the specified start point to the end point.
            </summary>
            <param name="start">The starting point of the edge.</param>
            <param name="end">The ending point of the edge.</param>
            <param name="height">The height of the edge.</param>
            <param name="color">The color of the edge.</param>
            <param name="style">The gizmo style to use.</param>
        </member>
        <member name="M:Quantum.GizmoUtils.DrawGizmosCapsule(UnityEngine.Vector3,System.Single,System.Single,UnityEngine.Color,System.Nullable{UnityEngine.Quaternion},Quantum.QuantumGizmoStyle)">
            <summary>
            Draws a capsule Gizmo in 3D space.
            </summary>
            <param name="center">The center position of the capsule.</param>
            <param name="radius">The radius of the capsule.</param>
            <param name="extent">The extent (length) of the capsule.</param>
            <param name="color">The color of the capsule.</param>
            <param name="rotation">The rotation of the capsule. If null, no rotation is applied.</param>
            <param name="style">The style of the Gizmo. Defaults to QuantumGizmoStyle.</param>
        </member>
        <member name="M:Quantum.GizmoUtils.DrawGizmosCapsule(UnityEngine.Matrix4x4,System.Single,System.Single,UnityEngine.Color,Quantum.QuantumGizmoStyle)">
            <summary>
            Draws a capsule gizmo in the Scene view using Handles.
            </summary>
            <param name="matrix">The matrix of the capsule.</param>
            <param name="radius">The radius of the capsule.</param>
            <param name="extent">The height extent of the capsule.</param>
            <param name="color">The color of the capsule.</param>
            <param name="style">Optional gizmo style.</param>
        </member>
        <member name="T:Quantum.QuantumGizmoStyle">
            <summary>
            The style of the gizmo.
            </summary>
        </member>
        <member name="P:Quantum.QuantumGizmoStyle.FillDisabled">
            <summary>
            The default gizmo style.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGizmoStyle.DisableFill">
            <summary>
            If true, the gizmo will be filled.
            </summary>
        </member>
        <member name="P:Quantum.QuantumGizmoStyle.IsFillEnabled">
            <summary>
            Returns true if the gizmo fill is enabled.
            </summary>
        </member>
        <member name="P:Quantum.QuantumGizmoStyle.IsWireframeEnabled">
            <summary>
            Returns true if the gizmo wireframe is enabled.
            </summary>
        </member>
        <member name="T:Quantum.PhotonServerSettings">
            <summary>
            This class wraps the AppSettings into a scriptable object and adds a few Quantum connection related configurations.
            Connect to specific region cloud: UseNameSever = true,  FixedRegion = "us", Server = ""
            Connect to best region:           UseNameSever = true,  FixedRegion = "",   Server = ""
            Connect to (local) master server: UseNameSever = false, FixedRegion = "",   Server = "10.0.0.0.", Port = 5055
            Connect to (local) name server:   UseNameSever = true,  FixedRegion = "",   Server = "10.0.0.0.", Port = 5058
            </summary>
        </member>
        <member name="F:Quantum.PhotonServerSettings.DefaultPath">
            <summary>
            The default asset path to search or create a default server settings asset.
            </summary>
        </member>
        <member name="F:Quantum.PhotonServerSettings.AppSettings">
            <summary>
            Photon AppSettings is serialized on this class.
            </summary>
        </member>
        <member name="F:Quantum.PhotonServerSettings.PlayerTtlInSeconds">
            <summary>
            PlayerTTL used when opening rooms.
            </summary>
        </member>
        <member name="F:Quantum.PhotonServerSettings.EmptyRoomTtlInSeconds">
            <summary>
            EmptyRoomTTL used when opening rooms.
            </summary>
        </member>
        <member name="F:Quantum.PhotonServerSettings.BestRegionSummaryKey">
            <summary>
            Best region summary key used to store ping results in PlayerPrefs.
            </summary>
        </member>
        <member name="P:Quantum.PhotonServerSettings.CanRejoin">
            <summary>
            Rejoining rooms (after the 10 second default timeout) is only possible when PlayerTTL > 0.
            </summary>
        </member>
        <member name="P:Quantum.PhotonServerSettings.BestRegionSummary">
            <summary>
            Access best region summary in PlayerPrefs.
            </summary>
        </member>
        <member name="M:Quantum.PhotonServerSettings.CloneAppSettings(Photon.Realtime.AppSettings)">
            <summary>
            Obsolete: use new AppSettings(appsSettings)
            </summary>
        </member>
        <member name="T:Quantum.QuantumMultiClientPlayer">
            <summary>
            This class keeps track of individual Photon connections and Quantum simulations (QuantumRunner). 
            </summary>
        </member>
        <member name="P:Quantum.QuantumMultiClientPlayer.Runner">
            <summary>
            The QuantumRunner that this player belongs to.
            </summary>
        </member>
        <member name="P:Quantum.QuantumMultiClientPlayer.RunnerId">
            <summary>
            Access the runner id of it's runner or null if it does not exist.
            </summary>
        </member>
        <member name="P:Quantum.QuantumMultiClientPlayer.Input">
            <summary>
            The Input object to toggle on or off.
            </summary>
        </member>
        <member name="P:Quantum.QuantumMultiClientPlayer.ShutdownHandler">
            <summary>
            The shutdown handler used to keep track of disconnect events from the QuantumRunner. Requires a reference to clean up during destruction.
            </summary>
        </member>
        <member name="P:Quantum.QuantumMultiClientPlayer.DetroyPlayerCallback">
            <summary>
            The callback to notify the MultiClientRunner class of pressing exit.
            </summary>
        </member>
        <member name="P:Quantum.QuantumMultiClientPlayer.PlayerSlot">
            <summary>
            The local player slot this player uses. Only used when AddAsLocalPlayers is enabled.
            </summary>
        </member>
        <member name="P:Quantum.QuantumMultiClientPlayer.MainPlayer">
            <summary>
            If this player is using the connection and QuantumRunner of another player (only used when AddAsLocalPlayers is enabled).
            </summary>
        </member>
        <member name="P:Quantum.QuantumMultiClientPlayer.LocalPlayers">
            <summary>
            Other local players running on this players connection and QuantumRunner.
            </summary>
        </member>
        <member name="P:Quantum.QuantumMultiClientPlayer.View">
            <summary>
            Access the view object.
            </summary>
        </member>
        <member name="M:Quantum.QuantumMultiClientPlayer.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Quantum.QuantumMultiClientPlayer.CreateFreeClientPlayerSlot(System.Int32)">
            <summary>
            Tries to allocate a free player slot for this player. Returns a valid player slot or -1 if no slot is available.
            </summary>
        </member>
        <member name="M:Quantum.QuantumMultiClientPlayer.GetHighestSiblingIndex">
            <summary>
            Gets the highest sibling index of this player and all local players used to correctly name GameObjects.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Quantum.QuantumMultiClientPlayer.CreateInput(UnityEngine.GameObject)">
            <summary>
            Instantiates an input script from a template.
            </summary>
        </member>
        <member name="M:Quantum.QuantumMultiClientPlayer.CreateEntityViewUpdater(Quantum.QuantumEntityViewUpdater,Quantum.QuantumGame)">
            <summary>
            Instantiates an entity view updater script from a template.
            </summary>
        </member>
        <member name="M:Quantum.QuantumMultiClientPlayer.BindView(Quantum.QuantumMultiClientPlayerView,System.Boolean,System.Boolean)">
            <summary>
            Binds a player view to this player.
            </summary>
        </member>
        <member name="M:Quantum.QuantumMultiClientPlayer.Destroy">
            <summary>
            Unity destroy callback shuts down the player (ui, input and evu).
            </summary>
        </member>
        <member name="T:Quantum.GizmoIconColorAttribute">
            <summary>
            Defines the color of a gizmo header in the overlay.
            </summary>
        </member>
        <member name="P:Quantum.GizmoIconColorAttribute.Color">
            <summary>
            The color of the gizmo header.
            </summary>
        </member>
        <member name="M:Quantum.GizmoIconColorAttribute.#ctor(Quantum.ScriptHeaderBackColor)">
            <summary>
            Create a new instance of the <see cref="T:Quantum.GizmoIconColorAttribute"/> class.
            </summary>
            <param name="color"></param>
        </member>
        <member name="T:Quantum.QuantumEntityViewComponent`1">
            <summary>
            The base class to inherit entity view components from.
            Entity view components can be used to add features to entity views and gain simple access to all relevant Quantum game API and the Quantum entity.
            </summary>
            <typeparam name="T">The type of the custom view context used by this view component. Can be `IQuantumEntityViewContext` if not required.</typeparam>
        </member>
        <member name="P:Quantum.QuantumEntityViewComponent`1.Game">
            <summary>
            The Game that the entity belongs to. This can change after the OnGameChanged() callback.
            Set before calling OnActivate(Frame).
            </summary>
        </member>
        <member name="P:Quantum.QuantumEntityViewComponent`1.EntityRef">
            <summary>
            The Quantum EntityRef that the underlying entity view is attached to.
            </summary>
        </member>
        <member name="P:Quantum.QuantumEntityViewComponent`1.EntityView">
            <summary>
            A reference to the parent class to access interesting game and entity data.
            </summary>
        </member>
        <member name="M:Quantum.QuantumEntityViewComponent`1.HasPredictedQuantumComponent``1">
            <summary>
            Checks the predicted frame if this Quantum entity has a particular Quantum entity.
            </summary>
            <typeparam name="TComponent">Quantum component type</typeparam>
            <returns>True, if the entity has the component</returns>
        </member>
        <member name="M:Quantum.QuantumEntityViewComponent`1.HasVerifiedQuantumComponent``1">
            <summary>
            Checks the verified frame if this Quantum entity has a particular Quantum entity.
            </summary>
            <typeparam name="TComponent">Quantum component type</typeparam>
            <returns>True, if the entity has the component</returns>
        </member>
        <member name="M:Quantum.QuantumEntityViewComponent`1.GetPredictedQuantumComponent``1">
            <summary>
            Returns the desired Quantum component from the entity of the the predicted frame.
            This method throws exceptions when the Frame or Entity ref are not assigned, as well as when the Quantum entity does not have the component.
            <see cref="M:Quantum.Core.FrameBase.Get``1(Quantum.EntityRef)"/>
            </summary>
            <typeparam name="TComponent">Quantum component type</typeparam>
            <returns>The Quantum component</returns>
        </member>
        <member name="M:Quantum.QuantumEntityViewComponent`1.GetVerifiedQuantumComponent``1">
            <summary>
            Returns the desired Quantum component from the entity of the the verified frame.
            This method throws exceptions when the Frame or Entity ref are not assigned, as well as when the Quantum entity does not have the component.
            <see cref="M:Quantum.Core.FrameBase.Get``1(Quantum.EntityRef)"/>
            </summary>
            <typeparam name="TComponent">Quantum component type</typeparam>
            <returns>The Quantum component</returns>
        </member>
        <member name="M:Quantum.QuantumEntityViewComponent`1.TryGetPredictedQuantumComponent``1(``0@)">
            <summary>
            Try to get the component from this Quantum entity and the predicted frame.
            <see cref="M:Quantum.Core.FrameBase.TryGet``1(Quantum.EntityRef,``0@)"/>
            </summary>
            <typeparam name="TComponent">Desired component type</typeparam>
            <param name="value">The resulting Quantum component instance.</param>
            <returns>True when the component was found.</returns>
        </member>
        <member name="M:Quantum.QuantumEntityViewComponent`1.TryGetVerifiedQuantumComponent``1(``0@)">
            <summary>
            Try to get the component from this Quantum entity and the verified frame.
            <see cref="M:Quantum.Core.FrameBase.TryGet``1(Quantum.EntityRef,``0@)"/>
            </summary>
            <typeparam name="TComponent">Desired component type</typeparam>
            <param name="value">The resulting Quantum component instance.</param>
            <returns>True when the component was found.</returns>
        </member>
        <member name="T:Quantum.QuantumEntityViewComponent">
            <summary>
            A entity view component without context type.
            </summary>
        </member>
        <member name="T:Quantum.QuantumUnityNativeAllocator">
            <summary>
            The Unity implementation of the Quantum native memory allocator.
            </summary>
        </member>
        <member name="M:Quantum.QuantumUnityNativeAllocator.Alloc(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Quantum.QuantumUnityNativeAllocator.Alloc(System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Quantum.QuantumUnityNativeAllocator.Free(System.Void*)">
            <inheritdoc />
        </member>
        <member name="M:Quantum.QuantumUnityNativeAllocator.Clear(System.Void*,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Quantum.QuantumUnityNativeAllocator.GetManagedVTable">
            <inheritdoc />
        </member>
        <member name="T:Quantum.QuantumUnityNativeUtility">
            <summary>
            The Unity implementation of the Quantum native utility functions.
            </summary>
        </member>
        <member name="M:Quantum.QuantumUnityNativeUtility.Clear(System.Void*,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Quantum.QuantumUnityNativeUtility.Copy(System.Void*,System.Void*,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Quantum.QuantumUnityNativeUtility.Move(System.Void*,System.Void*,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Quantum.QuantumUnityNativeUtility.Set(System.Void*,System.Byte,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Quantum.QuantumUnityNativeUtility.Compare(System.Void*,System.Void*,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Quantum.QuantumUnityNativeUtility.ResetStatics">
            <summary>
            Reset statics. Currently does nothing.
            </summary>
        </member>
        <member name="T:Quantum.QuantumNavMeshDebugDrawer">
            <summary>
            Obsolete script. Navmesh editor gizmos are now rendered with the map.
            </summary>
        </member>
        <member name="T:Quantum.QuantumMapLoader">
            <summary>
            A Unity script that helps with loading Quantum maps and scenes.
            </summary>
        </member>
        <member name="P:Quantum.QuantumMapLoader.Instance">
            <summary>
            Gets or creates a global instance of the QuantumMapLoader.
            <para>Will return null when the application is about to quit.</para>
            </summary>
        </member>
        <member name="M:Quantum.QuantumMapLoader.Awake">
            <summary>
            Unity Awake method. Tag this GameObject as DontDestroyOnLoad.
            </summary>
        </member>
        <member name="M:Quantum.QuantumMapLoader.OnApplicationQuit">
            <summary>
            Unity OnApplicationQuit callback, sets the application quitting flag to prevent further instance creation.
            </summary>
        </member>
        <member name="M:Quantum.QuantumMapLoader.ResetStatics">
            <summary>
            Reset global statics.
            </summary>
        </member>
        <member name="T:Quantum.SerializedObjectExtensions">
            <summary>
            Quantum utilities to work with Unity serialized objects.
            </summary>
        </member>
        <member name="M:Quantum.SerializedObjectExtensions.FindPropertyOrThrow(UnityEditor.SerializedObject,System.String)">
            <summary>
            Find a property in the serialized object or throw an exception if not found.
            </summary>
            <param name="so">ScriptableObject</param>
            <param name="propertyPath">Property path</param>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Is raised when not found</exception>
        </member>
        <member name="M:Quantum.SerializedObjectExtensions.FindPropertyRelativeOrThrow(UnityEditor.SerializedProperty,System.String)">
            <summary>
            Find a property at a relative path to the current property or throw an exception if not found.
            </summary>
            <param name="sp">Serialized property to start searching from</param>
            <param name="relativePropertyPath">Relative path to current property</param>
            <returns></returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Is raised when not found</exception>
        </member>
        <member name="M:Quantum.SerializedObjectExtensions.FindPropertyRelativeToParent(UnityEditor.SerializedProperty,System.String)">
            <summary>
            Find a property at a relative path to the parent property
            </summary>
            <param name="property">Serialized property to start searching from</param>
            <param name="relativePath">Relative path from the parent</param>
            <returns>Found property or null</returns>
        </member>
        <member name="M:Quantum.SerializedObjectExtensions.FindPropertyRelativeToParentOrThrow(UnityEditor.SerializedProperty,System.String)">
            <summary>
            Find a property at a relative path to the parent property or throw an exception if not found.
            </summary>
            <param name="property">Serialized property to start searching from</param>
            <param name="relativePath">Relative path from the parent</param>
            <returns>Found property or null</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Is raised when not found</exception>
        </member>
        <member name="M:Quantum.SerializedObjectExtensions.GetIntegerValue(UnityEditor.SerializedProperty)">
            <summary>
            Convert different property types to an integer value.
            </summary>
            <param name="sp">Property</param>
            <returns>The converted int value or 0</returns>
        </member>
        <member name="M:Quantum.SerializedObjectExtensions.SetIntegerValue(UnityEditor.SerializedProperty,System.Int64)">
            <summary>
            Set an integer value to a different serialized property types.
            </summary>
            <param name="sp">Property</param>
            <param name="value">Value to set</param>
            <exception cref="T:System.NotSupportedException">Is raised if setting an integer is not supported</exception>
        </member>
        <member name="T:Quantum.FPMathUtils">
            <summary>
            Unity specific FixedPoint math utilities.
            All conversions between Unity float into Quantum FP (e.g. Vector2 to FPVector2) 
            are considered non-deterministic and should never be used in the Quantum simulation directly.
            </summary>
        </member>
        <member name="M:Quantum.FPMathUtils.LoadLookupTables(System.Boolean)">
            <summary>
            Load the lookup tables from the resources folders.
            </summary>
            <param name="force">Will reload the table if set to true</param>
        </member>
        <member name="M:Quantum.FPMathUtils.ToFP(System.Single)">
            <summary>
            Convert a float to an FP, with rounding towards zero.
            To round towards nearest representable FP, use <see cref="M:Quantum.FPMathUtils.ToRoundedFP(System.Single)"/>.
            This is always considered to be unsafe and non-deterministic and should never be used in conjunction with the simulation.
            </summary>
            <seealso cref="M:Photon.Deterministic.FP.FromFloat_UNSAFE(System.Single)"/>
        </member>
        <member name="M:Quantum.FPMathUtils.ToRoundedFP(System.Single)">
            <summary>
            Convert a float to an FP, with rounding to the nearest representable FP.
            This is always considered to be unsafe and non-deterministic and should never be used in conjunction with the simulation.
            </summary>
            <seealso cref="M:Photon.Deterministic.FP.FromRoundedFloat_UNSAFE(System.Single)"/>
        </member>
        <member name="M:Quantum.FPMathUtils.FlipRotation(Photon.Deterministic.FP)">
            <summary>
            Inverts the FP if QUNATUM_XY is not defined.
            </summary>
            <param name="r">2D rotation</param>
            <returns>Inverted value.</returns>
        </member>
        <member name="M:Quantum.FPMathUtils.ToUnityQuaternionDegrees(Photon.Deterministic.FP)">
            <summary>
            Create a Quaternion from a y rotation in degrees.
            Internally checks QUANTUM_XY to rotate around z instead.
            </summary>
            <param name="r">Rotation in degrees</param>
            <returns>Unity rotation</returns>
        </member>
        <member name="M:Quantum.FPMathUtils.ToUnityQuaternion(Photon.Deterministic.FP)">
            <summary>
            Creates a Quaternion from a y rotation in radians.
            Internally checks QUANTUM_XY to rotate around z instead.
            </summary>
            <param name="r">Rotation in radians</param>
            <returns>Unity rotation</returns>
        </member>
        <member name="M:Quantum.FPMathUtils.ToUnityQuaternion(Photon.Deterministic.FPQuaternion)">
            <summary>
            Converts a Quantum FPQuaternion to a Unity Quaternion.
            </summary>
            <param name="r">Rotation</param>
            <returns>Unity rotation</returns>
        </member>
        <member name="M:Quantum.FPMathUtils.ToUnityQuaternion(Photon.Deterministic.FPQuaternion,System.Boolean)">
            <summary>
            Converts a Quantum FPQuaternion to a Unity Quaternion with swizzling the y and z axis.
            </summary>
            <param name="r">Rotation</param>
            <param name="swizzle">True if the rotation should swizzle</param>
            <returns>Unity rotation</returns>
        </member>
        <member name="M:Quantum.FPMathUtils.ToFPQuaternion(UnityEngine.Quaternion)">
            <summary>
            Convert a Unity quaternion to a Quantum FPQuaternion.
            </summary>
            <param name="r">Rotation</param>
            <returns>Quantum rotation</returns>
        </member>
        <member name="M:Quantum.FPMathUtils.ToFPRotation2DDegrees(UnityEngine.Quaternion)">
            <summary>
            Converts a Unity quaternion to 2D rotation in degrees by only using the y 
            (or z axis if QUANTUM_XY is defined)
            </summary>
            <param name="r">Unity rotation</param>
            <returns>2D rotation in degree</returns>
        </member>
        <member name="M:Quantum.FPMathUtils.ToFPRotation2D(UnityEngine.Quaternion)">
            <summary>
            Converts a Unity quaternion to 2D rotation in radians by only using the y 
            (or z axis if QUANTUM_XY is defined)
            </summary>
            <param name="r">Unity rotation</param>
            <returns>2D rotation in radian</returns>
        </member>
        <member name="M:Quantum.FPMathUtils.ToFPVector2(UnityEngine.Vector2)">
            <summary>
            Converts a Unity Vector2 to a Quantum FPVector2, with each component being rounded towards zero.
            To round towards the nearest representable FP, use <see cref="M:Quantum.FPMathUtils.ToRoundedFPVector2(UnityEngine.Vector3)"/>.
            </summary>
            <param name="v">Unity vector2</param>
            <returns>Quantum vector2</returns>
        </member>
        <member name="M:Quantum.FPMathUtils.ToUnityVector2(Photon.Deterministic.FPVector2)">
            <summary>
            Converts a Quantum FPVector2 to a Unity Vector2.
            </summary>
            <param name="v">Quantum vector2</param>
            <returns>Unity vector2</returns>
        </member>
        <member name="M:Quantum.FPMathUtils.ToFPVector2(UnityEngine.Vector3)">
            <summary>
            Converts a Unity Vector3 to a Quantum FPVector2 by removing the y component 
            (removing the z component if QUANTUM_XY is defined). Each component is rounded towards zero.
            </summary>
            <param name="v">Unity vector3</param>
            <returns>Quantum vector2</returns>
            <seealso cref="M:Photon.Deterministic.FP.FromFloat_UNSAFE(System.Single)"/>
        </member>
        <member name="M:Quantum.FPMathUtils.ToRoundedFPVector2(UnityEngine.Vector3)">
            <summary>
            Converts a Unity Vector3 to a Quantum FPVector2 by removing the y component 
            (removing the z component if QUANTUM_XY is defined). Each component is rounded towards
            the nearest representable FP.
            </summary>
            <param name="v">Unity vector3</param>
            <returns>Quantum vector2</returns>
            <seealso cref="M:Photon.Deterministic.FP.FromRoundedFloat_UNSAFE(System.Single)"/>
        </member>
        <member name="M:Quantum.FPMathUtils.ToFPVerticalPosition(UnityEngine.Vector3)">
            <summary>
            Extracts the vertical position of a Unity Vector3 and converts it to a Quantum FP.
            Will use the inverse z component if QUANTUM_XY is defined.
            </summary>
            <param name="v">Unity vector3</param>
            <returns>The height component</returns>
        </member>
        <member name="M:Quantum.FPMathUtils.ToFPVector3(UnityEngine.Vector3)">
            <summary>
            Converts a Unity vector3 to a Quantum FPVector3, with each component being rounded towards zero.
            </summary>
            <param name="v">Unity vector3</param>
            <returns>Quantum vector3</returns>
        </member>
        <member name="M:Quantum.FPMathUtils.ToFPMatrix4X4(UnityEngine.Matrix4x4)">
            <summary>
            Converts a Unity Matrix4x4 to a Quantum FPMatrix4x4, with each component being rounded towards the nearest representable FP.
            </summary>
            <param name="m">The Unity Matrix4x4</param>
            <returns>Quantum Matrix4x4</returns>
        </member>
        <member name="M:Quantum.FPMathUtils.ToRoundedFPVector3(UnityEngine.Vector3)">
            <summary>
            Converts a Unity vector3 to a Quantum FPVector3, with each component being rounded towards the nearest representable FP.
            </summary>
            <param name="v">Unity vector3</param>
            <returns>Quantum vector3</returns>
        </member>
        <member name="M:Quantum.FPMathUtils.ToUnityVector3(Photon.Deterministic.FPVector2)">
            <summary>
            Converts a Quantum vector2 to a Unity vector3 by setting the y component to 0.
            (sets the z component to 0 if QUANTUM_XY is defined).
            </summary>
            <param name="v">Quantum vector2</param>
            <returns>Unity vector3</returns>
        </member>
        <member name="M:Quantum.FPMathUtils.ToUnityVector3(Photon.Deterministic.FPVector3)">
            <summary>
            Converts a Quantum vector3 to a Unity vector3.
            </summary>
            <param name="v">Quantum vector3</param>
            <returns>Unity vector3</returns>
        </member>
        <member name="M:Quantum.FPMathUtils.ToUnityVector3(Photon.Deterministic.FPVector3,System.Boolean)">
            <summary>
              Use this version of ToUnityVector3() when converting a 3D position from the XZ plane in the simulation to the 2D XY
              plane in Unity.
            </summary>
        </member>
        <member name="M:Quantum.FPMathUtils.ToUnityVector2(Photon.Deterministic.FPVector3)">
            <summary>
            Obsolete
            </summary>
        </member>
        <member name="M:Quantum.FPMathUtils.RoundToInt(UnityEngine.Vector3)">
            <summary>
            Rounds all components of the Unity vector to the nearest integer.
            </summary>
            <param name="v">Unity vector3</param>
            <returns>The rounded vector</returns>
        </member>
        <member name="M:Quantum.FPMathUtils.RoundToInt(UnityEngine.Vector2)">
            <summary>
            Rounds all components of the Unity vector to the nearest integer.
            </summary>
            <param name="v">Unity vector2</param>
            <returns>The rounded vector</returns>
        </member>
        <member name="M:Quantum.FPMathUtils.ToColor32(Quantum.ColorRGBA)">
            <summary>
            Obsolete
            </summary>
        </member>
        <member name="M:Quantum.FPMathUtils.ToColor(Quantum.ColorRGBA)">
            <summary>
            Obsolete
            </summary>
        </member>
        <member name="T:Quantum.QuantumNavMeshRegion">
            <summary>
            This script can be placed on a game object that has a mesh renderer and is used to cast Quantum navmesh toggle-able regions onto the Unity generated navmesh.
            </summary>
        </member>
        <member name="T:Quantum.QuantumNavMeshRegion.RegionCastType">
            <summary>
            The Quantum region cast type.
            </summary>
        </member>
        <member name="F:Quantum.QuantumNavMeshRegion.RegionCastType.CastRegion">
            <summary>
            Create a region on the navmesh.
            </summary>
        </member>
        <member name="F:Quantum.QuantumNavMeshRegion.RegionCastType.NoRegion">
            <summary>
            Do not create a region on the navmesh (Quantum navmesh links for example).
            </summary>
        </member>
        <member name="F:Quantum.QuantumNavMeshRegion.Id">
            <summary>
            All regions with the same id are toggle-able as one region. Check Map.Regions to see the results.
            </summary>
        </member>
        <member name="F:Quantum.QuantumNavMeshRegion.CastRegion">
            <summary>
            Set to CastRegion when the region should be casted onto the navmesh. For Links for example chose NoRegion.
            </summary>
        </member>
        <member name="F:Quantum.QuantumNavMeshRegion.Cost">
            <summary>
            Cost modifier that is applied to the heuristics of the path finding. Automatically gets the Unity area cost when adding the scripts. Toggle <see cref="F:Quantum.QuantumNavMeshRegion.OverwriteCost"/> to set to a custom value.
            </summary>
        </member>
        <member name="F:Quantum.QuantumNavMeshRegion.OverwriteCost">
            <summary>
            Enabled to set a different <see cref="F:Quantum.QuantumNavMeshRegion.Cost"/>.
            </summary>
        </member>
        <member name="T:Quantum.QuantumColor">
            <summary>
            Quantum default colors.
            </summary>
        </member>
        <member name="P:Quantum.QuantumColor.Log">
            <summary>
            The color of the highlighted Quantum log can change depending on the dark/light mode.
            </summary>
        </member>
        <member name="T:Quantum.QuantumStaticBoxCollider3D">
            <summary>
            The script will create a static 3D Quantum box collider during map baking.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticBoxCollider3D.SourceCollider">
            <summary>
            The Unity box collider to copy the size and position of during Quantum map baking.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticBoxCollider3D.Size">
            <summary>
            The size of the collider.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticBoxCollider3D.PositionOffset">
            <summary>
            The position offset added to the <see cref="P:UnityEngine.Transform.position"/> during baking.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticBoxCollider3D.RotationOffset">
            <summary>
            The rotation offset added to the <see cref="P:UnityEngine.Transform.rotation"/> during baking.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticBoxCollider3D.Settings">
            <summary>
            Additional static collider settings.
            </summary>
        </member>
        <member name="M:Quantum.QuantumStaticBoxCollider3D.UpdateFromSourceCollider">
            <summary>
            Copy collider configuration from source collider if exist. 
            </summary>
        </member>
        <member name="M:Quantum.QuantumStaticBoxCollider3D.BeforeBake">
            <summary>
            Callback before baking the collider.
            </summary>
        </member>
        <member name="T:Quantum.QuantumStaticEdgeCollider2D">
            <summary>
            The script will create a static 2D edge collider during Quantum map baking.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticEdgeCollider2D.SourceCollider">
            <summary>
            Link a Unity edge collider to copy its size and position of during Quantum map baking.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticEdgeCollider2D.VertexA">
            <summary>
            Vertex A of the edge.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticEdgeCollider2D.VertexB">
            <summary>
            Vertex B of the edge.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticEdgeCollider2D.PositionOffset">
            <summary>
            The position offset added to the <see cref="P:UnityEngine.Transform.position"/> during baking.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticEdgeCollider2D.RotationOffset">
            <summary>
            The rotation offset added to the <see cref="P:UnityEngine.Transform.rotation"/> during baking.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticEdgeCollider2D.Height">
            <summary>
            The optional 2D pseudo height of the collider.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticEdgeCollider2D.Settings">
            <summary>
            Additional static collider settings.
            </summary>
        </member>
        <member name="M:Quantum.QuantumStaticEdgeCollider2D.UpdateFromSourceCollider">
            <summary>
            Copy collider configuration from source collider if exist. 
            </summary>
        </member>
        <member name="M:Quantum.QuantumStaticEdgeCollider2D.BeforeBake">
            <summary>
            Callback before baking the collider.
            </summary>
        </member>
        <member name="M:Quantum.QuantumStaticEdgeCollider2D.GetEdgeGizmosSettings(UnityEngine.Transform,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Photon.Deterministic.FP,UnityEngine.Vector3@,UnityEngine.Vector3@,System.Single@)">
            <summary>
            Edge transformation to bake.
            </summary>
        </member>
        <member name="T:Quantum.JsonUtilityExtensions">
            <summary>
            Extends capabilities of <see cref="T:UnityEngine.JsonUtility"/> by adding type annotations to the serialized JSON, Unity object reference
            handling and integer enquotement.
            </summary>
        </member>
        <member name="T:Quantum.JsonUtilityExtensions.TypeResolverDelegate">
            <see cref="M:Quantum.JsonUtilityExtensions.FromJsonWithTypeAnnotation(System.String,Quantum.JsonUtilityExtensions.TypeResolverDelegate)"/>
        </member>
        <member name="T:Quantum.JsonUtilityExtensions.TypeSerializerDelegate">
            <see cref="M:Quantum.JsonUtilityExtensions.ToJsonWithTypeAnnotation(System.Object,Quantum.JsonUtilityExtensions.InstanceIDHandlerDelegate)"/>
        </member>
        <member name="T:Quantum.JsonUtilityExtensions.InstanceIDHandlerDelegate">
            <see cref="M:Quantum.JsonUtilityExtensions.ToJsonWithTypeAnnotation(System.Object,Quantum.JsonUtilityExtensions.InstanceIDHandlerDelegate)"/>
        </member>
        <member name="M:Quantum.JsonUtilityExtensions.EnquoteIntegers(System.String,System.Int32)">
            <summary>
            Enquotes integers in the JSON string that are at least <paramref name="minDigits"/> long. This is useful for parsers that
            interpret large integers as floating point numbers.
            </summary>
            <param name="json">JSON to process</param>
            <param name="minDigits">Digit threshold to perform the enquoting</param>
            <returns><paramref name="json"/> with long integers enquoted.</returns>
        </member>
        <member name="M:Quantum.JsonUtilityExtensions.ToJsonWithTypeAnnotation(System.Object,Quantum.JsonUtilityExtensions.InstanceIDHandlerDelegate)">
            <summary>
            Converts the object to JSON with type annotations.
            </summary>
            <param name="obj">Object to be serialized.</param>
            <param name="instanceIDHandler">Handler for UnityEngine.Object references. If the handler returns an empty string,
            the reference is removed from the final result.</param>
        </member>
        <member name="M:Quantum.JsonUtilityExtensions.ToJsonWithTypeAnnotation(System.Object,System.IO.TextWriter,System.Nullable{System.Int32},Quantum.JsonUtilityExtensions.TypeSerializerDelegate,Quantum.JsonUtilityExtensions.InstanceIDHandlerDelegate)">
            <summary>
            Converts the object/IList to JSON with type annotations.
            </summary>
            <param name="obj">Object to be serialized.</param>
            <param name="writer">The output TextWriter.</param>
            <param name="integerEnquoteMinDigits"><see cref="M:Quantum.JsonUtilityExtensions.EnquoteIntegers(System.String,System.Int32)"/></param>
            <param name="typeSerializer">Handler for obtaining serialized type names. If <see langword="null"/>, the short assembly
            qualified name (namespace + name + assembly name) will be used.</param>
            <param name="instanceIDHandler">Handler for UnityEngine.Object references. If the handler returns an empty string,
            the reference is removed from the final result.</param>
        </member>
        <member name="M:Quantum.JsonUtilityExtensions.FromJsonWithTypeAnnotation``1(System.String,Quantum.JsonUtilityExtensions.TypeResolverDelegate)">
            <summary>
            Converts JSON with type annotation to an instance of <typeparamref name="T"/>. If the JSON contains type annotations, they need to match
            the expected result type. If there are no type annotations, use <paramref name="typeResolver"/> to return the expected type.
            </summary>
            <param name="json">JSON to be parsed</param>
            <param name="typeResolver">Converts type name to a type instance.</param>
        </member>
        <member name="M:Quantum.JsonUtilityExtensions.FromJsonWithTypeAnnotation(System.String,Quantum.JsonUtilityExtensions.TypeResolverDelegate)">
            <summary>
            Converts JSON with type annotation. If there are no type annotations, use <paramref name="typeResolver"/> to return the expected type.
            </summary>
            <param name="json">JSON to be parsed</param>
            <param name="typeResolver">Converts type name to a type instance.</param>
        </member>
        <member name="T:Quantum.QuantumAddressablesUtils">
            <summary>
            Utility class for addressables.
            </summary>
        </member>
        <member name="M:Quantum.QuantumAddressablesUtils.TryParseAddress(System.String,System.String@,System.String@)">
            <summary>
            Tries to parse the address into main part and sub object name.
            </summary>
            <param name="address">The address to parse.</param>
            <param name="mainPart">The main part of the address.</param>
            <param name="subObjectName">The sub object name.</param>
            <returns><see langword="true"/> if the address is successfully parsed; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.QuantumAddressablesUtils.CreateAssetReference(System.String)">
            <summary>
            Creates an asset reference from the given address.
            </summary>
            <param name="address">The address to create the asset reference from.</param>
            <returns>The created asset reference.</returns>
            <exception cref="T:System.ArgumentException">Thrown when the main part of the address is not a guid or the address is not valid.</exception>
        </member>
        <member name="M:Quantum.QuantumAddressablesUtils.LoadEditorInstance(System.String)">
            <summary>
            Loads the editor instance for the given runtime key.
            </summary>
            <param name="runtimeKey">The runtime key.</param>
            <returns>The loaded editor instance.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when the load editor instance handler is not set.</exception>
        </member>
        <member name="M:Quantum.QuantumAddressablesUtils.SetLoadEditorInstanceHandler(System.Func{System.String,UnityEngine.Object})">
            <summary>
            Sets the load editor instance handler.
            </summary>
            <param name="loadEditorInstance">The load editor instance handler.</param>
        </member>
        <member name="T:Quantum.QuantumMppmStatus">
            <summary>
            The current status of MPPM. If the package is not enabled, this will always be <see cref="F:Quantum.QuantumMppmStatus.Disabled"/>.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMppmStatus.Disabled">
            <summary>
            MPPM is not installed.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMppmStatus.MainInstance">
            <summary>
            This instance is the main instance. Can use <see cref="M:Quantum.QuantumMppm.Send``1(``0)"/> to send commands.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMppmStatus.VirtualInstance">
            <summary>
            This instance is a virtual instance. Will receive commands from the main instance.
            </summary>
        </member>
        <member name="T:Quantum.QuantumMppm">
            <summary>
            Support for Multiplayer Play Mode (MPPM). It uses named pipes
            to communicate between the main Unity instance and virtual instances.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMppm.Status">
            <summary>
            The current status of MPPM.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMppm.MainEditor">
            <summary>
            If <see cref="F:Quantum.QuantumMppm.Status"/> is <see cref="F:Quantum.QuantumMppmStatus.MainInstance"/>, this static field can be used to send commands.
            </summary>
        </member>
        <member name="M:Quantum.QuantumMppm.Send``1(``0)">
            <summary>
            Sends a command to all virtual instances. Use as:
            <code>QuantumMppm.MainEditor?.Send</code>
            </summary>
            <param name="data"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Quantum.QuantumMppm.Broadcast``1(``0)">
            <summary>
            Broadcasts a command to all virtual instances.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="data"></param>
        </member>
        <member name="T:Quantum.QuantumMppmCommand">
            <summary>
            The base class for all Quantum MPPM commands.
            </summary>
        </member>
        <member name="M:Quantum.QuantumMppmCommand.Execute">
            <summary>
            Execute the command on a virtual instance.
            </summary>
        </member>
        <member name="P:Quantum.QuantumMppmCommand.NeedsAck">
            <summary>
            Does the main instance need to wait for an ack?
            </summary>
        </member>
        <member name="P:Quantum.QuantumMppmCommand.PersistentKey">
            <summary>
            If the command is persistent (i.e. needs to be executed on each domain reload), this key is used to store it.
            </summary>
        </member>
        <member name="T:Quantum.QuantumMppmRegisterCustomDependencyCommand">
            <summary>
            A command implementing a workaround for MPPM not syncing custom dependencies.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMppmRegisterCustomDependencyCommand.DependencyName">
            <summary>
            Name of the custom dependency.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMppmRegisterCustomDependencyCommand.Hash">
            <summary>
            Hash of the custom dependency.
            </summary>
        </member>
        <member name="P:Quantum.QuantumMppmRegisterCustomDependencyCommand.NeedsAck">
            <inheritdoc cref="P:Quantum.QuantumMppmCommand.NeedsAck"/>
        </member>
        <member name="P:Quantum.QuantumMppmRegisterCustomDependencyCommand.PersistentKey">
            <inheritdoc cref="P:Quantum.QuantumMppmCommand.PersistentKey"/>
        </member>
        <member name="M:Quantum.QuantumMppmRegisterCustomDependencyCommand.Execute">
            <summary>
            Registers a custom dependency with the given name and hash.
            </summary>
        </member>
        <member name="T:Quantum.QuantumUnityExtensions">
            <summary>
            Provides backwards compatibility for Unity API.
            </summary>
        </member>
        <member name="T:Quantum.QuantumEntityViewBindBehaviour">
            <summary>
            The view bind behaviour controls when the view is created. For entities on the predicted or entities on the verified frame. 
            Because the verified frame is confirmed by the server this bind behaviour will show local entity views delayed.
            When using non-verifed it may happen that they get destroyed when the frame is finally confirmed by the server.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityViewBindBehaviour.NonVerified">
            <summary>
            The entity view is created during a predicted frame.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityViewBindBehaviour.Verified">
            <summary>
            The entity view is created during a verified frame.
            </summary>
        </member>
        <member name="T:Quantum.QuantumEntityPrototypeColliderLayerSource">
            <summary>
            Defines the source of the physics collider layer information.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototypeColliderLayerSource.GameObject">
            <summary>
            The layer information is retrieved from the Source Collider's GameObject (if one is provided)
            or this Prototype's GameObject (otherwise).
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototypeColliderLayerSource.Explicit">
            <summary>
            The layer is defined explicitly from a layer enumeration.
            </summary>
        </member>
        <member name="T:Quantum.QuantumNetworkCommunicator">
            <summary>
            This class implements the Quantum interface <see cref="T:Photon.Deterministic.ICommunicator"/> and uses Photon Realtime in Unity 
            to support sending <see cref="M:Quantum.QuantumNetworkCommunicator.RaiseEvent(System.Byte,System.Byte[],System.Int32,System.Boolean,System.Int32[])"/> and receiving <see cref="M:Quantum.QuantumNetworkCommunicator.AddEventListener(Photon.Deterministic.OnEventReceived)"/> 
            network messages from the Photon Cloud.
            </summary>
        </member>
        <member name="P:Quantum.QuantumNetworkCommunicator.ShutdownConnectionOptions">
            <summary>
            When this class is assigned to a Quantum session this option configures what happens to the standing 
            online connecting when the Quantum simulation is completed. By default the connection is shutdown as well.
            Other options are staying in the Photon room or returning to the master server.
            </summary>
        </member>
        <member name="P:Quantum.QuantumNetworkCommunicator.NetworkClient">
            <summary>
            The Realtime client object which is assigned inside the constructor.
            </summary>
        </member>
        <member name="P:Quantum.QuantumNetworkCommunicator.IsConnected">
            <summary>
            Returns <see cref="P:Photon.Realtime.RealtimeClient.IsConnected"/>.
            </summary>
        </member>
        <member name="P:Quantum.QuantumNetworkCommunicator.RoundTripTime">
            <summary>
            Returns the RTT measured by the Realtime client.
            </summary>
        </member>
        <member name="P:Quantum.QuantumNetworkCommunicator.ActorNumber">
            <summary>
            Returns the Photon Actor Number that this client was assigned to.
            </summary>
        </member>
        <member name="M:Quantum.QuantumNetworkCommunicator.#ctor(Photon.Realtime.RealtimeClient,Quantum.ShutdownConnectionOptions)">
            <summary>
            Create instance to assign to <see cref="F:Quantum.SessionRunner.Arguments.Communicator"/>.
            The client object is expected to be connected to a game server (joined a room).
            </summary>
            <param name="loadBalancingClient">The connected Realtime client object</param>
            <param name="shutdownConnectionOptions">Optionally chose the shutdown behaviour</param>
        </member>
        <member name="M:Quantum.QuantumNetworkCommunicator.DisposeEventObject(System.Object)">
            <summary>
            Called by Quantum to recycle incoming message objects.
            </summary>
            <param name="obj">Message object to recycle</param>
        </member>
        <member name="M:Quantum.QuantumNetworkCommunicator.RaiseEvent(System.Byte,System.Byte[],System.Int32,System.Boolean,System.Int32[])">
            <summary>
            Called by Quantum to send messages.
            </summary>
        </member>
        <member name="M:Quantum.QuantumNetworkCommunicator.AddEventListener(Photon.Deterministic.OnEventReceived)">
            <summary>
            Called by Quantum to subscribe to incoming messages.
            </summary>
        </member>
        <member name="M:Quantum.QuantumNetworkCommunicator.Service">
            <summary>
            Called by Quantum to update the Realtime client.
            </summary>
        </member>
        <member name="M:Quantum.QuantumNetworkCommunicator.OnDestroy">
            <summary>
            Called by Quantum when the simulation is shut down.
            Also called by the <see cref="T:Quantum.SessionRunner"/> when shutting down.
            </summary>
        </member>
        <member name="M:Quantum.QuantumNetworkCommunicator.OnDestroyAsync">
            <summary>
            Called when the <see cref="T:Quantum.SessionRunner"/> is shutting down async.
            </summary>
        </member>
        <member name="T:Quantum.QuantumMeshCollection">
            <summary>
            A collection of Unity mesh asset to draw gizmos or scene object. 
            </summary>
        </member>
        <member name="F:Quantum.QuantumMeshCollection.Capsule">
            <summary>
            Capsule mesh.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMeshCollection.Circle">
            <summary>
            Circle mesh.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMeshCollection.CircleXY">
            <summary>
            Circle mesh that is aligned to XY plane.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMeshCollection.Cube">
            <summary>
            Cube mesh.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMeshCollection.Cylinder">
            <summary>
            Cylinder mesh.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMeshCollection.CylinderXY">
            <summary>
            Cylinder mesh that is aligned to XY plane.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMeshCollection.Quad">
            <summary>
            Quad mesh.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMeshCollection.QuadXY">
            <summary>
            Quad mesh that is aligned to XY plane.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMeshCollection.Sphere">
            <summary>
            Sphere mesh.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMeshCollection.DebugMaterial">
            <summary>
            Debug material used by <see cref="T:Quantum.DebugDraw"/> 
            when drawing debug shapes from the Quantum simulation.
            </summary>
        </member>
        <member name="T:Quantum.QuantumRunnerUnityFactory">
            <summary>
            Implements the runner factory to Unity platform.
            </summary>
        </member>
        <member name="F:Quantum.QuantumRunnerUnityFactory.DefaultFactory">
            <summary>
            Statically keep one default factory around.
            </summary>
        </member>
        <member name="P:Quantum.QuantumRunnerUnityFactory.CreateGameParameters">
            <summary>
            Create game parameters and set default values based on the platform.
            </summary>
        </member>
        <member name="P:Quantum.QuantumRunnerUnityFactory.CreatePlaformInfo">
            <summary>
            Create the Unity platform information object.
            </summary>
        </member>
        <member name="P:Quantum.QuantumRunnerUnityFactory.CreateTaskFactory">
            <summary>
            Assign a task factory that will be used by the runner to create and chain new tasks.
            </summary>
        </member>
        <member name="P:Quantum.QuantumRunnerUnityFactory.UpdateDB">
            <summary>
            Assign an action to update the global database.
            </summary>
        </member>
        <member name="M:Quantum.QuantumRunnerUnityFactory.CreateRunner(Quantum.SessionRunner.Arguments)">
            <summary>
            Creates a unity GameObject and attaches a QuantumRunnerBehaviour to it which will then update the actual session runner object. 
            </summary>
            <param name="arguments">Session arguments</param>
            <returns>A session runner object</returns>
        </member>
        <member name="M:Quantum.QuantumRunnerUnityFactory.CreateGame(Quantum.QuantumGameStartParameters)">
            <summary>
            Create a DeterministicGame instance.
            </summary>
            <param name="startParameters">Game start parameters</param>
            <returns>QuantumGame instance</returns>
        </member>
        <member name="M:Quantum.QuantumRunnerUnityFactory.CreateProfiler(System.String,Photon.Deterministic.DeterministicSessionConfig,Photon.Deterministic.DeterministicPlatformInfo,Photon.Deterministic.IDeterministicGame)">
            <summary>
            Create and attach a remote profiler to the game.
            </summary>
            <param name="clientId">Client id</param>
            <param name="deterministicConfig">Deterministic config</param>
            <param name="platformInfo">Platform information</param>
            <param name="game">Game object</param>
        </member>
        <member name="M:Quantum.QuantumRunnerUnityFactory.CreatePlatformInfo">
            <summary>
            Create the Unity platform information object.
            </summary>
            <returns>Platform info object</returns>
        </member>
        <member name="M:Quantum.QuantumRunnerUnityFactory.Init(System.Boolean)">
            <summary>
            Static initializer to initialize Quantum base systems required by the factory and Quantum in general.
            </summary>
            <param name="force">Force reload the LUT</param>
        </member>
        <member name="T:Quantum.QuantumCallbacks">
            <summary>
            A legacy way to hook into Quantum game callbacks.
            Use the publish subscribe pattern used by <see cref="T:Quantum.QuantumCallbacks"/> instead.
            To use this callback class, derive from it and implement the methods you are interested in.
            The callback MonoBehaviour has to be added to the scene to work.
            </summary>
        </member>
        <member name="F:Quantum.QuantumCallbacks.Instances">
            <summary>
            Static list of all instances of QuantumCallbacks to call on Quantum callbacks.
            Populated on OnEnable and OnDisable.
            </summary>
        </member>
        <member name="M:Quantum.QuantumCallbacks.OnEnable">
            <summary>
            Unity OnEnable event registers this instance to the static list called by the Quantum callbacks.
            </summary>
        </member>
        <member name="M:Quantum.QuantumCallbacks.OnDisable">
            <summary>
            Unity OnDisable event removes itself from the static callback list.
            </summary>
        </member>
        <member name="M:Quantum.QuantumCallbacks.OnGameInit(Quantum.QuantumGame,System.Boolean)">
            <summary>
            Is called by <see cref="T:Quantum.CallbackGameInit"/> during <see cref="M:Quantum.QuantumGame.OnGameStart(Photon.Deterministic.DeterministicFrame)"/>
            when the game is about to start.
            </summary>
            <param name="game">The Quantum game</param>
            <param name="isResync">Is true when the simulation is paused and waits for snapshot to commence the start.</param>
        </member>
        <member name="M:Quantum.QuantumCallbacks.OnGameStart(Quantum.QuantumGame)">
            <summary>
            Obsolete: use other OnGameStart overload.
            </summary>
            <param name="game"></param>
        </member>
        <member name="M:Quantum.QuantumCallbacks.OnGameStart(Quantum.QuantumGame,System.Boolean)">
            <summary>
            Is called by <see cref="T:Quantum.CallbackGameStarted"/> during 
            <see cref="M:Quantum.QuantumGame.OnGameStart(Photon.Deterministic.DeterministicFrame)"/> or <see cref="M:Quantum.QuantumGame.OnGameResync"/>"
            when the game is started after systems are initialized and the snapshot has arrived
            for late-joining clients.
            </summary>
            <param name="game">Quantum game</param>
            <param name="isResync">Is true if the game was started from a snapshot.</param>
        </member>
        <member name="M:Quantum.QuantumCallbacks.OnGameResync(Quantum.QuantumGame)">
            <summary>
            Is called by <see cref="T:Quantum.CallbackGameResynced"/> during <see cref="M:Quantum.QuantumGame.OnGameResync"/> when 
            the game has been re-synchronized from a snapshot and is about to start.
            </summary>
            <param name="game">Quantum game</param>
        </member>
        <member name="M:Quantum.QuantumCallbacks.OnGameDestroyed(Quantum.QuantumGame)">
            <summary>
            Is called by <see cref="T:Quantum.CallbackGameDestroyed"/> when the session has been destroyed."/>
            </summary>
            <param name="game">Quantum game</param>
        </member>
        <member name="M:Quantum.QuantumCallbacks.OnUpdateView(Quantum.QuantumGame)">
            <summary>
            Is called by <see cref="T:Quantum.CallbackUpdateView"/> which is originally 
            called by <see cref="M:Quantum.QuantumRunner.Update"/> and it is called every Unity frame.
            </summary>
            <param name="game">Quantum game</param>
        </member>
        <member name="M:Quantum.QuantumCallbacks.OnSimulateFinished(Quantum.QuantumGame,Quantum.Frame)">
            <summary>
            Is called by <see cref="T:Quantum.CallbackSimulateFinished"/> after completing the simulation of a frame.
            </summary>
            <param name="game">Quantum game</param>
            <param name="frame">Completed frame</param>
        </member>
        <member name="M:Quantum.QuantumCallbacks.OnUnitySceneLoadBegin(Quantum.QuantumGame)">
            <summary>
            Is called by <see cref="T:Quantum.CallbackUnitySceneLoadBegin"/> when a Unity scene is about to be loaded.
            To enable this feature <see cref="F:Quantum.SimulationConfig.AutoLoadSceneFromMap"/> must be toggled on.
            </summary>
            <param name="game">Quantum game</param>
        </member>
        <member name="M:Quantum.QuantumCallbacks.OnUnitySceneLoadDone(Quantum.QuantumGame)">
            <summary>
            Is called by <see cref="T:Quantum.CallbackUnitySceneLoadDone"/> when a Unity scene has been loaded.
            To enable this feature <see cref="F:Quantum.SimulationConfig.AutoLoadSceneFromMap"/> must be toggled on.
            </summary>
            <param name="game">Quantum game</param>
        </member>
        <member name="M:Quantum.QuantumCallbacks.OnUnitySceneUnloadBegin(Quantum.QuantumGame)">
            <summary>
            Is called by <see cref="T:Quantum.CallbackUnitySceneUnloadBegin"/> when a Unity scene is about to be unloaded.
            To enable this feature <see cref="F:Quantum.SimulationConfig.AutoLoadSceneFromMap"/> must be toggled on.
            </summary>
            <param name="game">Quantum game</param>
        </member>
        <member name="M:Quantum.QuantumCallbacks.OnUnitySceneUnloadDone(Quantum.QuantumGame)">
            <summary>
            Is called by <see cref="T:Quantum.CallbackUnitySceneUnloadDone"/> when a Unity scene has been unloaded.
            </summary>
            <param name="game">Quantum game</param>
        </member>
        <member name="M:Quantum.QuantumCallbacks.OnChecksumError(Quantum.QuantumGame,Photon.Deterministic.DeterministicTickChecksumError,Quantum.Frame[])">
            <summary>
            Is called by <see cref="T:Quantum.CallbackChecksumError"/> when a checksum error is detected.
            To enable this feature <see cref="F:Quantum.SimulationConfig.AutoLoadSceneFromMap"/> must be toggled on.
            </summary>
            <param name="game">Quantum game</param>
            <param name="error">Error description</param>
            <param name="frames">List of latest frames</param>
        </member>
        <member name="T:Quantum.QuantumPropertyAttributeProxyAttribute">
            <summary>
            Obsolete attribute for Quantum 2 compatibility. Non functional in Quantum 3.
            </summary>
        </member>
        <member name="P:Quantum.QuantumPropertyAttributeProxyAttribute.Attribute">
            <summary>
            Proxied attribute.
            </summary>
        </member>
        <member name="T:Quantum.EditorRectUtils">
            <summary>
            Unity custom editor GUI utility functions.
            </summary>
        </member>
        <member name="M:Quantum.EditorRectUtils.SetWidth(UnityEngine.Rect,System.Single)">
            <summary>
            Set the width of rect.
            </summary>
            <param name="r">Rect</param>
            <param name="w">New width</param>
            <returns>The new rect</returns>
        </member>
        <member name="M:Quantum.EditorRectUtils.SetWidthHeight(UnityEngine.Rect,UnityEngine.Vector2)">
            <summary>
            Set the height and the width of the rect.
            </summary>
            <param name="r">Rect</param>
            <param name="v">X component is set as width, y component is set as height</param>
            <returns>The new rect</returns>
        </member>
        <member name="M:Quantum.EditorRectUtils.SetWidthHeight(UnityEngine.Rect,System.Single,System.Single)">
            <summary>
            Set the height and the width of the rect.
            </summary>
            <param name="r">Rect</param>
            <param name="w">The new width</param>
            <param name="h">The new height</param>
            <returns>The new rect</returns>
        </member>
        <member name="M:Quantum.EditorRectUtils.AddWidth(UnityEngine.Rect,System.Single)">
            <summary>
            Add a delta to the width of the rect.
            </summary>
            <param name="r">Rect</param>
            <param name="w">Width delta to apply</param>
            <returns>The new rect</returns>
        </member>
        <member name="M:Quantum.EditorRectUtils.AddHeight(UnityEngine.Rect,System.Single)">
            <summary>
            Add a delta to the height of the rect.
            </summary>
            <param name="r">Rect</param>
            <param name="h">Height delta to apply</param>
            <returns>The new rect</returns>
        </member>
        <member name="M:Quantum.EditorRectUtils.SetHeight(UnityEngine.Rect,System.Single)">
            <summary>
            Set the height of a rect.
            </summary>
            <param name="r">Rect</param>
            <param name="h">The new height value</param>
            <returns>The new rect</returns>
        </member>
        <member name="M:Quantum.EditorRectUtils.AddXY(UnityEngine.Rect,UnityEngine.Vector2)">
            <summary>
            Add a delta to the position <see cref="P:UnityEngine.Rect.x"/> and <see cref="P:UnityEngine.Rect.y"/>.
            </summary>
            <param name="r">Rect</param>
            <param name="xy">Position delta to be added</param>
            <returns>The new rect</returns>
        </member>
        <member name="M:Quantum.EditorRectUtils.AddXY(UnityEngine.Rect,System.Single,System.Single)">
            <summary>
            Add position delta to the rect.
            </summary>
            <param name="r">Rect</param>
            <param name="x">Add to <see cref="P:UnityEngine.Rect.x"/></param>
            <param name="y">Add to <see cref="P:UnityEngine.Rect.y"/></param>
            <returns>The new rect</returns>
        </member>
        <member name="M:Quantum.EditorRectUtils.AddX(UnityEngine.Rect,System.Single)">
            <summary>
            Add to the x component of the rect.
            </summary>
            <param name="r">Rect</param>
            <param name="x">Value to add to <see cref="P:UnityEngine.Rect.x"/></param>
            <returns>The new rect</returns>
        </member>
        <member name="M:Quantum.EditorRectUtils.AddY(UnityEngine.Rect,System.Single)">
            <summary>
            Add to the y component of the rect.
            </summary>
            <param name="r">Rect</param>
            <param name="y">Value to add to <see cref="P:UnityEngine.Rect.y"/></param>
            <returns>The new rect</returns>
        </member>
        <member name="M:Quantum.EditorRectUtils.SetY(UnityEngine.Rect,System.Single)">
            <summary>
            Set the y component of the rect.
            </summary>
            <param name="r">Rect</param>
            <param name="y">Value to set as <see cref="P:UnityEngine.Rect.y"/></param>
            <returns>The new rect</returns>
        </member>
        <member name="M:Quantum.EditorRectUtils.SetX(UnityEngine.Rect,System.Single)">
            <summary>
            Set the x component of the rect.
            </summary>
            <param name="r">Rect</param>
            <param name="x">Value to set as <see cref="P:UnityEngine.Rect.x"/></param>
            <returns>The new rect</returns>
        </member>
        <member name="M:Quantum.EditorRectUtils.SetXMin(UnityEngine.Rect,System.Single)">
            <summary>
            Set the xMin component of the rect.
            </summary>
            <param name="r">Rect</param>
            <param name="x">Value to set as <see cref="P:UnityEngine.Rect.xMin"/></param>
            <returns>The new rect</returns>
        </member>
        <member name="M:Quantum.EditorRectUtils.SetXMax(UnityEngine.Rect,System.Single)">
            <summary>
            Set the xMin component of the rect.
            </summary>
            <param name="r">Rect</param>
            <param name="x">Value to set as <see cref="P:UnityEngine.Rect.xMax"/></param>
            <returns>The new rect</returns>
        </member>
        <member name="M:Quantum.EditorRectUtils.SetYMin(UnityEngine.Rect,System.Single)">
            <summary>
            Set the yMin component of the rect.
            </summary>
            <param name="r">Rect</param>
            <param name="y">Value to set as <see cref="P:UnityEngine.Rect.yMin"/></param>
            <returns>The new rect</returns>
        </member>
        <member name="M:Quantum.EditorRectUtils.SetYMax(UnityEngine.Rect,System.Single)">
            <summary>
            The set yMax component of the rect.
            </summary>
            <param name="r">Rect</param>
            <param name="y">Value to set as <see cref="P:UnityEngine.Rect.yMax"/></param>
            <returns>The new rect</returns>
        </member>
        <member name="M:Quantum.EditorRectUtils.AddXMin(UnityEngine.Rect,System.Single)">
            <summary>
            Add to the xMin component of the rect.
            </summary>
            <param name="r">Rect</param>
            <param name="x">Value to add to <see cref="P:UnityEngine.Rect.xMin"/></param>
            <returns>The new rect</returns>
        </member>
        <member name="M:Quantum.EditorRectUtils.AddXMax(UnityEngine.Rect,System.Single)">
            <summary>
            Add to the xMax component of the rect.
            </summary>
            <param name="r">Rect</param>
            <param name="x">Value to add to <see cref="P:UnityEngine.Rect.xMax"/></param>
            <returns>The new rect</returns>
        </member>
        <member name="M:Quantum.EditorRectUtils.AddYMin(UnityEngine.Rect,System.Single)">
            <summary>
            Add to the yMin component of the rect.
            </summary>
            <param name="r">Rect</param>
            <param name="y">Value to add to <see cref="P:UnityEngine.Rect.yMin"/></param>
            <returns>The new rect</returns>
        </member>
        <member name="M:Quantum.EditorRectUtils.AddYMax(UnityEngine.Rect,System.Single)">
            <summary>
            Add to the yMax component of the rect.
            </summary>
            <param name="r">Rect</param>
            <param name="y">The value to add to <see cref="P:UnityEngine.Rect.yMax"/></param>
            <returns>The new rect</returns>
        </member>
        <member name="M:Quantum.EditorRectUtils.Adjust(UnityEngine.Rect,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Add to x,y, width and height component of the rect.
            </summary>
            <param name="r">Rect</param>
            <param name="x">Value to add to <see cref="P:UnityEngine.Rect.x"/></param>
            <param name="y">Value to add to <see cref="P:UnityEngine.Rect.y"/></param>
            <param name="w">Value to add to <see cref="P:UnityEngine.Rect.width"/></param>
            <param name="h">Value to add to <see cref="P:UnityEngine.Rect.height"/></param>
            <returns>The new rect</returns>
        </member>
        <member name="M:Quantum.EditorRectUtils.ToRect(UnityEngine.Vector2,System.Single,System.Single)">
            <summary>
            Create a rect with the given position and size.
            </summary>
            <param name="v">Rect position</param>
            <param name="w">Rect width</param>
            <param name="h">Rect height</param>
            <returns>The new rect</returns>
        </member>
        <member name="M:Quantum.EditorRectUtils.ZeroXY(UnityEngine.Rect)">
            <summary>
            Set the position to zero.
            </summary>
            <param name="r">Rect</param>
            <returns>The new rect</returns>
        </member>
        <member name="M:Quantum.EditorRectUtils.ToVector2(UnityEngine.Rect)">
            <summary>
            Convert the rect width and height to a vector2.
            </summary>
            <param name="r">Rect</param>
            <returns>The width (x) and height (y)</returns>
        </member>
        <member name="M:Quantum.EditorRectUtils.AddLine(UnityEngine.Rect,System.Int32)">
            <summary>
            Increase the rect size by add "editor lines" to the rect.
            </summary>
            <param name="r">Rect</param>
            <param name="count">The number of lines to add</param>
            <returns>The new rect</returns>
        </member>
        <member name="M:Quantum.EditorRectUtils.SetLineHeight(UnityEngine.Rect)">
            <summary>
            The the height of the rect based on the <see cref="P:UnityEditor.EditorGUIUtility.singleLineHeight"/>.
            </summary>
            <param name="r">Rect</param>
            <returns>The new rect</returns>
        </member>
        <member name="T:Quantum.IQuantumUnityDispatcher">
            <summary>
            An interface marking a dispatcher as being a Quantum Unity dispatcher.
            </summary>
        </member>
        <member name="T:Quantum.IQuantumUnityDispatcherExtensions">
            <summary>
            Set of extension methods for <see cref="T:Quantum.IQuantumUnityDispatcher"/>.
            </summary>
        </member>
        <member name="M:Quantum.IQuantumUnityDispatcherExtensions.GetUnityListenerStatus(Quantum.IQuantumUnityDispatcher,System.Object,System.UInt32)">
            <summary>
            Gets the status of a specific listener. Depending on subscription flags and whether the listener is a Unity object,
            the listener activity status is determined. 
            </summary>
            <param name="self"></param>
            <param name="listener"></param>
            <param name="flags"></param>
            <returns></returns>
        </member>
        <member name="T:Quantum.QuantumStaticCapsuleCollider3D">
            <summary>
            The script will create a static 3D capsule collider during Quantum map baking.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticCapsuleCollider3D.SourceCollider">
            <summary>
            Link a Unity capsule collider to copy its size and position of during Quantum map baking.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticCapsuleCollider3D.Radius">
            <summary>
            The radius of the capsule.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticCapsuleCollider3D.Height">
            <summary>
            The height of the capsule.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticCapsuleCollider3D.PositionOffset">
            <summary>
            The position offset added to the <see cref="P:UnityEngine.Transform.position"/> during baking.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticCapsuleCollider3D.RotationOffset">
            <summary>
            The rotation offset added to the <see cref="P:UnityEngine.Transform.rotation"/> during baking.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticCapsuleCollider3D.Settings">
            <summary>
            Additional static collider settings.
            </summary>
        </member>
        <member name="M:Quantum.QuantumStaticCapsuleCollider3D.UpdateFromSourceCollider">
            <summary>
            Copy collider configuration from source collider if exist. 
            </summary>
        </member>
        <member name="M:Quantum.QuantumStaticCapsuleCollider3D.BeforeBake">
            <summary>
            Callback before baking the collider.
            </summary>
        </member>
        <member name="T:Quantum.QuantumSnapshotInterpolationTimer">
            <summary>
            Configuration of the snapshot interpolation mode when selected in <see cref="F:Quantum.QuantumEntityView.InterpolationMode"/>.
            </summary>
        </member>
        <member name="M:Quantum.QuantumSnapshotInterpolationTimer.Advance(System.Int32,System.Single)">
            <summary>
            Advance the interpolation timer.
            </summary>
            <param name="verified">The verified frame number</param>
            <param name="fixedDelta">The fixed delta time</param>
        </member>
        <member name="T:Quantum.QuantumSnapshotInterpolationTimer.QuantumTransformData">
            <summary>
            Data structure to hold transform data on an entity in a buffer.
            </summary>
        </member>
        <member name="F:Quantum.QuantumSnapshotInterpolationTimer.QuantumTransformData.Transform2D">
            <summary>
            The transform 2d component.
            </summary>
        </member>
        <member name="F:Quantum.QuantumSnapshotInterpolationTimer.QuantumTransformData.Transform2DVertical">
            <summary>
            The transform 2d vertical component.
            </summary>
        </member>
        <member name="F:Quantum.QuantumSnapshotInterpolationTimer.QuantumTransformData.Transform3D">
            <summary>
            The transform 3d component.
            </summary>
        </member>
        <member name="F:Quantum.QuantumSnapshotInterpolationTimer.QuantumTransformData.Has2DVertical">
            <summary>
            Has 2d vertical component.
            </summary>
        </member>
        <member name="F:Quantum.QuantumSnapshotInterpolationTimer.QuantumTransformData.IsValid">
            <summary>
            Has valid and useable data.
            </summary>
        </member>
        <member name="T:Quantum.QuantumSnapshotInterpolationTimer.InterpolationBuffer`1">
            <summary>
            Simple ring buffer to store transform data.
            </summary>
            <typeparam name="T">Type of data to store</typeparam>
        </member>
        <member name="M:Quantum.QuantumSnapshotInterpolationTimer.InterpolationBuffer`1.#ctor(System.Int32)">
            <summary>
            Create the collection with a given capacity.
            </summary>
            <param name="size">Capacity</param>
        </member>
        <member name="M:Quantum.QuantumSnapshotInterpolationTimer.InterpolationBuffer`1.Reset">
            <summary>
            Reset the collection.
            </summary>
        </member>
        <member name="M:Quantum.QuantumSnapshotInterpolationTimer.InterpolationBuffer`1.Add(`0,System.Int32)">
            <summary>
            Add a new item to the collection.
            </summary>
            <param name="t">The object</param>
            <param name="tick">The frame number</param>
        </member>
        <member name="M:Quantum.QuantumSnapshotInterpolationTimer.InterpolationBuffer`1.TryGet(`0@,System.Int32)">
            <summary>
            Try get a value from the collection for the given frame number.
            </summary>
            <param name="t">Resulting object</param>
            <param name="tick">Requested frame number</param>
            <returns>True if an object with that frame number was found</returns>
        </member>
        <member name="T:Quantum.QuantumStaticBoxCollider2D">
            <summary>
            The script will create a static 2D Quantum box collider during map baking.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticBoxCollider2D.SourceCollider">
            <summary>
            Link a Unity box collider to copy its size and position of during Quantum map baking.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticBoxCollider2D.Size">
            <summary>
            Set the size of the box collider.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticBoxCollider2D.PositionOffset">
            <summary>
            The position offset added to the <see cref="P:UnityEngine.Transform.position"/> during baking.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticBoxCollider2D.RotationOffset">
            <summary>
            The rotation offset added to the <see cref="P:UnityEngine.Transform.rotation"/> during baking.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticBoxCollider2D.Height">
            <summary>
            Set an optional pseudo height of the collider.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticBoxCollider2D.Settings">
            <summary>
            Additional static collider settings.
            </summary>
        </member>
        <member name="M:Quantum.QuantumStaticBoxCollider2D.UpdateFromSourceCollider">
            <summary>
            Copy collider configuration from source collider if exist. 
            </summary>
        </member>
        <member name="M:Quantum.QuantumStaticBoxCollider2D.BeforeBake">
            <summary>
            Callback before baking the collider.
            </summary>
        </member>
        <member name="T:Quantum.QuantumAddRuntimePlayers">
            <summary>
              Similar to the CustomCallback script and the <see cref="T:Quantum.QuantumRunnerLocalDebug" /> this script will add all players
              inside the <see cref="T:Quantum.RuntimePlayer" /> list as local players to Quantum during the game start. The script must <see cref="M:Quantum.QuantumAddRuntimePlayers.Awake" /> before starting the
              game and it works for local debug and online matches via a menu.
              Remove this script from your scene when the players are only added inside the menu classes (use the Player list in
              <see cref="T:Quantum.QuantumRunnerLocalDebug" />  to start game scenes directly).
            </summary>
        </member>
        <member name="F:Quantum.QuantumAddRuntimePlayers.Players">
            <summary>
            These RuntimePlayer represent the players that will be added on game start.
            </summary>
        </member>
        <member name="M:Quantum.QuantumAddRuntimePlayers.Awake">
            <summary>
            Unity Awake event, used to subscribe to the game start event of <see cref="P:Quantum.QuantumRunner.Default"/>.
            </summary>
        </member>
        <member name="M:Quantum.QuantumAddRuntimePlayers.OnGameStarted(Quantum.QuantumGame,System.Boolean)">
            <summary>
            Add all players to the game.
            </summary>
            <param name="game">Quantum game</param>
            <param name="isResync">IsResync indicates the client is late-joining or reconnecting to a Quantum game</param>
        </member>
        <member name="T:Quantum.FloatMinMax">
            <summary>
            A struct that holds min and max float values and comes with a few inspector tools
            </summary>
        </member>
        <member name="F:Quantum.FloatMinMax.Min">
            <summary>
            Min value.
            </summary>
        </member>
        <member name="F:Quantum.FloatMinMax.Max">
            <summary>
            Max value.
            </summary>
        </member>
        <member name="M:Quantum.FloatMinMax.#ctor(System.Single,System.Single)">
            <summary>
            Create a new instance of FloatMinMax.
            </summary>
            <param name="min">Min</param>
            <param name="max">Max</param>
        </member>
        <member name="T:Quantum.MinMaxSliderAttribute">
            <summary>
            An attribute to display a slider in the Unity inspector between a min and max value.
            </summary>
        </member>
        <member name="F:Quantum.MinMaxSliderAttribute.Min">
            <summary>
            Min value.
            </summary>
        </member>
        <member name="F:Quantum.MinMaxSliderAttribute.Max">
            <summary>
            Max value.
            </summary>
        </member>
        <member name="M:Quantum.MinMaxSliderAttribute.#ctor">
            <summary>
            Create a slider between 0 and 1.
            </summary>
        </member>
        <member name="M:Quantum.MinMaxSliderAttribute.#ctor(System.Single,System.Single)">
            <summary>
            Create a slider between min and max.
            </summary>
            <param name="min">Min</param>
            <param name="max">Max</param>
        </member>
        <member name="T:Quantum.QuantumFrameDifferGUI">
            <summary>
            The actual GUI to render the frame dumps differences of multiple dumps send by different clients.
            Uses Unity Immediate Mode GUI.
            </summary>
        </member>
        <member name="F:Quantum.QuantumFrameDifferGUI.ReferenceActorId">
            <summary>
            The actor id to use as a reference state when comparing differences.
            </summary>
        </member>
        <member name="F:Quantum.QuantumFrameDifferGUI._hidden">
            <summary>
            True if the GUI is not rendered.
            </summary>
        </member>
        <member name="M:Quantum.QuantumFrameDifferGUI.#ctor(Quantum.QuantumFrameDifferGUI.FrameDifferState)">
            <summary>
            Create a new GUI frame differ instance using the given state.
            </summary>
            <param name="state"></param>
        </member>
        <member name="P:Quantum.QuantumFrameDifferGUI.State">
            <summary>
            Get or set the state of the frame differ.
            </summary>
        </member>
        <member name="P:Quantum.QuantumFrameDifferGUI.IsEditor">
            <summary>
            Returns true or derived classes if the GUI is running inside the Unity Editor.
            </summary>
        </member>
        <member name="P:Quantum.QuantumFrameDifferGUI.TextLineHeight">
            <summary>
            Returns the text line height. Default is 16.
            Can be customized in derived classes.
            </summary>
        </member>
        <member name="P:Quantum.QuantumFrameDifferGUI.DiffBackground">
            <summary>
            Returns the background style.
            Can be customized in derived classes.
            </summary>
        </member>
        <member name="P:Quantum.QuantumFrameDifferGUI.DiffHeader">
            <summary>
            Returns the header style.
            Can be customized in derived classes.
            </summary>
        </member>
        <member name="P:Quantum.QuantumFrameDifferGUI.DiffHeaderError">
            <summary>
            Returns the error header style.
            Can be customized in derived classes.
            </summary>
        </member>
        <member name="P:Quantum.QuantumFrameDifferGUI.DiffLineOverlay">
            <summary>
            Returns the line overlay style.
            Can be customized in derived classes.
            </summary>
        </member>
        <member name="P:Quantum.QuantumFrameDifferGUI.MiniButton">
            <summary>
            Returns the button style.
            Can be customized in derived classes.
            </summary>
        </member>
        <member name="P:Quantum.QuantumFrameDifferGUI.TextLabel">
            <summary>
            Returns the text label style.
            Can be customized in derived classes.
            </summary>
        </member>
        <member name="P:Quantum.QuantumFrameDifferGUI.BoldLabel">
            <summary>
            Returns the bold label style.
            Can be customized in derived classes.
            </summary>
        </member>
        <member name="P:Quantum.QuantumFrameDifferGUI.MiniButtonLeft">
            <summary>
            Returns the left button style.
            </summary>
        </member>
        <member name="P:Quantum.QuantumFrameDifferGUI.MiniButtonRight">
            <summary>
            Returns the right button style.
            </summary>
        </member>
        <member name="P:Quantum.QuantumFrameDifferGUI.Position">
            <summary>
            Returns the position of the screen/window.
            </summary>
        </member>
        <member name="P:Quantum.QuantumFrameDifferGUI.ScrollWidth">
            <summary>
            Returns the scroll width. Default is 16.
            </summary>
        </member>
        <member name="M:Quantum.QuantumFrameDifferGUI.Repaint">
            <summary>
            Toggles a windows repaint.
            </summary>
        </member>
        <member name="M:Quantum.QuantumFrameDifferGUI.DrawHeader">
            <summary>
            Draws the header of the GUI.
            </summary>
        </member>
        <member name="M:Quantum.QuantumFrameDifferGUI.Show">
            <summary>
            Toggles the _hidden flag.
            </summary>
        </member>
        <member name="M:Quantum.QuantumFrameDifferGUI.OnGUI">
            <summary>
            Should be invoked from Unity OnGUI method to draw the GUI.
            </summary>
        </member>
        <member name="T:Quantum.QuantumFrameDifferGUI.FrameDifferState">
            <summary>
            The state saves multiple frame dumps.
            </summary>
        </member>
        <member name="M:Quantum.QuantumFrameDifferGUI.FrameDifferState.Clear">
            <summary>
            Clear the sate.
            </summary>
        </member>
        <member name="M:Quantum.QuantumFrameDifferGUI.FrameDifferState.AddEntry(System.String,System.Int32,System.Int32,System.String,System.String)">
            <summary>
            Add an entry (a frame dump) to the frame state.
            </summary>
            <param name="runnerId">The runner id</param>
            <param name="actorId">The actor id</param>
            <param name="frameNumber">The frame number</param>
            <param name="frameDump">The frame dump as text</param>
            <param name="actorName">The actor name if available</param>
        </member>
        <member name="M:Quantum.QuantumFrameDifferGUI.FrameDifferState.OnAfterDeserialize">
            <summary>
            Is called after the state was loaded from a file to decompress the frame dumps.
            </summary>
        </member>
        <member name="M:Quantum.QuantumFrameDifferGUI.FrameDifferState.OnBeforeSerialize">
            <summary>
            Is called before the state is saved to a file to compress the frame dumps.
            </summary>
        </member>
        <member name="P:Quantum.QuantumFrameDifferGUI.FrameDifferState.RunnerIds">
            <summary>
            Return all runner ids.
            </summary>
        </member>
        <member name="T:Quantum.QuantumStaticSphereCollider3D">
            <summary>
            The script will create a static sphere collider during Quantum map baking.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticSphereCollider3D.SourceCollider">
            <summary>
            Link a Unity sphere collider to copy its size and position of during Quantum map baking.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticSphereCollider3D.Radius">
            <summary>
            The radius of the sphere.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticSphereCollider3D.PositionOffset">
            <summary>
            The position offset added to the <see cref="P:UnityEngine.Transform.position"/> during baking.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticSphereCollider3D.Settings">
            <summary>
            Additional static collider settings.
            </summary>
        </member>
        <member name="M:Quantum.QuantumStaticSphereCollider3D.UpdateFromSourceCollider">
            <summary>
            Copy collider configuration from source collider if exist. 
            </summary>
        </member>
        <member name="M:Quantum.QuantumStaticSphereCollider3D.BeforeBake">
            <summary>
            Callback before baking the collider.
            </summary>
        </member>
        <member name="T:Quantum.MapDataBakerCallbackAttribute">
            <summary>
            Add this attribute to implementations of <see cref="T:Quantum.MapDataBakerCallback"/> to control the order 
            in which the callbacks are finally executed. Works across different assemblies.
            </summary>
        </member>
        <member name="P:Quantum.MapDataBakerCallbackAttribute.InvokeOrder">
            <summary>
            The invoke order, higher means called earlier.
            </summary>
        </member>
        <member name="M:Quantum.MapDataBakerCallbackAttribute.#ctor(System.Int32)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="T:Quantum.ProgressBar">
            <summary>
            A progress bar implementation used by the navmesh importing.
            The progress bar is only showed when the LogLevel is set to Debug.
            </summary>
        </member>
        <member name="M:Quantum.ProgressBar.#ctor(System.String,System.Boolean,System.Boolean)">
            <summary>
            Create a progress bar instance.
            </summary>
            <param name="title">The title</param>
            <param name="isCancelable">Is the process cancelable</param>
            <param name="logStopwatch">Should the timer result be logged out periodically</param>
        </member>
        <member name="P:Quantum.ProgressBar.Info">
            <summary>
            Set the new sub headline for the progress bar and reset the progress.
            </summary>
        </member>
        <member name="P:Quantum.ProgressBar.Progress">
            <summary>
            Set the progress of the current task.
            </summary>
        </member>
        <member name="M:Quantum.ProgressBar.SetInfo(System.String)">
            <summary>
            Uses <see cref="P:Quantum.ProgressBar.Info"/> property.
            </summary>
            <param name="value">Into value</param>
        </member>
        <member name="M:Quantum.ProgressBar.SetProgress(System.Single)">
            <summary>
            Uses <see cref="P:Quantum.ProgressBar.Progress"/> property."/>
            </summary>
            <param name="value">Progress value between 0..1</param>
        </member>
        <member name="M:Quantum.ProgressBar.Dispose">
            <summary>
            Dispose, hide the progress bar UI.
            </summary>
        </member>
        <member name="T:Quantum.QuantumCallbackHandler_LegacyQuantumCallback">
            <summary>
            A handler object that subscribes to Quantum callbacks to call legacy QuantumCallbacks in on Unity game objects.
            </summary>
        </member>
        <member name="M:Quantum.QuantumCallbackHandler_LegacyQuantumCallback.Initialize">
            <summary>
            Init and subscribe to Quantum callbacks.
            </summary>
            <returns>An object to dispose to unsubscribe from the callbacks</returns>
        </member>
        <member name="T:Quantum.QuantumEntityPrototype">
            <summary>
            Entity Prototypes are similar to blueprints or prefabs, they carry information
            to create a Quantum Entity with its components and initialized them with pre-configured data.
            </summary>
        </member>
        <member name="T:Quantum.QuantumEntityPrototype.Transform2DVerticalInfo">
            <summary>
            Prototype settings for the <see cref="F:Quantum.QuantumEntityPrototype.Transform2DVertical"/> component.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.Transform2DVerticalInfo.IsEnabled">
            <summary>
            Is the prototype toggled on.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.Transform2DVerticalInfo.Height">
            <summary>
            The height of the component.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.Transform2DVerticalInfo.PositionOffset">
            <summary>
            The current vertical position of offset of the component.
            </summary>
        </member>
        <member name="T:Quantum.QuantumEntityPrototype.PhysicsColliderGeneric">
            <summary>
            A all-purpose physics collider info.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.PhysicsColliderGeneric.IsTrigger">
            <summary>
            Is the collider a trigger.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.PhysicsColliderGeneric.Material">
            <summary>
            The physics material to be set on the collider component.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.PhysicsColliderGeneric.SourceCollider">
            <summary>
            The source collider to be used for the shape.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.PhysicsColliderGeneric.IsEnabled">
            <summary>
            Is this prototype toggled on.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.PhysicsColliderGeneric.Shape2D">
            <summary>
            The 2D shape.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.PhysicsColliderGeneric.Shape3D">
            <summary>
            The 3d shape.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.PhysicsColliderGeneric.LayerSource">
            <summary>
            The source for the layer.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.PhysicsColliderGeneric.Layer">
            <summary>
            The initial physics layer.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.PhysicsColliderGeneric.CallbackFlags">
            <summary>
            The callback flags.
            </summary>
        </member>
        <member name="T:Quantum.QuantumEntityPrototype.PhysicsBodyGeneric">
            <summary>
            The all-purpose physics body info.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.PhysicsBodyGeneric.IsEnabled">
            <summary>
            Is the prototype toggled on.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.PhysicsBodyGeneric.Config2D">
            <summary>
            The 2d configuration flags.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.PhysicsBodyGeneric.Config3D">
            <summary>
            The 3d configuration flags.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.PhysicsBodyGeneric.RotationFreeze">
            <summary>
            The freeze rotation configuration.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.PhysicsBodyGeneric.Mass">
            <summary>
            The body mass.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.PhysicsBodyGeneric.Drag">
            <summary>
            The body drag.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.PhysicsBodyGeneric.AngularDrag">
            <summary>
            The body angular drag.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.PhysicsBodyGeneric.CenterOfMass2D">
            <summary>
            The center of mass in 2d.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.PhysicsBodyGeneric.CenterOfMass3D">
            <summary>
            The center of mass in 3d.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.PhysicsBodyGeneric.GravityScale">
            <summary>
            The gravity scale.
            </summary>
        </member>
        <member name="T:Quantum.QuantumEntityPrototype.NavMeshPathfinderInfo">
            <summary>
            The navmesh pathfinder info.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.NavMeshPathfinderInfo.IsEnabled">
            <summary>
            Is this prototype enabled.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.NavMeshPathfinderInfo.NavMeshAgentConfig">
            <summary>
            The navmesh agent configuration asset reference.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.NavMeshPathfinderInfo.InitialTarget">
            <summary>
            The initial target to be set when the entity is spawned.
            </summary>
        </member>
        <member name="T:Quantum.QuantumEntityPrototype.InitialNavMeshTargetInfo">
            <summary>
            The initial navmesh target info.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.InitialNavMeshTargetInfo.IsEnabled">
            <summary>
            Is this prototype info enabled.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.InitialNavMeshTargetInfo.Target">
            <summary>
            The target transform, the transform position is saved during baking.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.InitialNavMeshTargetInfo.Position">
            <summary>
            The world position of the target.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.InitialNavMeshTargetInfo.NavMesh">
            <summary>
            The target navmesh.
            </summary>
        </member>
        <member name="T:Quantum.QuantumEntityPrototype.NavMeshSpec">
            <summary>
            Navmesh specification for prototypes.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.NavMeshSpec.Reference">
            <summary>
            Reference to a navmesh unity component.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.NavMeshSpec.Asset">
            <summary>
            Reference to a navmesh asset.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.NavMeshSpec.Name">
            <summary>
            The navmesh name.
            </summary>
        </member>
        <member name="T:Quantum.QuantumEntityPrototype.NavMeshSteeringAgentInfo">
            <summary>
            Navmesh steering agent info.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.NavMeshSteeringAgentInfo.IsEnabled">
            <summary>
            Is this prototype toggled on.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.NavMeshSteeringAgentInfo.MaxSpeed">
            <summary>
            Toggle on to set the initial max speed of the agent.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.NavMeshSteeringAgentInfo.Acceleration">
            <summary>
            Toggle on to set the initial acceleration of the agent.
            </summary>
        </member>
        <member name="T:Quantum.QuantumEntityPrototype.OverrideFP">
            <summary>
            Data object to store a bool and a fixed point to represent overriding default values.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.OverrideFP.IsEnabled">
            <summary>
            Is this info object toggled on.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.OverrideFP.Value">
            <summary>
            Value.
            </summary>
        </member>
        <member name="T:Quantum.QuantumEntityPrototype.NavMeshAvoidanceAgentInfo">
            <summary>
            Navmesh avoidance agent info.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.NavMeshAvoidanceAgentInfo.IsEnabled">
            <summary>
            Is this prototype toggled on.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.TransformMode">
            <summary>
            The prototype transform mode.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.Transform2DVertical">
            <summary>
            The transform 2d info.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.PhysicsCollider">
            <summary>
            The physics collider info.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.PhysicsBody">
            <summary>
            The physics body info.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.NavMeshPathfinder">
            <summary>
            The pathfinder agent info.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.NavMeshSteeringAgent">
            <summary>
            The navmesh steering agent info.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.NavMeshAvoidanceAgent">
            <summary>
            The navmesh avoidance agent info.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityPrototype.View">
            <summary>
            The entity view asset reference.
            </summary>
        </member>
        <member name="M:Quantum.QuantumEntityPrototype.PreSerialize">
            <summary>
            Post process the prototype based on configuration settings.
            </summary>
        </member>
        <member name="M:Quantum.QuantumEntityPrototype.SerializeImplicitComponents(System.Collections.Generic.List{Quantum.ComponentPrototype},Quantum.QuantumEntityView@)">
            <summary>
            Serializes known prototypes.
            </summary>
            <param name="result">Resulting component prototypes</param>
            <param name="selfView">Resulting entity view</param>
        </member>
        <member name="M:Quantum.QuantumEntityPrototype.CheckComponentDuplicates(System.Action{System.String})">
            <summary>
            Validation step.
            </summary>
            <param name="duplicateCallback">Action to call on duplicate entries</param>
        </member>
        <member name="M:Quantum.QuantumEntityPrototype.CheckComponentDuplicates(System.Action{System.Type,System.Collections.Generic.List{UnityEngine.Component}})">
            <summary>
            Validation step.
            </summary>
            <param name="duplicateCallback">Dictionary of duplication detection callbacks</param>
        </member>
        <member name="M:Quantum.QuantumEntityPrototype.InitializeAssetObject(Quantum.EntityPrototype,Quantum.EntityView)">
            <summary>
            Initialize the prototype after being loaded.
            </summary>
            <param name="assetObject">Entity prototype asset object</param>
            <param name="selfViewAsset">Associated view asset</param>
        </member>
        <member name="T:Quantum.QuantumMultiClientPlayerView">
            <summary>
            The multi client UI view of one player.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMultiClientPlayerView.Label">
            <summary>
            The name of the player.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMultiClientPlayerView.ConnectingLabel">
            <summary>
            The "is connecting" label.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMultiClientPlayerView.Input">
            <summary>
            The button to toggle the input.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMultiClientPlayerView.View">
            <summary>
            The button to toggle the EntityViewUpdater.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMultiClientPlayerView.Gizmos">
            <summary>
            The button to toggle the game gizmo rendering.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMultiClientPlayerView.AddPlayer">
            <summary>
            The button to add a player using the same client.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMultiClientPlayerView.Quit">
            <summary>
            The button to quit the player.
            </summary>
        </member>
        <member name="M:Quantum.QuantumMultiClientPlayerView.SetLoading">
            <summary>
            Configure the view for loading status.
            </summary>
        </member>
        <member name="M:Quantum.QuantumMultiClientPlayerView.SetRunning(System.Boolean)">
            <summary>
            Configure the view for running status.
            </summary>
            <param name="isAddPlayerEnabled">It <see langword="true"/> the add player button is enabled.</param>
        </member>
        <member name="T:Quantum.QuantumMapBakeAssemblyAttribute">
            <summary>
            This assembly attribute needs to be set inside custom assemblies that required 
            static edit mode callbacks from the <see cref="T:Quantum.MapDataBakerCallback"/> class.
            [assembly: QuantumMapBakeAssembly]
            </summary>
        </member>
        <member name="F:Quantum.QuantumMapBakeAssemblyAttribute.Ignore">
            <summary>
            Enabled to explicitly ignore this assembly when searching for callback implementations.
            </summary>
        </member>
        <member name="T:Quantum.MapDataBakerCallback">
            <summary>
            Derive from the class to receive callbacks during Quantum map baking.
            Add the <see cref="T:Quantum.QuantumMapBakeAssemblyAttribute"/> assembly attribute when the implementation
            is located in different assemblies.
            </summary>
        </member>
        <member name="M:Quantum.MapDataBakerCallback.OnBeforeBake(Quantum.QuantumMapData)">
            <summary>
            Is called in the beginning of map baking.
            </summary>
            <param name="data">The MapData object that is currently baked.</param>
        </member>
        <member name="M:Quantum.MapDataBakerCallback.OnBeforeBake(Quantum.QuantumMapData,Quantum.QuantumMapDataBaker.BuildTrigger,Quantum.QuantumMapDataBakeFlags)">
            <summary>
            Is called in the beginning of map baking similar to <see cref="M:Quantum.MapDataBakerCallback.OnBeforeBake(Quantum.QuantumMapData)"/>
            with a different signature.
            </summary>
            <param name="data">Map data</param>
            <param name="buildTrigger">Originating build trigger</param>
            <param name="bakeFlags">Use build flags</param>
        </member>
        <member name="M:Quantum.MapDataBakerCallback.OnBake(Quantum.QuantumMapData)">
            <summary>
            Is called after map baking when colliders and prototypes have been baked and before navmesh baking.
            </summary>
            <param name="data"></param>
            
        </member>
        <member name="M:Quantum.MapDataBakerCallback.OnBeforeBakeNavMesh(Quantum.QuantumMapData)">
            <summary>
            Is called before any navmeshes are generated or any bake data is collected.
            </summary>
            <param name="data">The MapData object that is currently baked.</param>
        </member>
        <member name="M:Quantum.MapDataBakerCallback.OnCollectNavMeshBakeData(Quantum.QuantumMapData,System.Collections.Generic.List{Quantum.NavMeshBakeData})">
            <summary>
            Is called during navmesh baking with the current list of bake data retreived from Unity navmeshes flagged for Quantum
            navmesh baking.
            Add new BakeData objects to the navMeshBakeData list.
            </summary>
            <param name="data">The MapData object that is currently baked.</param>
            <param name="navMeshBakeData">Current list of bake data to be baked</param>
        </member>
        <member name="M:Quantum.MapDataBakerCallback.OnCollectNavMeshes(Quantum.QuantumMapData,System.Collections.Generic.List{Quantum.NavMesh})">
            <summary>
            Is called after navmesh baking before serializing them to assets.
            Add new NavMesh objects the navmeshes list.
            </summary>
            <param name="data">The MapData object that is currently baked.</param>
            <param name="navmeshes">Current list of baked navmeshes to be saved to assets.</param>
        </member>
        <member name="M:Quantum.MapDataBakerCallback.OnBakeNavMesh(Quantum.QuantumMapData)">
            <summary>
            Is called after the navmesh generation has been completed.
            Navmeshes assets references are stored in data.Asset.Settings.NavMeshLinks.
            </summary>
            <param name="data">The MapData object that is currently baked.</param>
        </member>
        <member name="T:Quantum.QuantumMapDataBakeFlags">
            <summary>
            The QuantumEditorAutoBaker script uses this enumeration to configure what steps to build
            on different automatic build triggers.
            </summary>
        </member>
        <member name="F:Quantum.QuantumMapDataBakeFlags.None">
            <summary>
            Build nothing
            </summary>
        </member>
        <member name="F:Quantum.QuantumMapDataBakeFlags.BakeMapData">
            <summary>
            Bake <see cref="F:Quantum.QuantumMapDataBakeFlags.BakeMapPrototypes"/> and <see cref="F:Quantum.QuantumMapDataBakeFlags.BakeMapColliders"/>
            </summary>
        </member>
        <member name="F:Quantum.QuantumMapDataBakeFlags.BakeMapPrototypes">
            <summary>
            Bake map prototypes
            </summary>
        </member>
        <member name="F:Quantum.QuantumMapDataBakeFlags.BakeMapColliders">
            <summary>
            Bake map colliders
            </summary>
        </member>
        <member name="F:Quantum.QuantumMapDataBakeFlags.BakeUnityNavMesh">
            <summary>
            Bake the Unity navmesh
            </summary>
        </member>
        <member name="F:Quantum.QuantumMapDataBakeFlags.ImportUnityNavMesh">
            <summary>
            Import the Unity navmesh into an intermediate navmesh data structure
            </summary>
        </member>
        <member name="F:Quantum.QuantumMapDataBakeFlags.BakeNavMesh">
            <summary>
            Bake the Quantum navmesh using the intermediate navmesh data structure
            </summary>
        </member>
        <member name="F:Quantum.QuantumMapDataBakeFlags.ClearUnityNavMesh">
            <summary>
            Clear and reset the Unity navmesh
            </summary>
        </member>
        <member name="F:Quantum.QuantumMapDataBakeFlags.GenerateAssetDB">
            <summary>
            Generate the Quantum Unity Asset DB
            </summary>
        </member>
        <member name="F:Quantum.QuantumMapDataBakeFlags.SaveUnityAssets">
            <summary>
            Save Unity assets during the baking process. Results in calling AssetDatabase.SaveAssets().
            </summary>
        </member>
        <member name="T:Quantum.QuantumStaticCircleCollider2D">
            <summary>
            The script will create a static 2D circle collider during Quantum map baking.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticCircleCollider2D.SourceCollider">
            <summary>
            Link a Unity circle collider to copy its size and position of during Quantum map baking.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticCircleCollider2D.Radius">
            <summary>
            The radius of the circle.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticCircleCollider2D.PositionOffset">
            <summary>
            The position offset added to the <see cref="P:UnityEngine.Transform.position"/> during baking.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticCircleCollider2D.Height">
            <summary>
            The optional 2D pseudo height of the collider.
            </summary>
        </member>
        <member name="F:Quantum.QuantumStaticCircleCollider2D.Settings">
            <summary>
            Additional static collider settings.
            </summary>
        </member>
        <member name="M:Quantum.QuantumStaticCircleCollider2D.UpdateFromSourceCollider">
            <summary>
            Copy collider configuration from source collider if exist. 
            </summary>
        </member>
        <member name="M:Quantum.QuantumStaticCircleCollider2D.BeforeBake">
            <summary>
            Callback before baking the collider.
            </summary>
        </member>
        <member name="T:Quantum.QuantumEntityViewUpdater">
            <summary>
            The Entity View Updater is essential. An instance needs to be present to create Entity Views as the 
            simulation view representations based on the <see cref="T:Quantum.EntityView"/> components.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityViewUpdater.ViewParentTransform">
            <summary>
            "Optionally provide a transform that all entity views will be parented under."
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityViewUpdater.AutoFindMapData">
            <summary>
            Disable you don't intend to use MapData component.
            </summary>
        </member>
        <member name="F:Quantum.QuantumEntityViewUpdater.SnapshotInterpolation">
            <summary>
            Configuration of the snapshot interpolation mode of EntityViews.
            </summary>
        </member>
        <member name="P:Quantum.QuantumEntityViewUpdater.MapData">
            <summary>
            Provides access to MapData when deriving from this class for example.
            </summary>
        </member>
        <member name="P:Quantum.QuantumEntityViewUpdater.ActiveEntities">
            <summary>
            Provides access to the active entities. 
            </summary>
        </member>
        <member name="P:Quantum.QuantumEntityViewUpdater.RemoveEntities">
            <summary>
            Privates access to the entities that should be removed.
            </summary>
        </member>
        <member name="P:Quantum.QuantumEntityViewUpdater.ActiveViews">
            <summary>
            Provides access to the active views.
            </summary>
        </member>
        <member name="P:Quantum.QuantumEntityViewUpdater.Teleport">
            <summary>
            Returns <see langword="true"/> when the entities are marked to teleport next update. Set by <see cref="M:Quantum.QuantumEntityViewUpdater.TeleportAllEntities"/>.
            </summary>
        </member>
        <member name="P:Quantum.QuantumEntityViewUpdater.ObservedGame">
            <summary>
            Returns the currently observed game.
            </summary>
        </member>
        <member name="P:Quantum.QuantumEntityViewUpdater.Pool">
            <summary>
            Get or set the EntityViewPool. If not set, the EntityViewUpdater will use the first found pool in the hierarchy.
            </summary>
        </member>
        <member name="P:Quantum.QuantumEntityViewUpdater.Context">
            <summary>
            Access all view contexts that could be loaded in the scene as children of the EntityViewUpdater.
            </summary>
        </member>
        <member name="M:Quantum.QuantumEntityViewUpdater.GetPrefab(Quantum.EntityRef)">
            <summary>
            Obsolete: Use GetView instead
            </summary>
        </member>
        <member name="M:Quantum.QuantumEntityViewUpdater.GetView(Quantum.EntityRef)">
            <summary>
            Try to get the view instance for the given Quantum entity reference.
            </summary>
            <param name="entityRef"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.QuantumEntityViewUpdater.SetTeleportOnce">
            <summary>
            Obsolete: Use TeleportAllEntities() instead.
            </summary>
        </member>
        <member name="M:Quantum.QuantumEntityViewUpdater.TeleportAllEntities">
            <summary>
            Set all entity views to teleport on the next update.
            </summary>
        </member>
        <member name="M:Quantum.QuantumEntityViewUpdater.SetCurrentGame(Quantum.QuantumGame)">
            <summary>
            Set the current observed game.
            </summary>
        </member>
        <member name="M:Quantum.QuantumEntityViewUpdater.Awake">
            <summary>
            Unity Awake() callback, register callbacks and load view contexts.
            </summary>
        </member>
        <member name="M:Quantum.QuantumEntityViewUpdater.AddViewComponent(Quantum.IQuantumViewComponent)">
            <summary>
            Attach a non-entity view component that is then updated by the EntityViewUpdater.
            The <see cref="M:Quantum.QuantumViewComponent`1.OnActivate(Quantum.Frame)"/> will be deferred until the next view update.
            <para>Does not add the view component if it already was added (e.g. <see cref="P:Quantum.IQuantumViewComponent.IsInitialized"/> returns <see langword="true"/>).</para>
            </summary>
            <param name="viewComponent">View component instance</param>
        </member>
        <member name="M:Quantum.QuantumEntityViewUpdater.RemoveViewComponent(Quantum.IQuantumViewComponent)">
            <summary>
            Remove a view component from being updated by the EntityViewUpdater.
            The removing of the view component is being deferred until the next late update.
            </summary>
            <param name="viewComponent">View component instance to remove</param>
        </member>
        <member name="M:Quantum.QuantumEntityViewUpdater.DestroyEntityView(Quantum.QuantumGame,Quantum.QuantumEntityView)">
            <summary>
            Destroys the entity view instance and removes it from the active views list.
            <para>Can be overwritten in derived class.</para>
            </summary>
            <param name="game">The game reference the entity belongs to.</param>
            <param name="view">The entity view object.</param>
        </member>
        <member name="M:Quantum.QuantumEntityViewUpdater.CreateEntityViewInstance(Quantum.EntityView,System.Nullable{UnityEngine.Vector3},System.Nullable{UnityEngine.Quaternion})">
            <summary>
            Creates a new entity view instance.
            <para>Can be overwritten in derived class.</para>
            </summary>
            <param name="asset">View asset.</param>
            <param name="position">World position.</param>
            <param name="rotation">Initial rotation.</param>
            <returns>A new Quantum entity view instance.</returns>
        </member>
        <member name="M:Quantum.QuantumEntityViewUpdater.DestroyEntityViewInstance(Quantum.QuantumEntityView)">
            <summary>
            Destroys an entity view.
            <para>Can be overwritten in derived class.</para>
            </summary>
            <param name="instance">Instance to destroy.</param>
        </member>
        <member name="M:Quantum.QuantumEntityViewUpdater.ActivateMapEntityInstance(Quantum.QuantumEntityView,System.Nullable{UnityEngine.Vector3},System.Nullable{UnityEngine.Quaternion})">
            <summary>
            Activates a map entity instance.
            <para>Can be overwritten in derived class.</para>
            </summary>
        </member>
        <member name="M:Quantum.QuantumEntityViewUpdater.DisableMapEntityInstance(Quantum.QuantumEntityView)">
            <summary>
            Disabled a map entity instance.
            <para>Can be overwritten in derived class.</para>
            </summary>
        </member>
        <member name="M:Quantum.QuantumEntityViewUpdater.LoadMissingPrefab(Quantum.EntityView)">
            <summary>
            Is triggered when <see cref="F:Quantum.EntityView.Prefab"/> is null and expects to be set after this callback.
            <para>Can be overwritten in derived class.</para>
            </summary>
            <param name="viewAsset">View asset to load.</param>
        </member>
        <member name="T:Quantum.QuantumRunnerRegistry">
            <summary>
            A registry to keep track of all active Quantum runners.
            </summary>
        </member>
        <member name="P:Quantum.QuantumRunnerRegistry.Global">
            <summary>
            Singleton instance of the registry. Creates a new instance if none exists.
            </summary>
        </member>
        <member name="P:Quantum.QuantumRunnerRegistry.Default">
            <summary>
            The default runner.
            <para>If multiple runners exists it will return the first one.</para>
            </summary>
        </member>
        <member name="P:Quantum.QuantumRunnerRegistry.ActiveRunners">
            <summary>
            Returns all runners.
            </summary>
        </member>
        <member name="M:Quantum.QuantumRunnerRegistry.ShutdownAll">
            <summary>
            Calls <see cref="M:Quantum.SessionRunner.Shutdown(Quantum.ShutdownCause)"/> on all runners.
            </summary>
        </member>
        <member name="M:Quantum.QuantumRunnerRegistry.ShutdownAllAsync">
            <summary>
            Calls <see cref="M:Quantum.SessionRunner.WaitForShutdownAsync(System.Threading.CancellationToken)"/> on all runners."/>
            </summary>
        </member>
        <member name="M:Quantum.QuantumRunnerRegistry.AddRunner(Quantum.SessionRunner)">
            <summary>
            Add a runner.
            </summary>
        </member>
        <member name="M:Quantum.QuantumRunnerRegistry.RemoveRunner(Quantum.SessionRunner)">
            <summary>
            Remove a runner.
            </summary>
        </member>
        <member name="M:Quantum.QuantumRunnerRegistry.FindRunner(System.String)">
            <summary>
            Find a runner by <see cref="P:Quantum.SessionRunner.Id"/>.
            </summary>
            <param name="id">Runner id to search.</param>
            <returns>The runner with the given id or <see langword="null"/>.</returns>
        </member>
        <member name="M:Quantum.QuantumRunnerRegistry.FindRunner(Photon.Deterministic.IDeterministicGame)">
            <summary>
            Find a runner by <see cref="P:Quantum.SessionRunner.DeterministicGame"/>.
            </summary>
            <param name="game">The game that the runner belongs to.</param>
            <returns>The runner with the given game or <see langword="null"/>.</returns>
        </member>
        <member name="T:Quantum.QuantumInstantReplayDemo">
            <summary>
            A script to demonstrate the instant replay feature of Quantum.
            Add this script to a GameObject in your scene to enable the instant replays.
            Press the "Start" button during runtime to start a replay.
            Uses the <see cref="T:Quantum.QuantumInstantReplay"/> class. 
            </summary>
        </member>
        <member name="F:Quantum.QuantumInstantReplayDemo.PlaybackSpeed">
            <summary>
            The playback speed of the replay. Default is 1.0f.
            </summary>
        </member>
        <member name="F:Quantum.QuantumInstantReplayDemo.ReplayLengthSec">
            <summary>
            The length of the replay in seconds. Default is 2.0f.
            </summary>
        </member>
        <member name="F:Quantum.QuantumInstantReplayDemo.ShowReplayLabel">
            <summary>
            If set to true, displays a replay label on the screen during the replay.
            </summary>
        </member>
        <member name="F:Quantum.QuantumInstantReplayDemo.ShowFadingEffect">
            <summary>
            If set to true, displays a fading effect when starting and stopping the replay.
            </summary>
        </member>
        <member name="F:Quantum.QuantumInstantReplayDemo.IsReplayRunning">
            <summary>
            Read-only flag to indicate if the replay is running.
            </summary>
        </member>
        <member name="F:Quantum.QuantumInstantReplayDemo.Button_StartInstantReplay">
            <summary>
            Read-only flag to indicate the start button can be pressed.
            </summary>
        </member>
        <member name="F:Quantum.QuantumInstantReplayDemo.Button_StopInstantReplay">
            <summary>
            Read-only flag to indicate the stop button can be pressed.
            </summary>
        </member>
        <member name="F:Quantum.QuantumInstantReplayDemo.RewindMode">
            <summary>
            Set the rewind mode to loop the replay or seek to a desired frame.
            </summary>
        </member>
        <member name="F:Quantum.QuantumInstantReplayDemo.EnableLoop">
            <summary>
            Loops the replay. Only available when <see cref="F:Quantum.QuantumInstantReplayDemo.RewindMode"/> is not disabled.
            </summary>
        </member>
        <member name="F:Quantum.QuantumInstantReplayDemo.NormalizedTime">
            <summary>
            The replay normalized time. This value is between 0 and 1.
            Use the slider to jump to a desired time in the replay.
            </summary>
        </member>
        <member name="M:Quantum.QuantumInstantReplayDemo.Awake">
            <summary>
            Unity Awake event, subscribe to the game destroyed event and clean up stopped replays.
            </summary>
        </member>
        <member name="M:Quantum.QuantumInstantReplayDemo.Update">
            <summary>
            Unity Update event. Toggle recording snapshots and update the replay.
            Update the debug buttons and trigger seeking the replay.
            </summary>
        </member>
        <member name="M:Quantum.QuantumInstantReplayDemo.OnDisable">
            <summary>
            Unity OnDisabled event, disposes the instant replay data structures.
            </summary>
        </member>
        <member name="M:Quantum.QuantumInstantReplayDemo.OnDestroy">
            <summary>
            Unity OnDestroy event, destroys the fading texture.
            </summary>
        </member>
        <member name="M:Quantum.QuantumInstantReplayDemo.OnGUI">
            <summary>
            Unity OnGUI event, displays the replay label and the replay slider.
            </summary>
        </member>
        <member name="M:Quantum.QuantumInstantReplayDemo.Editor_StartInstantReplay">
            <summary>
            Is called from the inspector to start the instant replay.
            </summary>
        </member>
        <member name="M:Quantum.QuantumInstantReplayDemo.Editor_StopInstantReplay">
            <summary>
            Is called from the inspector to stop the instant replay.
            </summary>
        </member>
        <member name="T:Quantum.OptionalGizmoBool">
            <summary>
            Allows optional gizmo values to be serialized in the inspector.
            </summary>
        </member>
        <member name="P:Quantum.OptionalGizmoBool.HasValue">
            <summary>
            Does this optional value have a value.
            </summary>
        </member>
        <member name="P:Quantum.OptionalGizmoBool.Value">
            <summary>
            The value of this optional value.
            </summary>
        </member>
        <member name="M:Quantum.OptionalGizmoBool.op_Implicit(Quantum.OptionalGizmoBool)~System.Boolean">
            <summary>
            Implicitly convert an optional gizmo value to a bool.
            </summary>
            <param name="optional"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.OptionalGizmoBool.op_Implicit(System.Boolean)~Quantum.OptionalGizmoBool">
            <summary>
            Implicitly convert a bool to an optional gizmo value.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:Quantum.QuantumGizmoEntry">
            <summary>
            Individual entry for a specific section of Quantum.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGizmoEntry.Enabled">
            <summary>
            Is this gizmo enabled.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGizmoEntry.Color">
            <summary>
            The main color of the gizmo.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGizmoEntry.Scale">
            <summary>
            The scale of the gizmo. Only available for gizmos that support scaling.
            0 means disabled.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGizmoEntry.OnlyDrawSelected">
            <summary>
            Only draw the gizmo when the object is selected.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGizmoEntry.DisableFill">
            <summary>
            Draw the gizmo without fill. Only available for gizmos that support fill.
            </summary>
        </member>
        <member name="P:Quantum.QuantumGizmoEntry.InactiveColor">
            <summary>
            The color of the gizmo when it is inactive.
            </summary>
        </member>
        <member name="P:Quantum.QuantumGizmoEntry.TransparentColor">
            <summary>
            The transparent version of the gizmo color.
            </summary>
        </member>
        <member name="P:Quantum.QuantumGizmoEntry.Style">
            <summary>
            The style of the gizmo.
            </summary>
        </member>
        <member name="M:Quantum.QuantumGizmoEntry.#ctor(UnityEngine.Color)">
            <summary>
            Create a new gizmo entry with the given color.
            </summary>
            <param name="color"></param>
        </member>
        <member name="T:Quantum.PhysicsComponentGizmoEntry">
            <summary>
            Individual entry for specifically the physics section of the gizmo overlay.
            </summary>
        </member>
        <member name="M:Quantum.PhysicsComponentGizmoEntry.#ctor(UnityEngine.Color)">
            <summary>
            Create a new physics component gizmo entry with the given color.
            </summary>
            <param name="color"></param>
        </member>
        <member name="T:Quantum.JointGizmoEntry">
            <summary>
            Individual entry for specifically the joint section of the gizmo overlay.
            </summary>
        </member>
        <member name="F:Quantum.JointGizmoEntry.SecondaryColor">
            <summary>
            The secondary color of the joint gizmo.
            </summary>
        </member>
        <member name="F:Quantum.JointGizmoEntry.WarningColor">
            <summary>
            The warning color of the joint gizmo.
            </summary>
        </member>
        <member name="M:Quantum.JointGizmoEntry.#ctor(UnityEngine.Color,UnityEngine.Color,UnityEngine.Color)">
            <summary>
            Create a new joint gizmo entry with the given colors.
            </summary>
            <param name="color"></param>
            <param name="secondaryColor"></param>
            <param name="warningColor"></param>
        </member>
        <member name="T:Quantum.NavMeshComponentGizmoEntry">
            <summary>
            Individual entry for specifically the NavMesh component section of the gizmo overlay.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshComponentGizmoEntry.DefaultComponentGizmoSize">
            <summary>
            Default size for NavMesh component gizmos.
            </summary>
        </member>
        <member name="M:Quantum.NavMeshComponentGizmoEntry.#ctor(UnityEngine.Color)">
            <summary>
            Create a new NavMesh component gizmo entry with the given color.
            </summary>
            <param name="color"></param>
        </member>
        <member name="T:Quantum.NavMeshBorderGizmoEntry">
            <summary>
            Individual entry for specifically the border of the navmesh section of the gizmo overlay.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBorderGizmoEntry.DrawNormals">
            <summary>
            Should the normals of the border be drawn.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshBorderGizmoEntry.BorderNormalColor">
            <summary>
            The color of the border normals.
            </summary>
        </member>
        <member name="M:Quantum.NavMeshBorderGizmoEntry.#ctor(UnityEngine.Color,System.Boolean,UnityEngine.Color)">
            <summary>
            Create a new NavMesh border gizmo entry with the given colors.
            </summary>
            <param name="color"></param>
            <param name="drawNormals"></param>
            <param name="borderNormalColor"></param>
        </member>
        <member name="T:Quantum.NavMeshGizmoEntry">
            <summary>
            Individual entry for specifically the navmesh section of the gizmo overlay.
            </summary>
        </member>
        <member name="F:Quantum.NavMeshGizmoEntry.RegionColor">
            <summary>
            The color of the navmesh region.
            </summary>
        </member>
        <member name="M:Quantum.NavMeshGizmoEntry.#ctor(UnityEngine.Color,UnityEngine.Color)">
            <summary>
            Create a new NavMesh gizmo entry with the given colors.
            </summary>
            <param name="color"></param>
            <param name="regionColor"></param>
        </member>
        <member name="T:Quantum.QuantumGizmoColors">
            <summary>
            The default Quantum Gizmo colors.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGizmoColors.Black">
            <summary>
            Black Gizmo color. RGBA: (0, 0, 0, 1)
            </summary>
        </member>
        <member name="F:Quantum.QuantumGizmoColors.Yellow">
            <summary>
            Yellow Gizmo color. RGBA: (1, 0.92, 0.016, 1)
            </summary>
        </member>
        <member name="F:Quantum.QuantumGizmoColors.Magenta">
            <summary>
            Magenta Gizmo color. RGBA: (1, 0, 1, 1)
            </summary>
        </member>
        <member name="F:Quantum.QuantumGizmoColors.Blue">
            <summary>
            Blue Gizmo color. RGBA: (0, 0, 1, 1)
            </summary>
        </member>
        <member name="F:Quantum.QuantumGizmoColors.Green">
            <summary>
            Green Gizmo color. RGBA: (0, 1, 0, 1)
            </summary>
        </member>
        <member name="F:Quantum.QuantumGizmoColors.White">
            <summary>
            White Gizmo color. RGBA: (1, 1, 1, 1)
            </summary>
        </member>
        <member name="F:Quantum.QuantumGizmoColors.Red">
            <summary>
            Red Gizmo color. RGBA: (1, 0, 0, 1)
            </summary>
        </member>
        <member name="F:Quantum.QuantumGizmoColors.Cyan">
            <summary>
            Cyan Gizmo color. RGBA: (0, 1, 1, 1)
            </summary>
        </member>
        <member name="F:Quantum.QuantumGizmoColors.Gray">
            <summary>
            Gray Gizmo color. RGBA: (0.5, 0.5, 0.5, 1)
            </summary>
        </member>
        <member name="F:Quantum.QuantumGizmoColors.LightGreen">
            <summary>
            Light Green Gizmo color. RGBA: (0.4, 1, 0.7, 1)
            </summary>
        </member>
        <member name="F:Quantum.QuantumGizmoColors.LimeGreen">
            <summary>
            Lime Green Gizmo color. RGBA: (0.4925605, 0.9176471, 0.5050631, 1)
            </summary>
        </member>
        <member name="F:Quantum.QuantumGizmoColors.LightBlue">
            <summary>
            Light Blue Gizmo color. RGBA: (0, 0.75, 1, 1)
            </summary>
        </member>
        <member name="F:Quantum.QuantumGizmoColors.SkyBlue">
            <summary>
            Sky Blue Gizmo color. RGBA: (0.4705882, 0.7371198, 1, 1)
            </summary>
        </member>
        <member name="F:Quantum.QuantumGizmoColors.Maroon">
            <summary>
            Maroon Gizmo color. RGBA: (1, 0, 0.5, 0.5)
            </summary>
        </member>
        <member name="F:Quantum.QuantumGizmoColors.LightPurple">
            <summary>
            Light Purple Gizmo color. RGBA: (0.5192922, 0.4622621, 0.6985294, 1)
            </summary>
        </member>
        <member name="F:Quantum.QuantumGizmoColors.TransparentMagenta">
            <summary>
            Transparent Magenta Gizmo color. RGBA: (1, 0, 1, 0.5)
            </summary>
        </member>
        <member name="F:Quantum.QuantumGizmoColors.TransparentGray">
            <summary>
            Transparent Gray Gizmo color. RGBA: (0.5, 0.5, 0.5, 0.5)
            </summary>
        </member>
        <member name="F:Quantum.QuantumGizmoColors.TransparentLightPurple">
            <summary>
            Transparent Light Purple Gizmo color. RGBA: (0.5192922, 0.4622621, 0.6985294, 0.5)
            </summary>
        </member>
        <member name="F:Quantum.QuantumGizmoColors.TransparentYellow">
            <summary>
            Transparent Yellow Gizmo color. RGBA: (1, 0.92, 0.016, 0.5)
            </summary>
        </member>
        <member name="F:Quantum.QuantumGizmoColors.TransparentWhite">
            <summary>
            Transparent White Gizmo color. RGBA: (1, 1, 1, 0.5)
            </summary>
        </member>
        <member name="F:Quantum.QuantumGizmoColors.TransparentLimeGreen">
            <summary>
            Transparent Lime Green Gizmo color. RGBA: (0.4925605, 0.9176471, 0.5050631, 0.5)
            </summary>
        </member>
        <member name="F:Quantum.QuantumGizmoColors.TransparentGreen">
            <summary>
            Transparent Green Gizmo color. RGBA: (0, 1, 0, 0.5)
            </summary>
        </member>
        <member name="F:Quantum.QuantumGizmoColors.TransparentSkyBlue">
            <summary>
            Transparent Sky Blue Gizmo color. RGBA: (0.4705882, 0.7371198, 1, 0.5)
            </summary>
        </member>
        <member name="F:Quantum.QuantumGizmoColors.TransparentLightBlue">
            <summary>
            Transparent Light Blue Gizmo color. RGBA: (0, 0.75, 1, 0.5)
            </summary>
        </member>
        <member name="F:Quantum.QuantumGizmoColors.TransparentLightGreen">
            <summary>
            Transparent Black Gizmo color. RGBA: (0, 0, 0, 0.5)
            </summary>
        </member>
        <member name="F:Quantum.QuantumGizmoColors.TransparentBlue">
            <summary>
            Transparent Blue Gizmo color. RGBA: (0, 0, 1, 0.5)
            </summary>
        </member>
        <member name="F:Quantum.QuantumGizmoColors.TransparentMaroon">
            <summary>
            Transparent Maroon Gizmo color. RGBA: (1, 0, 0.5, 0.5)
            </summary>
        </member>
        <member name="F:Quantum.QuantumGizmoColors.TransparentRed">
            <summary>
            Transparent Red Gizmo color. RGBA: (1, 0, 0, 0.5)
            </summary>
        </member>
        <member name="M:Quantum.QuantumGizmoColors.GetSelectedColor(Quantum.QuantumGameGizmosSettings,UnityEngine.Color,System.Boolean)">
            <summary>
            Get the selected version of a given color.
            </summary>
            <param name="settings"></param>
            <param name="color"></param>
            <param name="selected"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.QuantumGizmoColors.Desaturate(UnityEngine.Color,System.Single)">
            <summary>
            Desaturate a given color.
            </summary>
            <param name="c"></param>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.QuantumGizmoColors.Darken(UnityEngine.Color,System.Single)">
            <summary>
            Darken a given color.
            </summary>
            <param name="color"></param>
            <param name="percentage"></param>
            <returns></returns>
        </member>
        <member name="T:Quantum.EditorDefines">
            <summary>
            Quantum editor defines.
            </summary>
        </member>
        <member name="F:Quantum.EditorDefines.AssetMenuPriority">
            <summary>
            Asset menu priority starting position.
            -1000 mean the items will be at the top of the list.
            </summary>
        </member>
        <member name="F:Quantum.EditorDefines.AssetMenuPriorityAssets">
            <summary>
            Create assets menu order.
            </summary>
        </member>
        <member name="F:Quantum.EditorDefines.AssetMenuPriorityConfigurations">
            <summary>
            Create configuration menu order.
            </summary>
        </member>
        <member name="F:Quantum.EditorDefines.AssetMenuPriorityScripts">
            <summary>
            Create scripts menu order.
            </summary>
        </member>
        <member name="F:Quantum.EditorDefines.AssetMenuPrioritQtn">
            <summary>
            Obsolete
            </summary>
        </member>
        <member name="F:Quantum.EditorDefines.AssetMenuPriorityDemo">
            <summary>
            Obsolete
            </summary>
        </member>
        <member name="F:Quantum.EditorDefines.AssetMenuPriorityStart">
            <summary>
            Obsolete
            </summary>
        </member>
        <member name="T:Quantum.QuantumGameGizmosSettingsScriptableObject">
            <summary>
            A scriptable object to store the Quantum game gizmos settings <see cref="T:Quantum.QuantumGameGizmosSettings"/>.
            Global configs are marked with "QuantumDefaultGlobal" asset label and there should be only one instance of this asset tagged as such.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameGizmosSettingsScriptableObject.DefaultPath">
            <summary>
            The default location where the initial asset is being created.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameGizmosSettingsScriptableObject.Settings">
            <summary>
            The global and default settings for Quantum gizmos.
            </summary>
        </member>
        <member name="M:Quantum.QuantumGameGizmosSettingsScriptableObject.OpenOverlay">
            <summary>
            Open the overlay for the Quantum gizmos.
            </summary>
        </member>
        <member name="T:Quantum.QuantumRunnerLocalReplay">
            <summary>
            An example of how to start a Quantum replay simulation from a replay file.
            </summary>
        </member>
        <member name="F:Quantum.QuantumRunnerLocalReplay.DeltaTypeType">
            <summary>
            Set the <see cref="F:Quantum.QuantumRunnerLocalReplay.DeltaTypeType" /> to <see cref="F:Quantum.SimulationUpdateTime.EngineDeltaTime" /> to not progress the
            simulation time during break points.
            </summary>
        </member>
        <member name="F:Quantum.QuantumRunnerLocalReplay.ReplayFile">
            <summary>
            Replay JSON file.
            </summary>
        </member>
        <member name="F:Quantum.QuantumRunnerLocalReplay.DatabaseFile">
            <summary>
            Quantum asset database Json file.
            </summary>
        </member>
        <member name="F:Quantum.QuantumRunnerLocalReplay.SimulationSpeedMultiplier">
            <summary>
            Simulation speed multiplier to playback the replay in a different speed.
            </summary>
        </member>
        <member name="F:Quantum.QuantumRunnerLocalReplay.ShowReplayLabel">
            <summary>
            Toggle the replay gui label on/off.
            </summary>
        </member>
        <member name="F:Quantum.QuantumRunnerLocalReplay.InstantReplayConfig">
            <summary>
            Instant replay configurations to start the replay with.
            </summary>
        </member>
        <member name="M:Quantum.QuantumRunnerLocalReplay.Start">
            <summary>
            Unity start event, will start the Quantum runner and simulation after deserializing the replay file.
            </summary>
        </member>
        <member name="M:Quantum.QuantumRunnerLocalReplay.Update">
            <summary>
            Unity Update event will update the simulation if a custom <see cref="F:Quantum.QuantumRunnerLocalReplay.SimulationSpeedMultiplier"/> was set.
            </summary>
        </member>
        <member name="T:Quantum.QuantumNavMesh">
            <summary>
            This class is a collection of utility methods to import Unity NavMesh data into Quantum NavMesh data.
            </summary>
        </member>
        <member name="T:Quantum.QuantumNavMesh.Vertex">
            <summary>
            Intermediate mesh vertex data structure.
            </summary>
        </member>
        <member name="F:Quantum.QuantumNavMesh.Vertex.Id">
            <summary>
            The vertex id.
            </summary>
        </member>
        <member name="F:Quantum.QuantumNavMesh.Vertex.Position">
            <summary>
            The world position.
            </summary>
        </member>
        <member name="M:Quantum.QuantumNavMesh.Vertex.Convert">
            <summary>
            Convert the vertex data to a Quantum NavMesh vertex.
            </summary>
            <returns></returns>
        </member>
        <member name="F:Quantum.QuantumNavMesh.DefaultMinAgentRadius">
            <summary>
            The default minimum agent radius. Will be updated during importing the Unity navmesh.
            </summary>
        </member>
        <member name="T:Quantum.QuantumNavMesh.ImportSettings">
            <summary>
            The Unity navmesh import settings.
            </summary>
        </member>
        <member name="F:Quantum.QuantumNavMesh.ImportSettings.WeldIdenticalVertices">
            <summary>
            The Unity NavMesh is a collection of non - connected triangles, this option is very important and combines shared vertices.
            </summary>
        </member>
        <member name="F:Quantum.QuantumNavMesh.ImportSettings.WeldVertexEpsilon">
            <summary>
            Don't make the epsilon too small, vertices to fuse are missed, also don't make the value too big as it will deform your navmesh. Min = float.Epsilon.
            </summary>
        </member>
        <member name="F:Quantum.QuantumNavMesh.ImportSettings.DelaunayTriangulation">
            <summary>
            Post processes imported Unity navmesh with a Delaunay triangulation to reduce long triangles.
            </summary>
        </member>
        <member name="F:Quantum.QuantumNavMesh.ImportSettings.DelaunayTriangulationRestrictToPlanes">
            <summary>
            In 3D the triangulation can deform the navmesh on slopes, check this option to restrict the triangulation to triangles that lie in the same plane.
            </summary>
        </member>
        <member name="F:Quantum.QuantumNavMesh.ImportSettings.FixTrianglesOnEdges">
            <summary>
            Sometimes vertices are lying on other triangle edges, this will lead to unwanted borders being detected, this option splits those vertices.
            </summary>
        </member>
        <member name="F:Quantum.QuantumNavMesh.ImportSettings.FixTrianglesOnEdgesEpsilon">
            <summary>
            Larger scaled navmeshes may require to increase this value (e.g. 0.001) when false-positive borders are detected. Min = float.Epsilon.
            </summary>
        </member>
        <member name="F:Quantum.QuantumNavMesh.ImportSettings.FixTrianglesOnEdgesHeightEpsilon">
            <summary>
            Make the height offset considerably larger than FixTrianglesOnEdgesEpsilon to better detect degenerate triangles. Is the navmesh becomes deformed chose a smaller epsilon. . Min = float.Epsilon. Default is 0.05.
            </summary>
        </member>
        <member name="F:Quantum.QuantumNavMesh.ImportSettings.LinkErrorCorrection">
            <summary>
            Automatically correct navmesh link position to the closest triangle by searching this distance (default is 0).
            </summary>
        </member>
        <member name="F:Quantum.QuantumNavMesh.ImportSettings.ClosestTriangleCalculation">
            <summary>
            SpiralOut will be considerably faster but fallback triangles can be null.
            </summary>
        </member>
        <member name="F:Quantum.QuantumNavMesh.ImportSettings.ClosestTriangleCalculationDepth">
            <summary>
            Number of cells to search triangles in neighbors.
            </summary>
        </member>
        <member name="F:Quantum.QuantumNavMesh.ImportSettings.EnableQuantum_XY">
            <summary>
            Activate this and the navmesh baking will flip Y and Z to support navmeshes generated in the XY plane.
            </summary>
        </member>
        <member name="F:Quantum.QuantumNavMesh.ImportSettings.MinAgentRadius">
            <summary>
            The agent radius that the navmesh is build for. The value is retrieved from Unity settings when baking in Editor.
            </summary>
        </member>
        <member name="F:Quantum.QuantumNavMesh.ImportSettings.ImportRegions">
            <summary>
            Toggle the Quantum region import.
            </summary>
        </member>
        <member name="F:Quantum.QuantumNavMesh.ImportSettings.RegionDetectionMargin">
            <summary>
            The artificial margin is necessary because the Unity NavMesh does not fit the source size very well. The value is added to the navmesh area and checked against all Quantum Region scripts to select the correct region id.
            </summary>
        </member>
        <member name="F:Quantum.QuantumNavMesh.ImportSettings.RegionAreaIds">
            <summary>
            The region area ids to import.
            </summary>
        </member>
        <member name="T:Quantum.QuantumNavMesh.ImportUtils">
            <summary>
            The navmesh import utility methods.
            </summary>
        </member>
        <member name="M:Quantum.QuantumNavMesh.ImportUtils.WeldIdenticalVertices(Quantum.QuantumNavMesh.Vertex[]@,Quantum.NavMeshBakeDataTriangle[]@,System.Single,System.Action{System.Single})">
            <summary>
            Tries to merge vertices that are very close to each other into a single vertex.
            </summary>
            <param name="vertices">Mesh vertices collection.</param>
            <param name="triangles">Mesh triangles collection.</param>
            <param name="cleanupEpsilon">The epsilon to detect identical vertices.</param>
            <param name="reporter">Progress bar.</param>
        </member>
        <member name="M:Quantum.QuantumNavMesh.ImportUtils.RemoveUnusedVertices(Quantum.QuantumNavMesh.Vertex[]@,Quantum.NavMeshBakeDataTriangle[]@,System.Action{System.Single})">
            <summary>
            Removes unused vertices from the vertex array.
            </summary>
            <param name="vertices">Mesh vertices collection.</param>
            <param name="triangles">Mesh triangles collection.</param>
            <param name="reporter">Progress bar.</param>
        </member>
        <member name="M:Quantum.QuantumNavMesh.ImportUtils.ImportRegions(UnityEngine.SceneManagement.Scene,Quantum.QuantumNavMesh.Vertex[]@,Quantum.NavMeshBakeDataTriangle[]@,System.Int32,System.Collections.Generic.List{System.String}@,System.Single)">
            <summary>
            Tries to identify what region individual vertices belong to. Uses the original <see cref="T:Quantum.QuantumNavMeshRegion"/> scripts to cast vertices against.
            </summary>
            <param name="scene">Unity scene.</param>
            <param name="vertices">Mesh vertices collection.</param>
            <param name="triangles">Mesh triangles collection.</param>
            <param name="t">The current triangle index to analyze.</param>
            <param name="regionMap">The list of regions already found.</param>
            <param name="regionDetectionMargin">The region detection margin used to enlarge the reference share from the <see cref="T:Quantum.QuantumNavMeshRegion"/> script.</param>
        </member>
        <member name="M:Quantum.QuantumNavMesh.ImportUtils.FixTrianglesOnEdges(Quantum.QuantumNavMesh.Vertex[]@,Quantum.NavMeshBakeDataTriangle[]@,System.Int32,System.Int32,System.Single,System.Single)">
            <summary>
            Tries to detect degenerated triangles that are emit by the Unity navmesh triangulation. This detects when triangles have vertices on other triangle edges.
            </summary>
            <param name="vertices">Mesh vertices collection.</param>
            <param name="triangles">Mesh triangles collection.</param>
            <param name="t">The current triangle index to analyze.</param>
            <param name="v0">The first vertex.</param>
            <param name="epsilon">The epsilon to use when detecting vertex on edges.</param>
            <param name="epsilonHeight">The explicit height epsilon to use.</param>
        </member>
        <member name="M:Quantum.QuantumNavMesh.ImportUtils.FindTriangleOnEdge(Quantum.QuantumNavMesh.Vertex[]@,Quantum.NavMeshBakeDataTriangle[]@,System.Int32,System.Int32,System.Int32,System.Single,System.Single,System.Int32@)">
            <summary>
            Detects if a triangle <paramref name="tri"/> has a vertex on the segment between <paramref name="v0"/> and <paramref name="v1"/>.
            </summary>
            <returns>The triangle that lies on the segment or -1.</returns>
        </member>
        <member name="M:Quantum.QuantumNavMesh.ImportUtils.SplitTriangle(Quantum.NavMeshBakeDataTriangle[]@,System.Int32,System.Int32,System.Int32)">
            <summary>
            Splits a triangle into two triangles by inserting a new vertex at the edge between <paramref name="v0"/> and v0 + 1.
            </summary>
        </member>
        <member name="M:Quantum.QuantumNavMesh.ImportFromUnity(UnityEngine.SceneManagement.Scene,Quantum.QuantumNavMesh.ImportSettings,System.String)">
            <summary>
            Import a Unity NavMesh into Quantum NavMesh data.
            </summary>
            <param name="scene">The Unity scene.</param>
            <param name="settings">The navmesh import settings.</param>
            <param name="name">The navmesh.</param>
            <returns>The resulting imported navmesh.</returns>
        </member>
        <member name="M:Quantum.QuantumNavMesh.FindSmallestAgentRadius(UnityEngine.GameObject[])">
            <summary>
            Iterates through all navmesh surfaces and detect the smallest agent radius used.
            </summary>
            <param name="navmeshSurfaces">List of navmesh surfaces to analyze.</param>
            <returns>The smallets agent radius in FP.</returns>
        </member>
        <member name="T:Quantum.QuantumNavMesh.Vector2Double">
            <summary>
            Math class only used by <see cref="T:Quantum.QuantumNavMesh"/> import calculations. Uses double precision.
            </summary>
        </member>
        <member name="F:Quantum.QuantumNavMesh.Vector2Double.X">
            <summary>
            X component of the vector.
            </summary>
        </member>
        <member name="F:Quantum.QuantumNavMesh.Vector2Double.Y">
            <summary>
            Y component of the vector.
            </summary>
        </member>
        <member name="M:Quantum.QuantumNavMesh.Vector2Double.#ctor(System.Double,System.Double)">
            <summary>
            Create new vector.
            </summary>
        </member>
        <member name="M:Quantum.QuantumNavMesh.Vector2Double.op_Subtraction(Quantum.QuantumNavMesh.Vector2Double,Quantum.QuantumNavMesh.Vector2Double)">
            <summary>
            Minus operator.
            </summary>
        </member>
        <member name="M:Quantum.QuantumNavMesh.Vector2Double.Distance(Quantum.QuantumNavMesh.Vector2Double,Quantum.QuantumNavMesh.Vector2Double)">
            <summary>
            Calculate the distance between two points.
            </summary>
            <param name="a">Point a.</param>
            <param name="b">Point b.</param>
            <returns>The distance between to points.</returns>
        </member>
        <member name="T:Quantum.QuantumNavMesh.Vector3Double">
            <summary>
            Math class only used by <see cref="T:Quantum.QuantumNavMesh"/> import calculations. Uses double precision.
            </summary>
        </member>
        <member name="F:Quantum.QuantumNavMesh.Vector3Double.X">
            <summary>
            X component of the vector.
            </summary>
        </member>
        <member name="F:Quantum.QuantumNavMesh.Vector3Double.Y">
            <summary>
            Y component of the vector.
            </summary>
        </member>
        <member name="F:Quantum.QuantumNavMesh.Vector3Double.Z">
            <summary>
            Z component of the vector.
            </summary>
        </member>
        <member name="M:Quantum.QuantumNavMesh.Vector3Double.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Crate a new vector.
            </summary>
        </member>
        <member name="M:Quantum.QuantumNavMesh.Vector3Double.#ctor(Photon.Deterministic.FPVector3)">
            <summary>
            Create a new vector using a Quantum fixed point vector.
            </summary>
            <param name="v"></param>
        </member>
        <member name="M:Quantum.QuantumNavMesh.Vector3Double.#ctor(UnityEngine.Vector3)">
            <summary>
            Create a new vector using a Unity vector.
            </summary>
            <param name="v"></param>
        </member>
        <member name="M:Quantum.QuantumNavMesh.Vector3Double.Equals(System.Object)">
            <summary>
            Returns a value indicating whether this instance is equal to a specified Vector3Double value.
            </summary>
            <param name="obj">An Vector3Double value to compare to this instance.</param>
            <returns><see langword="true"/> if other has the same value as this instance; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Quantum.QuantumNavMesh.Vector3Double.GetHashCode">
            <summary>
            Overrides the default hash function.
            </summary>
            <returns>A hash code for the current object.</returns>
        </member>
        <member name="M:Quantum.QuantumNavMesh.Vector3Double.op_Equality(Quantum.QuantumNavMesh.Vector3Double,Quantum.QuantumNavMesh.Vector3Double)">
            <summary>
            Operator override for which checks if two instances of Vector3Double are equal.
            </summary>
            <returns><see langword="true"/> if the instances are equal.</returns>
        </member>
        <member name="M:Quantum.QuantumNavMesh.Vector3Double.op_Inequality(Quantum.QuantumNavMesh.Vector3Double,Quantum.QuantumNavMesh.Vector3Double)">
            <summary>
            Operator override for which checks if two instances of REPLACE are not equal.
            </summary>
            <returns><see langword="true"/> if the instances are not equal.</returns>
        </member>
        <member name="M:Quantum.QuantumNavMesh.Vector3Double.op_Subtraction(Quantum.QuantumNavMesh.Vector3Double,Quantum.QuantumNavMesh.Vector3Double)">
            <summary>
            Subtracts two Vector3Double instances.
            </summary>
        </member>
        <member name="M:Quantum.QuantumNavMesh.Vector3Double.op_Addition(Quantum.QuantumNavMesh.Vector3Double,Quantum.QuantumNavMesh.Vector3Double)">
            <summary>
            Adds two Vector3Double instances.
            </summary>
        </member>
        <member name="M:Quantum.QuantumNavMesh.Vector3Double.op_Multiply(Quantum.QuantumNavMesh.Vector3Double,System.Double)">
            <summary>
            Multiplies a Vector3Double instance with a scalar.
            </summary>
        </member>
        <member name="M:Quantum.QuantumNavMesh.Vector3Double.op_Multiply(System.Double,Quantum.QuantumNavMesh.Vector3Double)">
            <summary>
            Multiplies a Vector3Double instance with a scalar.
            </summary>
        </member>
        <member name="M:Quantum.QuantumNavMesh.Vector3Double.AsFPVector">
            <summary>
            Converts into fixed point vector. Only safe during editor as it uses <see cref="M:Photon.Deterministic.FP.FromFloat_UNSAFE(System.Single)"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Quantum.QuantumNavMesh.Vector3Double.AsVector">
            <summary>
            Converts into Unity vector.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Quantum.QuantumNavMesh.Vector3Double.SqrMagnitude">
            <summary>
            Returns the square magnitude of the vector.
            </summary>
        </member>
        <member name="M:Quantum.QuantumNavMesh.Vector3Double.SqrMagnitude(Quantum.QuantumNavMesh.Vector3Double)">
            <summary>
            Returns the square magnitude <paramref name="v"/>
            </summary>
        </member>
        <member name="M:Quantum.QuantumNavMesh.Vector3Double.Magnitude">
            <summary>
            Returns the magnitude of the vector.
            </summary>
        </member>
        <member name="M:Quantum.QuantumNavMesh.Vector3Double.Distance(Quantum.QuantumNavMesh.Vector3Double,Quantum.QuantumNavMesh.Vector3Double)">
            <summary>
            Returns the distance between two points.
            </summary>
        </member>
        <member name="M:Quantum.QuantumNavMesh.Vector3Double.Normalize">
            <summary>
            Normalized the vector.
            </summary>
            <exception cref="T:System.ArgumentException">Is raised when the magnitude is 0.</exception>
        </member>
        <member name="M:Quantum.QuantumNavMesh.Vector3Double.ToString">
            <summary>
            Converts the numeric value of this instance to its equivalent string representation.
            </summary>
        </member>
        <member name="M:Quantum.QuantumNavMesh.Vector3Double.Dot(Quantum.QuantumNavMesh.Vector3Double,Quantum.QuantumNavMesh.Vector3Double)">
            <summary>
            Returns the dot product of two vectors.
            </summary>
        </member>
        <member name="M:Quantum.QuantumNavMesh.Vector3Double.Cross(Quantum.QuantumNavMesh.Vector3Double,Quantum.QuantumNavMesh.Vector3Double)">
            <summary>
            Returns the cross product of two vectors.
            </summary>
        </member>
        <member name="M:Quantum.QuantumNavMesh.Vector3Double.IsPointBetween(Quantum.QuantumNavMesh.Vector3Double,Quantum.QuantumNavMesh.Vector3Double,Quantum.QuantumNavMesh.Vector3Double,System.Single,System.Single)">
            <summary>
            Calculates if the point <paramref name="p"/> is between the two points <paramref name="v0"/> and <paramref name="v1"/>.
            </summary>
        </member>
        <member name="M:Quantum.QuantumNavMesh.Vector3Double.ClosestDistanceToTriangle(Quantum.QuantumNavMesh.Vector3Double,Quantum.QuantumNavMesh.Vector3Double,Quantum.QuantumNavMesh.Vector3Double,Quantum.QuantumNavMesh.Vector3Double,Quantum.QuantumNavMesh.Vector3Double@)">
            <summary>
            Calculates the closest distance from point <paramref name="p"/> to the triangle defined by <paramref name="v0"/>, <paramref name="v1"/> and <paramref name="v2"/>.
            </summary>
        </member>
        <member name="T:Quantum.QuantumDeterministicSessionConfigAsset">
            <summary>
            The asset wraps an instance of <see cref="T:Photon.Deterministic.DeterministicSessionConfig"/> and makes it globally (in Unity) accessible as a default config.
            </summary>
        </member>
        <member name="F:Quantum.QuantumDeterministicSessionConfigAsset.DefaultPath">
            <summary>
            The default location of the global QuantumDeterministicSessionConfigAsset asset.
            </summary>
        </member>
        <member name="F:Quantum.QuantumDeterministicSessionConfigAsset.Config">
            <summary>
            The config instance.
            </summary>
        </member>
        <member name="P:Quantum.QuantumDeterministicSessionConfigAsset.DefaultConfig">
            <summary>
            Return the default global config instance.
            </summary>
        </member>
        <member name="F:QuantumSDKAttributesTest.LayerMask">
            <summary>
            Some inline help.
            </summary>
        </member>
        <member name="F:QuantumSDKAttributesTest.EntityPrototype">
            <summary>
            Some inline help.
            </summary>
        </member>
        <member name="F:QuantumSDKAttributesTest.fpUnitsHelp">
            <summary>
            Some inline help.
            </summary>
        </member>
    </members>
</doc>
