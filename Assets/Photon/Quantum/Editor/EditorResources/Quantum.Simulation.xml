<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Quantum.Simulation</name>
    </assembly>
    <members>
        <member name="T:Quantum.SystemGroup">
            <summary>
            The base class for a hierarchy of systems.
            </summary>
        </member>
        <member name="P:Quantum.SystemGroup.ChildSystems">
            <inheritdoc cref="P:Quantum.SystemBase.ChildSystems"/>
        </member>
        <member name="M:Quantum.SystemGroup.#ctor(System.String,Quantum.SystemBase[])">
            <summary>
            Create a new system group.
            </summary>
            <param name="name">The name of the system.</param>
            <param name="children">The child systems.</param>
        </member>
        <member name="M:Quantum.SystemGroup.Schedule(Quantum.Frame,Quantum.Task.TaskHandle)">
            <summary>
            Add the child systems the the task hierarchy.
            </summary>
            <param name="f">The referenced frame.</param>
            <param name="taskHandle">The initial task handle.</param>
            <returns>The final task graph.</returns>
        </member>
        <member name="M:Quantum.SystemGroup.OnEnabled(Quantum.Frame)">
            <inheritdoc cref="M:Quantum.SystemBase.OnEnabled(Quantum.Frame)"/>
        </member>
        <member name="M:Quantum.SystemGroup.OnDisabled(Quantum.Frame)">
            <inheritdoc cref="M:Quantum.SystemBase.OnDisabled(Quantum.Frame)"/>
        </member>
        <member name="T:Quantum.GameResult">
            <summary>
            The game result class can be extended by a partial class. 
            It is used with the <see cref="T:Quantum.EventGameResult"/> to report the game result to the server.
            See the online documentation for more information.
            </summary>
        </member>
        <member name="F:Quantum.GameResult.Frame">
            <summary>
            The frame when the game result was created.
            </summary>
        </member>
        <member name="T:Quantum.EventGameResult">
            <summary>
            Does not have to implement checksum, because it's a hard-coded synced event.
            </summary>
        </member>
        <member name="F:Quantum.EventGameResult.ID">
            <summary>
            The game result event id.
            </summary>
        </member>
        <member name="F:Quantum.EventGameResult.GameResult">
            <summary>
            The game result that was created by the simulation.
            </summary>
        </member>
        <member name="M:Quantum.EventGameResult.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="P:Quantum.EventGameResult.Game">
            <summary>
            Override the Game accessor to return the specialized <see cref="T:Quantum.QuantumGame"/> instead of the interface.
            </summary>
        </member>
        <member name="T:Quantum.Asteroids.AsteroidsMapSystem">
            <summary>
            The <c>AsteroidsMapSystem</c> class handles the logic for wrapping entities around the map boundaries
            in the Asteroids game. It ensures that entities reappear on the opposite side when they move out of bounds.
            </summary>
        </member>
        <member name="T:Quantum.Asteroids.AsteroidsMapSystem.Filter">
            <summary>
            The <c>Filter</c> struct represents the components required for the system's operations,
            including an entity reference and its transform.
            </summary>
        </member>
        <member name="F:Quantum.Asteroids.AsteroidsMapSystem.Filter.Entity">
            <summary>
            The reference to the entity being processed.
            </summary>
        </member>
        <member name="F:Quantum.Asteroids.AsteroidsMapSystem.Filter.Transform">
            <summary>
            Pointer to the entity's transform component.
            </summary>
        </member>
        <member name="M:Quantum.Asteroids.AsteroidsMapSystem.Update(Quantum.Frame,Quantum.Asteroids.AsteroidsMapSystem.Filter@)">
            <summary>
            Updates the state of the system by checking if entities are out of bounds and wrapping them if necessary.
            </summary>
            <param name="f">The game frame.</param>
            <param name="filter">The filter containing the entity and its transform.</param>
        </member>
        <member name="T:Quantum.Asteroids.AsteroidsGameConfig">
            <summary>
            The <c>AsteroidsGameConfig</c> class holds the configuration settings for the Asteroids game.
            These settings include parameters for ships, projectiles, asteroids, and the game map.
            </summary>
        </member>
        <member name="P:Quantum.Asteroids.AsteroidsGameConfig.MapExtends">
            <summary>
            Gets the half-size of the map, used for boundary calculations.
            </summary>
        </member>
        <member name="M:Quantum.Asteroids.AsteroidsGameConfig.Loaded(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)">
            <summary>
            Called when the asset is loaded. Initializes the map extents based on the game map size.
            </summary>
            <param name="resourceManager">The resource manager used to load assets.</param>
            <param name="allocator">The memory allocator used during loading.</param>
        </member>
        <member name="M:Quantum.Asteroids.AsteroidsGameConfig.IsOutOfBounds(Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2@)">
            <summary>
            Checks if a position is out of bounds and provides a warped position.
            When the entity leaves the bounds, it will emerge on the other side.
            </summary>
            <param name="position">The position to check.</param>
            <param name="newPosition">The new position after wrapping around the map bounds.</param>
            <returns><c>true</c> if the position was out of bounds and was warped; otherwise, <c>false</c>.</returns>
        </member>
        <member name="T:Quantum.Asteroids.AsteroidsCollisionsSystem">
            <summary>
            The <c>AsteroidsCollisionsSystem</c> class handles collision events in the Asteroids game,
            responding to projectile hits on ships and asteroids, as well as asteroid collisions with ships.
            </summary>
        </member>
        <member name="M:Quantum.Asteroids.AsteroidsCollisionsSystem.OnCollisionEnter2D(Quantum.Frame,Quantum.CollisionInfo2D)">
            <summary>
            Called when a 2D collision occurs. Determines the type of entities involved
            in the collision and delegates to the appropriate handler method.
            </summary>
            <param name="f">The game frame.</param>
            <param name="info">Information about the collision.</param>
        </member>
        <member name="M:Quantum.Asteroids.AsteroidsCollisionsSystem.HandleProjectileHitShip(Quantum.Frame,Quantum.CollisionInfo2D,Quantum.AsteroidsProjectile*)">
            <summary>
            Handles the scenario where a projectile hits a ship. Increases the score of the ship that fired the projectile
            and signals the destruction of the hit ship.
            </summary>
            <param name="f">The game frame.</param>
            <param name="info">Information about the collision.</param>
            <param name="projectile">Pointer to the projectile involved in the collision.</param>
        </member>
        <member name="M:Quantum.Asteroids.AsteroidsCollisionsSystem.HandleProjectileHitAsteroid(Quantum.Frame,Quantum.CollisionInfo2D,Quantum.AsteroidsProjectile*,Quantum.AsteroidsAsteroid)">
            <summary>
            Handles the scenario where a projectile hits an asteroid. Increases the score of the ship that fired the projectile,
            and potentially spawns new child asteroids.
            </summary>
            <param name="f">The game frame.</param>
            <param name="info">Information about the collision.</param>
            <param name="projectile">Pointer to the projectile involved in the collision.</param>
            <param name="asteroid">The asteroid involved in the collision.</param>
        </member>
        <member name="M:Quantum.Asteroids.AsteroidsCollisionsSystem.HandleAsteroidHitShip(Quantum.Frame,Quantum.CollisionInfo2D,Quantum.AsteroidsAsteroid*)">
            <summary>
            Handles the scenario where an asteroid hits a ship. Signals the destruction of the ship.
            </summary>
            <param name="f">The game frame.</param>
            <param name="info">Information about the collision.</param>
            <param name="asteroid">Pointer to the asteroid involved in the collision.</param>
        </member>
        <member name="T:Quantum.Asteroids.AsteroidsWaveSpawnerSystem">
            <summary>
            The <c>AsteroidsWaveSpawnerSystem</c> class is responsible for spawning waves of asteroids
            and managing the asteroid spawning logic.
            </summary>
        </member>
        <member name="M:Quantum.Asteroids.AsteroidsWaveSpawnerSystem.OnInit(Quantum.Frame)">
            <summary>
            Initializes the wave spawner system by setting the initial wave count and spawning the first wave of asteroids.
            </summary>
            <param name="f">The game frame.</param>
        </member>
        <member name="M:Quantum.Asteroids.AsteroidsWaveSpawnerSystem.OnRemoved(Quantum.Frame,Quantum.EntityRef,Quantum.AsteroidsAsteroid*)">
            <summary>
            Handles the removal of an asteroid component. If there are no asteroids remaining,
            spawns a new wave of asteroids.
            </summary>
            <param name="f">The game frame.</param>
            <param name="entity">The entity from which the asteroid component was removed.</param>
            <param name="component">The removed asteroid component.</param>
        </member>
        <member name="M:Quantum.Asteroids.AsteroidsWaveSpawnerSystem.SpawnAsteroidWave(Quantum.Frame)">
            <summary>
            Spawns a wave of asteroids based on the current wave count.
            </summary>
            <param name="f">The game frame.</param>
        </member>
        <member name="M:Quantum.Asteroids.AsteroidsWaveSpawnerSystem.AsteroidsSpawnAsteroid(Quantum.Frame,Quantum.AssetRef{Quantum.EntityPrototype},Quantum.EntityRef)">
            <summary>
            Spawns an asteroid entity at a random position on the edge of the game area or near a specified parent entity.
            </summary>
            <param name="f">The game frame.</param>
            <param name="childPrototype">The prototype of the asteroid entity to spawn.</param>
            <param name="parent">The parent entity near which to spawn the asteroid (or EntityRef.None for random edge spawn).</param>
        </member>
        <member name="T:Quantum.Asteroids.AsteroidsUtils">
            <summary>
            The <c>AsteroidsUtils</c> static class provides utility functions for common tasks in the Asteroids game,
            such as generating random rotations and positions on a circle's edge.
            </summary>
        </member>
        <member name="M:Quantum.Asteroids.AsteroidsUtils.GetRandomRotation(Quantum.Frame)">
            <summary>
            Generates a random rotation angle between 0 and 360 degrees.
            </summary>
            <param name="f">The game frame, which provides access to the random number generator.</param>
            <returns>A random rotation angle in degrees.</returns>
        </member>
        <member name="M:Quantum.Asteroids.AsteroidsUtils.GetRandomEdgePointOnCircle(Quantum.Frame,Photon.Deterministic.FP)">
            <summary>
            Calculates a random point on the edge of a circle with the specified radius.
            </summary>
            <param name="f">The game frame, which provides access to the random number generator.</param>
            <param name="radius">The radius of the circle.</param>
            <returns>A random point on the edge of the circle.</returns>
        </member>
        <member name="T:Quantum.Asteroids.AsteroidsShipSystem">
            <summary>
            The <c>AsteroidsShipSystem</c> class manages the behavior of player-controlled ships,
            including movement, firing, and handling destruction and respawn.
            </summary>
        </member>
        <member name="T:Quantum.Asteroids.AsteroidsShipSystem.Filter">
            <summary>
            The <c>Filter</c> struct represents the components required for the system's operations,
            including an entity reference, transform, physics body, ship component, and player link component.
            </summary>
        </member>
        <member name="F:Quantum.Asteroids.AsteroidsShipSystem.Filter.Entity">
            <summary>
            The reference to the entity being processed.
            </summary>
        </member>
        <member name="F:Quantum.Asteroids.AsteroidsShipSystem.Filter.Transform">
            <summary>
            Pointer to the entity's transform component.
            </summary>
        </member>
        <member name="F:Quantum.Asteroids.AsteroidsShipSystem.Filter.Body">
            <summary>
            Pointer to the entity's physics body component.
            </summary>
        </member>
        <member name="F:Quantum.Asteroids.AsteroidsShipSystem.Filter.AsteroidsShip">
            <summary>
            Pointer to the entity's ship component.
            </summary>
        </member>
        <member name="F:Quantum.Asteroids.AsteroidsShipSystem.Filter.PlayerLink">
            <summary>
            Pointer to the entity's player link component.
            </summary>
        </member>
        <member name="M:Quantum.Asteroids.AsteroidsShipSystem.Update(Quantum.Frame,Quantum.Asteroids.AsteroidsShipSystem.Filter@)">
            <summary>
            Updates the ship movement and firing, as well as respawning if needed.
            </summary>
            <param name="f">The game frame.</param>
            <param name="filter">The filter containing the entity and its components.</param>
        </member>
        <member name="M:Quantum.Asteroids.AsteroidsShipSystem.UpdateShipFire(Quantum.Frame,Quantum.Asteroids.AsteroidsShipSystem.Filter@,Quantum.Input*,Quantum.Asteroids.AsteroidsGameConfig)">
            <summary>
            Updates the firing state of the ship, handling ammunition and firing intervals.
            </summary>
            <param name="f">The game frame.</param>
            <param name="filter">The filter containing the entity and its components.</param>
            <param name="input">The input state of the player.</param>
            <param name="config">The game configuration settings.</param>
        </member>
        <member name="M:Quantum.Asteroids.AsteroidsShipSystem.UpdateShipMovement(Quantum.Frame,Quantum.Asteroids.AsteroidsShipSystem.Filter@,Quantum.Input*,Quantum.Asteroids.AsteroidsGameConfig)">
            <summary>
            Updates the movement state of the ship, handling thrust and rotation based on player input.
            </summary>
            <param name="f">The game frame.</param>
            <param name="filter">The filter containing the entity and its components.</param>
            <param name="input">The input state of the player.</param>
            <param name="config">The game configuration settings.</param>
        </member>
        <member name="M:Quantum.Asteroids.AsteroidsShipSystem.AsteroidsSpawnShip(Quantum.Frame,Quantum.EntityRef)">
            <summary>
            Spawns a new ship for the player, setting its initial position and resetting its state.
            </summary>
            <param name="f">The game frame.</param>
            <param name="shipEntity">The reference to the ship entity to be spawned.</param>
        </member>
        <member name="M:Quantum.Asteroids.AsteroidsShipSystem.AsteroidsShipDestroyed(Quantum.Frame,Quantum.EntityRef)">
            <summary>
            Handles the destruction of a ship, disabling its collider and initiating a respawn timer.
            </summary>
            <param name="f">The game frame.</param>
            <param name="shipEntity">The reference to the ship entity being destroyed.</param>
        </member>
        <member name="T:Quantum.Asteroids.AsteroidsProjectileSystem">
            <summary>
            The <c>AsteroidsProjectileSystem</c> class manages the lifecycle of projectiles,
            including updating their time-to-live (TTL) and handling projectile shooting signals.
            </summary>
        </member>
        <member name="T:Quantum.Asteroids.AsteroidsProjectileSystem.Filter">
            <summary>
            The <c>Filter</c> struct represents the components required for the system's operations,
            including an entity reference and a pointer to its projectile component.
            </summary>
        </member>
        <member name="F:Quantum.Asteroids.AsteroidsProjectileSystem.Filter.Entity">
            <summary>
            The reference to the entity being processed.
            </summary>
        </member>
        <member name="F:Quantum.Asteroids.AsteroidsProjectileSystem.Filter.Projectile">
            <summary>
            Pointer to the entity's projectile component.
            </summary>
        </member>
        <member name="M:Quantum.Asteroids.AsteroidsProjectileSystem.Update(Quantum.Frame,Quantum.Asteroids.AsteroidsProjectileSystem.Filter@)">
            <summary>
            Updates TTL of projectiles and destroying them if TTL reaches zero.
            </summary>
            <param name="f">The game frame.</param>
            <param name="filter">The filter containing the entity and its projectile component.</param>
        </member>
        <member name="M:Quantum.Asteroids.AsteroidsProjectileSystem.AsteroidsShipShoot(Quantum.Frame,Quantum.EntityRef)">
            <summary>
            Handles the shooting of a projectile by a ship. This method creates a new projectile,
            sets its initial position and velocity, and assigns it to the shooting ship.
            </summary>
            <param name="f">The game frame.</param>
            <param name="owner">The reference to the entity (ship) that is shooting the projectile.</param>
        </member>
        <member name="T:Quantum.Asteroids.AsteroidsPlayerSystem">
            <summary>
            The <c>AsteroidsPlayerSystem</c> class handles the addition of new players to the game,
            including creating and spawning their ship entities.
            </summary>
        </member>
        <member name="M:Quantum.Asteroids.AsteroidsPlayerSystem.OnPlayerAdded(Quantum.Frame,Quantum.PlayerRef,System.Boolean)">
            <summary>
            Called when a new player is added to the game. This method creates a ship entity for the player,
            sets up the player link component, and triggers the ship spawn signal.
            </summary>
            <param name="f">The game frame.</param>
            <param name="player">The reference to the player being added.</param>
            <param name="firstTime">Indicates if this is the first time the player is added.</param>
        </member>
        <member name="T:Quantum.SystemMainThreadFilter`1">
             <summary>
             This type of system uses a FilterStruct of type T to filter a set of entities based on it, 
             loop through them and calls a method.
             <para>The Any and Without virtual functions can be overwritten for more advanced filtering.</para>
             <para>If more complex options are required, inherit from SystemMainThread and iterate through the filters manually.</para>
             <para>Always register new system types on the <see cref="T:Quantum.SystemsConfig"/>.</para>
             </summary>
             <example><code>
            public unsafe class FooSystem : SystemMainThreadFilter{Foo.Filter} {
              public struct Filter {
                public EntityRef Entity;
                public Foo* FooComponent;
              }
              public override void Update(Frame f, ref Filter filter) {
                filter.FooComponent->Update(f, filter.Entity);
              }
            }
             </code></example>
             <typeparam name="T">Filter type</typeparam>
        </member>
        <member name="P:Quantum.SystemMainThreadFilter`1.UseCulling">
            <summary>
            Override to change the if the filter should exclude culled entities.
            </summary>
        </member>
        <member name="P:Quantum.SystemMainThreadFilter`1.Without">
            <summary>
            A filter to exclude components from the iteration.
            </summary>
        </member>
        <member name="P:Quantum.SystemMainThreadFilter`1.Any">
            <summary>
            A filter to include components from the iteration.
            </summary>
        </member>
        <member name="M:Quantum.SystemMainThreadFilter`1.Update(Quantum.Frame)">
            <summary>
            Internal update method, use <see cref="M:Quantum.SystemMainThreadFilter`1.Update(Quantum.Frame,`0@)"/> instead.
            </summary>
            <param name="f">The current frame.</param>
        </member>
        <member name="M:Quantum.SystemMainThreadFilter`1.Update(Quantum.Frame,`0@)">
            <summary>
            Override to add workload.
            </summary>
            <param name="f">The current frame.</param>
            <param name="filter">The frame object.</param>
        </member>
        <member name="T:Quantum.CallbackDispatcher">
            <summary>
            A subscribe and publish pattern for Quantum callbacks.
            A Quantum callback is a invocation from inside the simulation during certain situations.
            </summary>
        </member>
        <member name="M:Quantum.CallbackDispatcher.GetBuiltInTypes">
            <summary>
            Assembles a dictionary of built-in Quantum callback types.
            </summary>
            <returns>Callback mapping</returns>
        </member>
        <member name="M:Quantum.CallbackDispatcher.#ctor">
            <summary>
            Constructor calls <see cref="M:Quantum.CallbackDispatcher.GetBuiltInTypes"/>.
            </summary>
        </member>
        <member name="M:Quantum.CallbackDispatcher.#ctor(System.Collections.Generic.Dictionary{System.Type,System.Int32})">
            <summary>
            Constructor to add the callback type mapping manually.
            </summary>
            <param name="callbackTypes"></param>
        </member>
        <member name="M:Quantum.CallbackDispatcher.Publish(Quantum.CallbackBase)">
            <summary>
            Publish a callback.
            </summary>
            <param name="e"></param>
            <returns>True if the callback has been handled by any subscriber</returns>
        </member>
        <member name="F:Quantum.ShutdownCause.Ok">
            <summary>
            Expected shutdown
            </summary>
        </member>
        <member name="F:Quantum.ShutdownCause.StartFailed">
            <summary>
            Start timed out or cancelled
            </summary>
        </member>
        <member name="F:Quantum.ShutdownCause.SessionError">
            <summary>
            The session threw an exception.
            </summary>
        </member>
        <member name="F:Quantum.ShutdownCause.NetworkError">
            <summary>
            Not used.
            </summary>
        </member>
        <member name="F:Quantum.ShutdownCause.SimulationStopped">
            <summary>
            Simulation stopped. Could also be a network error.
            </summary>
        </member>
        <member name="T:Quantum.SystemMainThreadGroup">
            <summary>
            A Quantum main thread system that has a system hierarchy.
            </summary>
        </member>
        <member name="M:Quantum.SystemMainThreadGroup.#ctor(System.String,Quantum.SystemMainThread[])">
            <summary>
            Create a new system group.
            </summary>
            <param name="name">The system name.</param>
            <param name="children">The system children.</param>
        </member>
        <member name="P:Quantum.SystemMainThreadGroup.ChildSystems">
            <summary>
            Returns all child systems of this instance.
            </summary>
        </member>
        <member name="M:Quantum.SystemMainThreadGroup.Schedule(Quantum.Frame,Quantum.Task.TaskHandle)">
            <inheritdoc cref="M:Quantum.SystemMainThread.Schedule(Quantum.Frame,Quantum.Task.TaskHandle)"/>
        </member>
        <member name="M:Quantum.SystemMainThreadGroup.OnEnabled(Quantum.Frame)">
            <inheritdoc cref="M:Quantum.SystemBase.OnEnabled(Quantum.Frame)"/>
        </member>
        <member name="M:Quantum.SystemMainThreadGroup.OnDisabled(Quantum.Frame)">
            <inheritdoc cref="M:Quantum.SystemBase.OnDisabled(Quantum.Frame)"/>
        </member>
        <member name="M:Quantum.SystemMainThreadGroup.Update(Quantum.Frame)">
            <summary>
            Override to add the workload.
            </summary>
            <param name="f">The current frame.</param>
        </member>
        <member name="T:Quantum.DotNetSessionRunner">
            <summary>
            This class implements the <see cref="T:Photon.Deterministic.IDeterministicSessionRunner"/> interface and contains code to glue together the Quantum server and Quantum session runner.
            This was formerly part of the Quantum Server SDK.
            </summary>
        </member>
        <member name="P:Quantum.DotNetSessionRunner.AssetSerializer">
            <summary>
            Get and set the AssetSerializer directly after <see cref="T:Photon.Deterministic.IDeterministicSessionRunner"/> creation, until it is possible to pass it internally.
            </summary>
        </member>
        <member name="P:Quantum.DotNetSessionRunner.CustomResourceManager">
            <summary>
            Assign a custom resource manager which will use the cached static resource manager as <see cref="P:Quantum.ResourceManagerStatic.FallbackResourceManager"/>.
            Must be set right after creation.
            </summary>
        </member>
        <member name="P:Quantum.DotNetSessionRunner.Runner">
            <summary>
            Grants access to the Quantum session runner.
            </summary>
        </member>
        <member name="P:Quantum.DotNetSessionRunner.EventDispatcher">
            <summary>
            Access Quantum events.
            </summary>
        </member>
        <member name="P:Quantum.DotNetSessionRunner.CallbackDispatcher">
            <summary>
            Access Quantum callbacks.
            </summary>
        </member>
        <member name="P:Quantum.DotNetSessionRunner.OnGameResult">
            <summary>
            Callback raised on game result events from the simulation.
            </summary>
        </member>
        <member name="M:Quantum.DotNetSessionRunner.Init(Photon.Deterministic.DeterministicSessionRunnerInitArguments)">
            <summary>
            Initialized the server simulation. It initializes static classes like FPLut, Native.Utils and instantiates a static resource manager that is shared over multiple server simulations.
            This method throws exceptions on errors.
            </summary>
        </member>
        <member name="M:Quantum.DotNetSessionRunner.Shutdown">
            <summary>
            Disposes the Quantum runner.
            </summary>
        </member>
        <member name="M:Quantum.DotNetSessionRunner.Start(Photon.Deterministic.DeterministicSessionRunnerStartArguments)">
            <summary>
            Implements the start of the Quantum online session. Instantiates a Quantum runner.
            </summary>
            <param name="args">Start arguments</param>
        </member>
        <member name="M:Quantum.DotNetSessionRunner.Service(System.Double)">
            <summary>
            Implements the server update callback.
            </summary>
            <param name="gameTime">Game time in seconds</param>
        </member>
        <member name="M:Quantum.DotNetSessionRunner.TryCreateSnapshot(System.Int32@,System.Byte[]@)">
            <summary>
            Implements the server snapshot requested callback. 
            This will use the most recent simulated frame on the server to use as a snapshot for late-joining clients.
            Which will bypass requesting buddy snapshots from other clients.
            </summary>
            <param name="tick">The tick of the snapshot.</param>
            <param name="data">DeterministicFrame object serialized.</param>
            <returns>True, if the snapshot was set.</returns>
        </member>
        <member name="T:Quantum.ChecksumFile">
            <summary>
            A serializable object that contains recorded checksums for a Quantum session.
            </summary>
        </member>
        <member name="F:Quantum.ChecksumFile.GrowSize">
            <summary>
            Grow the checksum array during recording by this amount.
            </summary>
        </member>
        <member name="T:Quantum.ChecksumFile.ChecksumEntry">
            <summary>
            Represents one recorded checksum.
            </summary>
        </member>
        <member name="F:Quantum.ChecksumFile.ChecksumEntry.Frame">
            <summary>
            The frame number the checksum was recorded for.
            </summary>
        </member>
        <member name="F:Quantum.ChecksumFile.ChecksumEntry.ChecksumAsLong">
            <summary>
            Unity JSON cannot read the unsigned long data type. 
            We can convert on this level, keeping the ULong CalculateChecksum() signature and encode the 
            checksum as a long for serialization. Any other ideas?
            </summary>
        </member>
        <member name="F:Quantum.ChecksumFile.Checksums">
            <summary>
            All recorded checksums.
            </summary>
        </member>
        <member name="M:Quantum.ChecksumFile.Clone">
            <summary>
            Clone this object and discard empty checksum entries.
            </summary>
            <returns>New checksum object to save to a replay for example</returns>
        </member>
        <member name="T:Quantum.ChecksumFileHelper">
            <summary>
            Helper methods to convert between ulong and long.
            </summary>
        </member>
        <member name="M:Quantum.ChecksumFileHelper.UlongToLong(System.UInt64)">
            <summary>
            Convert a ulong to a long.
            </summary>
            <param name="value">Value to convert</param>
            <returns>Converted to long</returns>
        </member>
        <member name="M:Quantum.ChecksumFileHelper.LongToULong(System.Int64)">
            <summary>
            Reverse the conversion ulong to long.
            </summary>
            <param name="value">Value to convert back</param>
            <returns>The ulong value representaiton of a long</returns>
        </member>
        <member name="T:Quantum.Core.PlayerConnectedSystem">
            <summary>
            The Quantum core player connected system.
            It will detect changes in the <see cref="M:Photon.Deterministic.DeterministicFrame.GetPlayerInputFlags(Quantum.PlayerRef)"/> and call 
            <see cref="T:Quantum.ISignalOnPlayerConnected"/> and <see cref="T:Quantum.ISignalOnPlayerDisconnected"/> respectively.
            </summary>
        </member>
        <member name="M:Quantum.Core.PlayerConnectedSystem.Update(Quantum.Frame)">
            <summary>
            Update the player connected system.
            </summary>
            <param name="f">The frame reference.</param>
        </member>
        <member name="T:Quantum.Core.EntityPrototypeSystem">
            <summary>
            The Quantum core system that creates map entities from the map prototype.
            Switching maps will destroy all entities and create new ones.
            </summary>
        </member>
        <member name="M:Quantum.Core.EntityPrototypeSystem.OnInit(Quantum.Frame)">
            <summary>
            Create and destroy map entities of the initial map.
            </summary>
            <param name="f">The frame reference.</param>
        </member>
        <member name="M:Quantum.Core.EntityPrototypeSystem.OnMapChanged(Quantum.Frame,Quantum.AssetRef{Quantum.Map})">
            <summary>
            Destroy current map entities and create new ones from the new map.
            </summary>
            <param name="f">The frame reference.</param>
            <param name="previousMap">The previous map.</param>
        </member>
        <member name="T:Quantum.Core.CullingSystem2D">
            <summary>
            During Predicted frames, culls all <see cref="M:Quantum.Core.FrameBase.SetCullable(Quantum.EntityRef,System.Boolean)">cullable</see> entities with
            <see cref="T:Quantum.Transform2D"/> that are positioned out of the
            <see cref="M:Quantum.Core.FrameContext.SetPredictionArea(Photon.Deterministic.FPVector3,Photon.Deterministic.FP)">prediction area</see>.
            </summary>
            \ingroup Culling
        </member>
        <member name="T:Quantum.Core.CullingSystem3D">
            <summary>
            During Predicted frames, culls all <see cref="M:Quantum.Core.FrameBase.SetCullable(Quantum.EntityRef,System.Boolean)">cullable</see> entities with
            <see cref="T:Quantum.Transform3D"/> that are positioned out of the
            <see cref="M:Quantum.Core.FrameContext.SetPredictionArea(Photon.Deterministic.FPVector3,Photon.Deterministic.FP)">prediction area</see>.
            </summary>
            \ingroup Culling
        </member>
        <member name="T:Quantum.Core.PhysicsSystem2D">
            <summary>
            The Quantum core physics system.
            </summary>
        </member>
        <member name="M:Quantum.Core.PhysicsSystem2D.OnInit(Quantum.Frame)">
            <summary>
            Initializes the 2D physics system.
            </summary>
            <param name="f">The frame reference.</param>
        </member>
        <member name="M:Quantum.Core.PhysicsSystem2D.Schedule(Quantum.Frame,Quantum.Task.TaskHandle)">
            <summary>
            Create the 2D physics system update task graph.
            </summary>
            <param name="f">The frame reference.</param>
            <param name="taskHandle">The initial task handle.</param>
            <returns>The updated task handle with the physics update graph.</returns>
        </member>
        <member name="M:Quantum.Core.PhysicsSystem2D.OnCollision2D(Quantum.Core.FrameBase,Quantum.CollisionInfo2D)">
            <inheritdoc cref="M:Quantum.ISignalOnCollision2D.OnCollision2D(Quantum.Frame,Quantum.CollisionInfo2D)"/>
        </member>
        <member name="M:Quantum.Core.PhysicsSystem2D.OnCollisionEnter2D(Quantum.Core.FrameBase,Quantum.CollisionInfo2D)">
            <inheritdoc cref="M:Quantum.ISignalOnCollisionEnter2D.OnCollisionEnter2D(Quantum.Frame,Quantum.CollisionInfo2D)"/>
        </member>
        <member name="M:Quantum.Core.PhysicsSystem2D.OnCollisionExit2D(Quantum.Core.FrameBase,Quantum.ExitInfo2D)">
            <inheritdoc cref="M:Quantum.ISignalOnCollisionExit2D.OnCollisionExit2D(Quantum.Frame,Quantum.ExitInfo2D)"/>
        </member>
        <member name="M:Quantum.Core.PhysicsSystem2D.OnTrigger2D(Quantum.Core.FrameBase,Quantum.TriggerInfo2D)">
            <inheritdoc cref="M:Quantum.ISignalOnTrigger2D.OnTrigger2D(Quantum.Frame,Quantum.TriggerInfo2D)"/>
        </member>
        <member name="M:Quantum.Core.PhysicsSystem2D.OnTriggerEnter2D(Quantum.Core.FrameBase,Quantum.TriggerInfo2D)">
            <inheritdoc cref="M:Quantum.ISignalOnTriggerEnter2D.OnTriggerEnter2D(Quantum.Frame,Quantum.TriggerInfo2D)"/>
        </member>
        <member name="M:Quantum.Core.PhysicsSystem2D.OnTriggerExit2D(Quantum.Core.FrameBase,Quantum.ExitInfo2D)">
            <inheritdoc cref="M:Quantum.ISignalOnTriggerExit2D.OnTriggerExit2D(Quantum.Frame,Quantum.ExitInfo2D)"/>
        </member>
        <member name="T:Quantum.Core.PhysicsSystem3D">
            <summary>
            The Quantum 3D physics system.
            </summary>
        </member>
        <member name="M:Quantum.Core.PhysicsSystem3D.OnInit(Quantum.Frame)">
            <summary>
            Initializes the 3D physics system.
            </summary>
            <param name="f">The frame reference.</param>
        </member>
        <member name="M:Quantum.Core.PhysicsSystem3D.Schedule(Quantum.Frame,Quantum.Task.TaskHandle)">
            <summary>
            Create the 3D physics system update task graph.
            </summary>
            <param name="f">The frame reference.</param>
            <param name="taskHandle">The initial task handle.</param>
            <returns>The updated task handle with the physics update graph.</returns>
        </member>
        <member name="M:Quantum.Core.PhysicsSystem3D.OnCollision3D(Quantum.Core.FrameBase,Quantum.CollisionInfo3D)">
            <inheritdoc cref="M:Quantum.ISignalOnCollision3D.OnCollision3D(Quantum.Frame,Quantum.CollisionInfo3D)"/>
        </member>
        <member name="M:Quantum.Core.PhysicsSystem3D.OnCollisionEnter3D(Quantum.Core.FrameBase,Quantum.CollisionInfo3D)">
            <inheritdoc cref="M:Quantum.ISignalOnCollisionEnter3D.OnCollisionEnter3D(Quantum.Frame,Quantum.CollisionInfo3D)"/>
        </member>
        <member name="M:Quantum.Core.PhysicsSystem3D.OnCollisionExit3D(Quantum.Core.FrameBase,Quantum.ExitInfo3D)">
            <inheritdoc cref="M:Quantum.ISignalOnCollisionExit3D.OnCollisionExit3D(Quantum.Frame,Quantum.ExitInfo3D)"/>
        </member>
        <member name="M:Quantum.Core.PhysicsSystem3D.OnTrigger3D(Quantum.Core.FrameBase,Quantum.TriggerInfo3D)">
            <inheritdoc cref="M:Quantum.ISignalOnTrigger3D.OnTrigger3D(Quantum.Frame,Quantum.TriggerInfo3D)"/>
        </member>
        <member name="M:Quantum.Core.PhysicsSystem3D.OnTriggerEnter3D(Quantum.Core.FrameBase,Quantum.TriggerInfo3D)">
            <inheritdoc cref="M:Quantum.ISignalOnTriggerEnter3D.OnTriggerEnter3D(Quantum.Frame,Quantum.TriggerInfo3D)"/>
        </member>
        <member name="M:Quantum.Core.PhysicsSystem3D.OnTriggerExit3D(Quantum.Core.FrameBase,Quantum.ExitInfo3D)">
            <inheritdoc cref="M:Quantum.ISignalOnTriggerExit3D.OnTriggerExit3D(Quantum.Frame,Quantum.ExitInfo3D)"/>
        </member>
        <member name="T:Quantum.Core.NavigationSystem">
            <summary>
            The Quantum core navigation system.
            </summary>
        </member>
        <member name="M:Quantum.Core.NavigationSystem.Schedule(Quantum.Frame,Quantum.Task.TaskHandle)">
            <summary>
            Create the navigation system update task graph.
            </summary>
            <param name="f">The frame reference.</param>
            <param name="taskHandle">The root task handle used to create new tasks.</param>
            <returns>Updated task handle with the navigation update graph.</returns>
        </member>
        <member name="M:Quantum.Core.NavigationSystem.OnWaypointReached(Quantum.EntityRef,Photon.Deterministic.FPVector3,Quantum.Navigation.WaypointFlag,System.Boolean@)">
            <inheritdoc cref="M:Quantum.INavigationCallbacks.OnWaypointReached(Quantum.EntityRef,Photon.Deterministic.FPVector3,Quantum.Navigation.WaypointFlag,System.Boolean@)"/>
        </member>
        <member name="M:Quantum.Core.NavigationSystem.OnSearchFailed(Quantum.EntityRef,System.Boolean@)">
            <inheritdoc cref="M:Quantum.INavigationCallbacks.OnSearchFailed(Quantum.EntityRef,System.Boolean@)"/>
        </member>
        <member name="M:Quantum.Core.NavigationSystem.OnMoveAgent(Quantum.EntityRef,Photon.Deterministic.FPVector2)">
            <inheritdoc cref="M:Quantum.INavigationCallbacks.OnMoveAgent(Quantum.EntityRef,Photon.Deterministic.FPVector2)"/>
        </member>
        <member name="T:Quantum.Core.DebugCommandType">
            <summary>
            Predefined debug commands.
            </summary>
        </member>
        <member name="F:Quantum.Core.DebugCommandType.Create">
            <summary>
            Create a new entity.
            </summary>
        </member>
        <member name="F:Quantum.Core.DebugCommandType.Destroy">
            <summary>
            Destroy an entity or a component.
            </summary>
        </member>
        <member name="F:Quantum.Core.DebugCommandType.UserCommandTypeStart">
            <summary>
            Add used defined debug commands types starting from this value.
            </summary>
        </member>
        <member name="T:Quantum.Core.DebugCommand">
            <summary>
            The DebugCommand class allows to send debug commands to the simulation.
            It's used by the Quantum state inspector for example.
            The system is completely disabled in non-development builds or when defining QUANTUM_DEBUG_COMMAND_DISABLED.
            </summary>
        </member>
        <member name="E:Quantum.Core.DebugCommand.CommandExecuted">
            <summary>
            A callback Action that is invoked when a debug command was executed.
            </summary>
        </member>
        <member name="P:Quantum.Core.DebugCommand.IsEnabled">
            <summary>
            Returns true when the debug command system is enabled.
            </summary>
        </member>
        <member name="M:Quantum.Core.DebugCommand.Send(Quantum.QuantumGame,Quantum.Core.DebugCommand.Payload[])">
            <summary>
            Sends a debug command.
            </summary>
            <param name="game">The reference game.</param>
            <param name="payload">The command payloads can include multiple instances.</param>
        </member>
        <member name="M:Quantum.Core.DebugCommand.Reset">
            <summary>
            Reset the debug command system and invalidate the <see cref="E:Quantum.Core.DebugCommand.CommandExecuted"/> callback.
            </summary>
        </member>
        <member name="T:Quantum.Core.DebugCommand.Payload">
            <summary>
            The debug command payload.
            </summary>
        </member>
        <member name="F:Quantum.Core.DebugCommand.Payload.Id">
            <summary>
            The command unique id.
            </summary>
        </member>
        <member name="F:Quantum.Core.DebugCommand.Payload.Type">
            <summary>
            The <see cref="T:Quantum.Core.DebugCommandType"/>.
            </summary>
        </member>
        <member name="F:Quantum.Core.DebugCommand.Payload.Entity">
            <summary>
            The referenced entity to destroy or the created entity id.
            </summary>
        </member>
        <member name="F:Quantum.Core.DebugCommand.Payload.Components">
            <summary>
            Optionally a component set to destroy.
            </summary>
        </member>
        <member name="F:Quantum.Core.DebugCommand.Payload.Data">
            <summary>
            Serialized user data. For example entity prototype information to create a new entity.
            </summary>
        </member>
        <member name="M:Quantum.Core.DebugCommand.CreateDestroyPayload(Quantum.EntityRef)">
            <summary>
            Factory to create a destroy entity debug command payload.
            </summary>
            <param name="entityRef">Entity to destroy.</param>
            <returns>Debug command payload.</returns>
        </member>
        <member name="M:Quantum.Core.DebugCommand.CreateMaterializePayload(Quantum.EntityRef,Quantum.EntityPrototype,Quantum.IAssetSerializer)">
            <summary>
            Factory to create the payload to create a new entity from an entity prototype.
            </summary>
            <param name="entityRef">If set, then the existing entity will be overwritten, if not set a new entity will be created.</param>
            <param name="prototype">Optionally the entity prototype to use. Can be null.</param>
            <param name="serializer">The serializer.</param>
            <returns>The debug command payload.</returns>
        </member>
        <member name="M:Quantum.Core.DebugCommand.CreateRemoveComponentPayload(Quantum.EntityRef,System.Type)">
            <summary>
            Factory to create the payload to remove a component from an entity.
            </summary>
            <param name="entityRef">The entity to remove a component from.</param>
            <param name="componentType">The component type to remove.</param>
            <returns>The debug command payload.</returns>
        </member>
        <member name="T:Quantum.QuantumGame">
            <summary>
            QuantumGame acts as an interface to the simulation from the client code's perspective.
            <para>Access and method to this class is always safe from the clients point of view.</para>
            </summary>
        </member>
        <member name="E:Quantum.QuantumGame.ProfilerSampleGenerated">
            <summary>
            A callback that is invoked after the <see cref="M:Photon.Deterministic.IDeterministicGame.OnSimulate(Photon.Deterministic.DeterministicFrame)"/> callback.
            It uses the <see cref="P:Quantum.Core.FrameContext.ProfilerContext"/> to create a report.
            </summary>
        </member>
        <member name="T:Quantum.QuantumGame.FramesContainer">
            <summary>
            Stores the different frames the simulation uses during one tick.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGame.FramesContainer.Verified">
            <summary>
            Quick accessor to the forward-only verified data (simulated with confirmed inputs from server in online games). 
            Can be used as source of truth, as this does not include predicted data.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGame.FramesContainer.Predicted">
            <summary>
            Quick accessor to the latest locally predicted copy of the game state.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGame.FramesContainer.PredictedPrevious">
            <summary>
            Quick accessor to the second latest locally predicted copy of the game state.
            Used for accurate visual interpolation of transforms (or any other data) between this and the Predicted frame.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGame.FramesContainer.PreviousUpdatePredicted">
            <summary>
            Quick accessor to the latest simulated copy of the Frame that was last-Predicted during the previous main session update. 
            Used to calculate transform view error for smoothed correction.
            </summary>
        </member>
        <member name="T:Quantum.QuantumGame.ConfigurationsContainer">
            <summary>
            Stores runtime config and simulation config for this session.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGame.ConfigurationsContainer.Runtime">
            <summary>
            Runtime config finally used by the (online) simulation.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGame.ConfigurationsContainer.Simulation">
            <summary>
            Access to the simulation config used by the (online) simulation.
            </summary>
        </member>
        <member name="P:Quantum.QuantumGame.Frames">
            <summary> 
            Access the frames of various times available during one tick. 
            </summary>
        </member>
        <member name="P:Quantum.QuantumGame.Configurations">
            <summary>
            Access the configurations that the simulation is running with.
            Only set after the first CreateFrame() call.
            </summary>
        </member>
        <member name="P:Quantum.QuantumGame.Session">
            <summary> 
            Access the Deterministic session object to query more internals. 
            </summary>
        </member>
        <member name="P:Quantum.QuantumGame.InterpolationFactor">
            <summary> 
            Used for position interpolation on the client for smoother interpolation results.
            </summary>
        </member>
        <member name="P:Quantum.QuantumGame.InstantReplayConfig">
            <summary>
            Instant replay configuration, initialized by <see cref="F:Quantum.QuantumGameStartParameters.InstantReplaySettings"/>."
            </summary>
        </member>
        <member name="P:Quantum.QuantumGame.AssetSerializer">
            <summary>
            Asset serializer passed by <see cref="F:Quantum.QuantumGameStartParameters.AssetSerializer"/>.
            </summary>
        </member>
        <member name="P:Quantum.QuantumGame.ResourceManager">
            <summary>
            Resource manager passed by <see cref="F:Quantum.QuantumGameStartParameters.ResourceManager"/>.
            </summary>
        </member>
        <member name="P:Quantum.QuantumGame.HeapExtraCount">
            <summary> 
            Extra heaps to allocate for a session in case you need to create 'auxiliary' frames than actually required for the simulation itself. 
            </summary>
        </member>
        <member name="P:Quantum.QuantumGame.GameFlags">
            <summary>
            Game flags passer by <see cref="F:Quantum.QuantumGameStartParameters.GameFlags"/>.
            See <see cref="T:Quantum.QuantumGameFlags"/>.
            </summary>
        </member>
        <member name="M:Quantum.QuantumGame.#ctor(Quantum.QuantumGameStartParameters@)">
            <summary>
            Create a Quantum game instance.
            </summary>
            <param name="startParams">Start parameters.</param>
        </member>
        <member name="M:Quantum.QuantumGame.GetLocalPlayers">
            <summary>
            Returns an array that is unique on every client and represents the global player indices that the local client controls in the Quantum simulation.
            </summary>
            <returns>Array of global players this client controls.</returns>
        </member>
        <member name="M:Quantum.QuantumGame.GetLocalPlayerSlots">
            <summary>
            Returns an array that is unique on every client and represents the player slots that the local client controls in the Quantum simulation.
            </summary>
            <returns>Array of local player slots  this client controls.</returns>
        </member>
        <member name="M:Quantum.QuantumGame.PlayerIsLocal(Quantum.PlayerRef)">
            <summary>
             Helps to decide if a PlayerRef is associated with the local player.
            </summary>
            <param name="playerRef">Player reference</param>
            <returns>True if the player is the local player</returns>
        </member>
        <member name="M:Quantum.QuantumGame.SendCommand(Photon.Deterministic.DeterministicCommand)">
            <summary>
            Sends a command to the server.
            </summary>
            <param name="command">Command to send</param>
            Commands are similar to input, they drive the simulation, but do not have to be sent regularly.
            <example><code>
            RemoveUnitCommand command = new RemoveUnitCommand();
            command.CellIndex = 42;
            QuantumRunner.Default.Game.SendCommand(command);
            </code></example>
        </member>
        <member name="M:Quantum.QuantumGame.SendCommand(System.Int32,Photon.Deterministic.DeterministicCommand)">
            <summary>
            Sends a command to the server.
            </summary>
            <param name="playerSlot">Specify the local player index when you have multiple players controlled from the same machine.</param>
            <param name="command">Command to send</param>
            <para>See <see cref="M:Quantum.QuantumGame.SendCommand(Photon.Deterministic.DeterministicCommand)"/></para>
            <para>Games that only have one local player can ignore the player index field.</para>
        </member>
        <member name="M:Quantum.QuantumGame.AddPlayer(Quantum.RuntimePlayer)">
            <summary>
            Send data for the local player to join the online match.
            If the client has multiple local players, the data will be sent for the first player set.
            </summary>
            <param name="data">Player data</param>
            After starting, joining the Quantum Game and after the OnGameStart signal has been fired each player needs to call the AddPlayer method to be added as a player in every ones simulation.\n
            The reason this needs to be called explicitly is that it greatly simplifies late-joining players.
        </member>
        <member name="M:Quantum.QuantumGame.AddPlayer(System.Int32,Quantum.RuntimePlayer)">
            <summary>
            Send data for one local player to join the online match.
            </summary>
            <param name="playerSlot">Local player index</param>
            <param name="data">Player data</param>
            After starting, joining the Quantum Game and after the OnGameStart signal has been fired each player needs to call the AddPlayer method to be added as a player in every ones simulation.\n
            The reason this needs to be called explicitly is that it greatly simplifies late-joining players.
        </member>
        <member name="M:Quantum.QuantumGame.RemovePlayer">
            <summary>
            Remove the player. Assuming there is only one local player that this client controls.
            </summary>
        </member>
        <member name="M:Quantum.QuantumGame.RemovePlayer(System.Int32)">
            <summary>
            Remove a player slot from the game.
            </summary>
            <param name="playerSlot">Local player</param>
        </member>
        <member name="M:Quantum.QuantumGame.RemoveAllPlayers">
            <summary>
            Removes all players from the game and acts as a spectator.
            </summary>
        </member>
        <member name="M:Quantum.QuantumGame.OnDestroy">
            <summary>
            The game is destroyed. This is called from inside the <see cref="T:Photon.Deterministic.DeterministicSession"/>.
            </summary>
        </member>
        <member name="M:Quantum.QuantumGame.CreateFrame">
            <summary>
            Create a new frame object using the internal frame context.
            </summary>
            <returns>Frame</returns>
        </member>
        <member name="M:Quantum.QuantumGame.Photon#Deterministic#IDeterministicGame#CreateFrame(System.IDisposable)">
            <summary>
            Create a new frame object using an external context.
            </summary>
            <param name="context"></param>
            <returns>Frame</returns>
        </member>
        <member name="M:Quantum.QuantumGame.Photon#Deterministic#IDeterministicGame#CreateFrame(System.IDisposable,System.Byte[])">
            <summary>
            Create a new frame object using an external context and external frame data.
            </summary>
            <param name="context">Frame context</param>
            <param name="data">Serialized frame data</param>
            <returns>Frame</returns>
        </member>
        <member name="M:Quantum.QuantumGame.GetVerifiedFrame(System.Int32)">
            <summary>
            Tries to get the verified frame for a given tick from the snapshot buffer.
            </summary>
            <param name="tick">Tick</param>
            <returns>Verified frame based on the requested tick or null.</returns>
        </member>
        <member name="M:Quantum.QuantumGame.CreateFrameContext">
            <summary>
            Create the frame context.
            </summary>
            <returns>Frame context</returns>
            <exception cref="T:System.ArgumentException">Is raised when no <see cref="T:Quantum.SimulationConfig"/> is set inside the <see cref="T:Quantum.RuntimeConfig"/>.</exception>
        </member>
        <member name="M:Quantum.QuantumGame.SetPredictionArea(Photon.Deterministic.FPVector3,Photon.Deterministic.FP)">
            <summary>
            Set the prediction area.
            </summary>
            <param name="position">Center of the prediction area</param>
            <param name="radius">Radius of the prediction area</param>
            <para>This can be safely called from the main-thread.</para>
            <para>Prediction Culling allows developers to save CPU time in games where the player has only a partial view of the game scene.
            Quantum prediction and rollbacks, which are time consuming, will only run for important entities that are visible to the local player(s). Leaving anything outside that area to be simulated only once per tick with no rollbacks as soon as the inputs are confirmed from server.
            It is safe and simple to activate and, depending on the game, the performance difference can be quite large.Imagine a 30Hz game to constantly rollback ten ticks for every confirmed input (with more players, the predictor eventually misses at least for one of them). This requires the game simulation to be lightweight to be able to run at almost 300Hz(because of the rollbacks). With Prediction Culling enabled the full frames will be simulated at the expected 30Hz all the time while the much smaller prediction area is the only one running within the prediction buffer.</para>
        </member>
        <member name="M:Quantum.QuantumGame.SetPredictionArea(Photon.Deterministic.FPVector2,Photon.Deterministic.FP)">
            <summary>
            See <see cref="M:Quantum.QuantumGame.SetPredictionArea(Photon.Deterministic.FPVector3,Photon.Deterministic.FP)"/>.
            </summary>
            <param name="position"></param>
            <param name="radius"></param>
        </member>
        <member name="M:Quantum.QuantumGame.OnGameEnded">
            <summary>
            Not implemented.
            </summary>
        </member>
        <member name="M:Quantum.QuantumGame.OnGameStart(Photon.Deterministic.DeterministicFrame)">
            <summary>
            The callback is called when the actual simulation starts after the online protocol start sequence was successful.
            </summary>
            <param name="f">First frame</param>
        </member>
        <member name="M:Quantum.QuantumGame.OnGameResync">
            <summary>
            The callback is called when the game is starting from a snapshot after the snapshot has been received.
            </summary>
        </member>
        <member name="M:Quantum.QuantumGame.OnLocalInput(System.Int32,System.Int32)">
            <summary>
            The callback is called to poll local input.
            </summary>
            <param name="frame">Frame</param>
            <param name="playerSlot">Player slot</param>
            <returns>Polled input for this frame</returns>
        </member>
        <member name="M:Quantum.QuantumGame.OnSerializedInput(System.Byte*,System.Array)">
            <summary>
            The callback is called to serialize the game-specific input.
            </summary>
            <param name="encoded">The source input</param>
            <param name="result">The destination input</param>
        </member>
        <member name="M:Quantum.QuantumGame.OnSimulate(Photon.Deterministic.DeterministicFrame)">
            <summary>
            The callback is called when any simulation step was executed.
            </summary>
            <param name="state">Frame that was simulated</param>
        </member>
        <member name="M:Quantum.QuantumGame.OnSimulateFinished(Photon.Deterministic.DeterministicFrame)">
            <summary>
            The callback is called after any simulation step was executed and after the <see cref="M:Quantum.QuantumGame.OnSimulate(Photon.Deterministic.DeterministicFrame)"/> callback.
            </summary>
            <param name="state">Frame that was simulated</param>
        </member>
        <member name="M:Quantum.QuantumGame.OnUpdateDone">
            <summary>
            The callback is called when when the session completed its <see cref="M:Photon.Deterministic.DeterministicSession.Update(System.Nullable{System.Double})"/> loop.
            </summary>
        </member>
        <member name="M:Quantum.QuantumGame.AssignSession(Photon.Deterministic.DeterministicSession)">
            <summary>
            The <see cref="T:Photon.Deterministic.DeterministicSession"/> creates this reference during its initialization.
            </summary>
            <param name="session">Deterministic session that this game uses</param>
        </member>
        <member name="M:Quantum.QuantumGame.OnChecksumError(Photon.Deterministic.DeterministicTickChecksumError,Photon.Deterministic.DeterministicFrame[])">
            <summary>
            The callback is called when a checksum error was detected.
            </summary>
            <param name="error">Checksum error information</param>
            <param name="frames">Contains the verified frame that was failed to validate</param>
        </member>
        <member name="M:Quantum.QuantumGame.OnChecksumComputed(System.Int32,System.UInt64)">
            <summary>
            The callback is called when the local checksum was computed.
            </summary>
            <param name="frame">The frame the checksum belongs to</param>
            <param name="checksum">The checksum that will be send to the server</param>
        </member>
        <member name="M:Quantum.QuantumGame.OnSimulationBegin">
            <summary>
            The callback is called before the session computes multiple simulation steps (frames).
            </summary>
        </member>
        <member name="M:Quantum.QuantumGame.OnSimulationEnd">
            <summary>
            The callback is called when multiple simulation steps (frames) were executed.
            </summary>
        </member>
        <member name="M:Quantum.QuantumGame.OnInputConfirmed(Photon.Deterministic.DeterministicFrameInputTemp)">
            <summary>
            The callback is called when an input object was confirmed by the server.
            </summary>
            <param name="input">Input object</param>
        </member>
        <member name="M:Quantum.QuantumGame.OnInputSetConfirmed(System.Int32,System.Int32,System.Byte[])">
            <summary>
            The callback is called when an input set (all clients) was confirmed by the server.
            </summary>
            <param name="tick">Tick</param>
            <param name="length">Length of input object array</param>
            <param name="data">Input objects</param>
        </member>
        <member name="M:Quantum.QuantumGame.OnChecksumErrorFrameDump(System.Int32,System.Int32,Photon.Deterministic.DeterministicSessionConfig,System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            The callback is called when the clients receives a frame dump of another client from the server.
            </summary>
            <param name="actorId">The Photon actor id that the dump belongs to</param>
            <param name="frameNumber">The frame number of the dump</param>
            <param name="sessionConfig">The session config</param>
            <param name="runtimeConfig">The runtime config</param>
            <param name="frameData">The frame data</param>
            <param name="extraData">Extra dump meta information</param>
        </member>
        <member name="M:Quantum.QuantumGame.OnPluginDisconnect(System.String)">
            <summary>
            The callback is called when the server plugin disconnected the client.
            </summary>
            <param name="reason">Debug string</param>
        </member>
        <member name="M:Quantum.QuantumGame.OnLocalPlayerAddConfirmed(Photon.Deterministic.DeterministicFrame,System.Int32,Quantum.PlayerRef)">
            <summary>
            The callback is called when the server confirmed the addition of a (local) player.
            </summary>
            <param name="frame">The frame the player has been added</param>
            <param name="playerSlot">The player slot that was used to assign the player</param>
            <param name="player">The player</param>
        </member>
        <member name="M:Quantum.QuantumGame.OnLocalPlayerRemoveConfirmed(Photon.Deterministic.DeterministicFrame,System.Int32,Quantum.PlayerRef)">
            <summary>
            The callback is called when the server confirmed the removal of a (local) player.
            </summary>
            <param name="frame">The frame when the request was confirmed</param>
            <param name="playerSlot">The player slot of the removed player</param>
            <param name="player">The player that was removed</param>
        </member>
        <member name="M:Quantum.QuantumGame.OnLocalPlayerAddFailed(System.Int32,System.String)">
            <summary>
            The callback is called when the server failed to process the add player request.
            </summary>
            <param name="playerSlot">The player slot that was requested</param>
            <param name="message">Debug message</param>
        </member>
        <member name="M:Quantum.QuantumGame.OnLocalPlayerRemoveFailed(System.Int32,System.String)">
            <summary>
            The callback is called when the server failed to process the remove player request.
            </summary>
            <param name="playerSlot">The player slot that was tried to remove</param>
            <param name="message">Debug message</param>
        </member>
        <member name="M:Quantum.QuantumGame.GetInputInMemorySize">
            <summary>
            Return the in memory input size.
            </summary>
            <returns>Input object size</returns>
        </member>
        <member name="M:Quantum.QuantumGame.GetInputSerializedFixedSize">
            <summary>
            Returns the serialized input size.
            </summary>
            <returns>Serialized input size</returns>
        </member>
        <member name="M:Quantum.QuantumGame.DeserializeInputInto(System.Int32,System.Byte[],System.Byte*,System.Boolean)">
            <summary>
            Asks the game to de-serialize input into the buffers, because it's game specific it cannot be done from here.
            </summary>
            <param name="player">The player the input is for</param>
            <param name="data">The input data</param>
            <param name="buffer">The destination buffer</param>
            <param name="verified">Is the input verified</param>
        </member>
        <member name="M:Quantum.QuantumGame.GetExtraErrorFrameDumpData(Photon.Deterministic.DeterministicFrame)">
            <summary>
            Creates information send to the server when detecting a checksum error.
            </summary>
            <param name="frame">Frame</param>
            <returns>Serialized frame dump context</returns>
        </member>
        <member name="M:Quantum.QuantumGame.CheckTrackedHeapAllocations">
            <summary>
            Trigger the heap allocation tracker during <see cref="M:Quantum.QuantumGame.OnDestroy"/>.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">Is raised when HeapTrackingMode is unknown</exception>
        </member>
        <member name="P:Quantum.QuantumGame.EventWaitingForConfirmationCount">
            <summary>
            The number of events in the queue waiting for confirmation.
            </summary>
        </member>
        <member name="T:Quantum.QuantumGame.CallbackBase">
            <summary>
            The base class of Quantum callbacks.
            </summary>
        </member>
        <member name="P:Quantum.QuantumGame.CallbackBase.Game">
            <summary>
            The assigned game.
            </summary>
        </member>
        <member name="M:Quantum.QuantumGame.CallbackBase.#ctor(System.Int32,Quantum.QuantumGame)">
            <summary>
            Constructor.
            </summary>
            <param name="id">The const callback id.</param>
            <param name="game">The game that the callback is invoked for</param>
        </member>
        <member name="M:Quantum.QuantumGame.CallbackBase.GetCallbackType(Quantum.CallbackId)">
            <summary>
            Maps the const callback id <see cref="T:Quantum.CallbackId"/> to a callback system type.
            </summary>
            <param name="id">Callback id</param>
            <returns>System type of the associated callback</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Is raised when the id is not known</exception>
        </member>
        <member name="M:Quantum.QuantumGame.InitCallbacks">
            <summary>
            Initializes all callbacks.
            </summary>
        </member>
        <member name="P:Quantum.QuantumGame.RecordedInputs">
            <summary>
            The recorded raw inputs.
            The raw input recording automatically start when <see cref="F:Quantum.SessionRunner.Arguments.RecordingFlags"/> contains
            <see cref="F:Quantum.RecordingFlags.Input"/> and <see cref="F:Photon.Deterministic.DeterministicSessionConfig.InputDeltaCompression"/> is disabled.
            The recording can also be started by calling <see cref="M:Quantum.QuantumGame.StartRecordingInput(System.Nullable{System.Int32})"/> manually.
            </summary>
        </member>
        <member name="P:Quantum.QuantumGame.RecordedChecksums">
            <summary>
            The recorded checksums.
            The checksum recording automatically start when <see cref="F:Quantum.SessionRunner.Arguments.RecordingFlags"/> contains
            <see cref="F:Quantum.RecordingFlags.Checksums"/> and <see cref="F:Photon.Deterministic.DeterministicSessionConfig.ChecksumInterval"/> > 0.
            The recording can also be started by calling <see cref="M:Quantum.QuantumGame.StartRecordingChecksums"/> manually.
            </summary>
        </member>
        <member name="P:Quantum.QuantumGame.RecordInputStream">
            <summary>
            The recorded delta compressed input stream.
            The raw input recording automatically start when <see cref="F:Quantum.SessionRunner.Arguments.RecordingFlags"/> contains
            <see cref="F:Quantum.RecordingFlags.Input"/> and <see cref="F:Photon.Deterministic.DeterministicSessionConfig.InputDeltaCompression"/> is enabled.
            The recording can also be started by calling <see cref="M:Quantum.QuantumGame.StartRecordingInput(System.Nullable{System.Int32})"/> manually.    /// </summary>
        </member>
        <member name="M:Quantum.QuantumGame.GetInstantReplaySnapshot(System.Int32)">
            <summary>
            Get a recorded frame for a given frame number from the checksum or instant replay snapshot buffers.
            </summary>
            <param name="frame">Frame number</param>
            <returns>Frame</returns>
        </member>
        <member name="M:Quantum.QuantumGame.GetInstantReplaySnapshots(System.Int32,System.Int32,System.Collections.Generic.List{Quantum.Frame})">
            <summary>
            Get recorded frames for a given frame number window from the checksum or instant replay snapshot buffers.
            </summary>
            <param name="startFrame">Start frame</param>
            <param name="endFrame">End frame</param>
            <param name="frames">Resulting frames</param>
        </member>
        <member name="M:Quantum.QuantumGame.CreateSavegame(System.Boolean)">
            <summary>
            Create a <see cref="T:Quantum.QuantumReplayFile"/> file that represents a save game.
            </summary>
            <param name="includeDb">Include the AssetDb</param>
            <returns>Replay file to be stored</returns>
        </member>
        <member name="M:Quantum.QuantumGame.GetRecordedReplay(System.Boolean,System.Boolean,Quantum.QuantumJsonFriendlyDataBlob.Encoder,Quantum.QuantumJsonFriendlyDataBlob.Encoder,Quantum.QuantumJsonFriendlyDataBlob.Encoder)">
            <summary>
            Creates a replay file that represents a recorded replay of the complete simulation.
            Requires the <see cref="T:Quantum.RecordingFlags"/> to be set accordingly.
            </summary>
            <param name="includeChecksums">Include checksums</param>
            <param name="includeDb">Include the asset db</param>
            <param name="customAssetDbSerializer">A custom asset serializer</param>
            <param name="customRuntimeConfigSerializer">A custom runtime config serializer</param>
            <param name="customInputSerializer">A custom input serialized</param>
            <returns>Replay file to store</returns>
        </member>
        <member name="M:Quantum.QuantumGame.StartRecordingInput(System.Nullable{System.Int32})">
            <summary>
            Manually start the input recording.
            Either accessible by 
            <see cref="P:Quantum.QuantumGame.RecordedInputs"/> (if <see cref="F:Photon.Deterministic.DeterministicSessionConfig.InputDeltaCompression"/> is disabled) or
            <see cref="P:Quantum.QuantumGame.RecordInputStream"/> (if <see cref="F:Photon.Deterministic.DeterministicSessionConfig.InputDeltaCompression"/> is enabled).
            </summary>
            <param name="startFrame"></param>
        </member>
        <member name="M:Quantum.QuantumGame.StartRecordingChecksums">
            <summary>
            Manually start the recording of checksums.
            </summary>
        </member>
        <member name="M:Quantum.QuantumGame.StartVerifyingChecksums(Quantum.ChecksumFile)">
            <summary>
            Start verifying new checksums against a recorded checksum file.
            </summary>
            <param name="checksums">Recorded checksum file</param>
        </member>
        <member name="M:Quantum.QuantumGame.StartRecordingInstantReplaySnapshots">
            <summary>
            Manually start recording instant replay snapshots.
            Requires <see cref="P:Quantum.QuantumGame.InstantReplayConfig"/> to be set accordingly.
            </summary>
        </member>
        <member name="T:Quantum.RuntimeConfig">
            <summary>
            In contrast to the <see cref="F:Quantum.RuntimeConfig.SimulationConfig"/>, which has only static configuration data, the RuntimeConfig holds information that can be different from game to game.
            </summary>
            By default is defines for example what map to load and the random start seed. It is assembled from scratch each time starting a game.
            <para>Developers can add custom data to quantum_code/quantum.state/RuntimeConfig.User.cs (don't forget to fill out the serialization methods).</para>
            <para>Like the <see cref="T:Photon.Deterministic.DeterministicSessionConfig"/> this config is distributed to every other client after the first player connected and joined the Quantum plugin.</para>
            <summary>
            Partial class <c>RuntimeConfig</c> contains configuration settings for the runtime behavior of the game.
            </summary>
        </member>
        <member name="F:Quantum.RuntimeConfig.Seed">
            <summary> 
            Seed to initialize the randomization session under <see cref="P:Quantum.Frame.RNG"/>. 
            </summary>
        </member>
        <member name="F:Quantum.RuntimeConfig.Map">
            <summary> 
            Asset reference of the Quantum map used with the upcoming game session. 
            </summary>
        </member>
        <member name="F:Quantum.RuntimeConfig.SimulationConfig">
            <summary>
            Asset reference to the SimulationConfig used with the upcoming game session.
            </summary>
        </member>
        <member name="F:Quantum.RuntimeConfig.SystemsConfig">
            <summary> 
            Asset reference to the Quantum systems configuration.
            If no config is assigned then a default selection of build-in systems is used (<see cref="M:Quantum.DeterministicSystemSetup.CreateSystems(Quantum.RuntimeConfig,Quantum.SimulationConfig,Quantum.SystemsConfig)"/>.
            The systems to be used can always be changed by code inside <see cref="M:Quantum.DeterministicSystemSetup.AddSystemsUser(System.Collections.Generic.ICollection{Quantum.SystemBase},Quantum.RuntimeConfig,Quantum.SimulationConfig,Quantum.SystemsConfig)"/>.
            </summary>
        </member>
        <member name="M:Quantum.RuntimeConfig.Dump">
            <summary>
            Dump the content into a human readable form.
            </summary>
            <returns>String representation</returns>
        </member>
        <member name="F:Quantum.RuntimeConfig.GameConfig">
            <summary>
            Reference to the game configuration asset, specifying various settings for the Asteroids game.
            </summary>
        </member>
        <member name="F:Quantum.RuntimeConfig.DefaultPlayerAvatar">
            <summary>
            Reference to the default player avatar prototype to be used when creating player entities.
            </summary>
        </member>
        <member name="T:Quantum.Statics">
            <summary>
            Static type registry is completed by code generation.
            </summary>
        </member>
        <member name="M:Quantum.Statics.RegisterSimulationTypes(Quantum.TypeRegistry)">
            <summary>
            Register Quantum types. Use <see cref="M:Quantum.Statics.RegisterSimulationTypesUser(Quantum.TypeRegistry)"/> partial method to extend.
            </summary>
            <param name="typeRegistry">Type registry.</param>
        </member>
        <member name="T:Quantum.QuantumJsonFriendlyDataBlob">
            <summary>
            Wrapper around storing binary data in JSON to work around the problem that Unity JSON tools only serialize byte arrays verbosely.
            </summary>
        </member>
        <member name="F:Quantum.QuantumJsonFriendlyDataBlob.Binary">
            <summary>
            The byte array is saved as is.
            </summary>
        </member>
        <member name="F:Quantum.QuantumJsonFriendlyDataBlob.Base64">
            <summary>
            The byte array is saved as Base64 text.
            </summary>
        </member>
        <member name="F:Quantum.QuantumJsonFriendlyDataBlob.IsCompressed">
            <summary>
            Both <see cref="F:Quantum.QuantumJsonFriendlyDataBlob.Binary"/> and <see cref="F:Quantum.QuantumJsonFriendlyDataBlob.Base64"/> can be GZip compressed.
            </summary>
        </member>
        <member name="T:Quantum.QuantumJsonFriendlyDataBlob.Encoder">
            <summary>
            Used to customize encoding of this class in internal API.
            </summary>
            <param name="data">Data to encode</param>
            <returns>New instance with encoded data</returns>
        </member>
        <member name="M:Quantum.QuantumJsonFriendlyDataBlob.Decode">
            <summary>
            Decode the byte[] array.
            Based on the configuration will return the <see cref="F:Quantum.QuantumJsonFriendlyDataBlob.Binary"/> (unzipped) or the <see cref="F:Quantum.QuantumJsonFriendlyDataBlob.Base64"/> (decoded and unzipped).
            </summary>
            <returns>Decoded data</returns>
        </member>
        <member name="M:Quantum.QuantumJsonFriendlyDataBlob.Encode(System.Byte[],System.Boolean,System.Boolean)">
            <summary>
            Encode a byte[].
            </summary>
            <param name="data">The data to encode</param>
            <param name="isCompressed">Is the data GZip compressed</param>
            <param name="asBase64String">Is the data converted to base64</param>
            <returns>Encoded data object</returns>
        </member>
        <member name="T:Quantum.FrameContextUser">
            <summary>
            Use this class to extend the <see cref="T:Quantum.Core.FrameContext"/> class.
            </summary>
        </member>
        <member name="M:Quantum.FrameContextUser.#ctor(Quantum.Core.FrameContext.Args)">
            <summary>
            Frame context user constructor.
            </summary>
        </member>
        <member name="M:Quantum.FrameContextUser.Dispose">
            <summary>
            Dispose user systems and memory.
            </summary>
        </member>
        <member name="T:Quantum.RingBufferInputProvider">
            <summary>
            This input provider can store a certain amount of input sets in a ring buffer.
            </summary>
        </member>
        <member name="M:Quantum.RingBufferInputProvider.#ctor(Photon.Deterministic.DeterministicSessionConfig,System.Int32)">
            <summary>
            Create a ring buffer input provider.
            </summary>
            <param name="sessionConfig">Session config</param>
            <param name="capacity">Total capacity</param>
        </member>
        <member name="M:Quantum.RingBufferInputProvider.CanSimulate(System.Int32)">
            <summary>
            Returns true if for the given frame input is available.
            </summary>
            <param name="frame">Requested frame</param>
            <returns>True when there is input for the requested frame</returns>
        </member>
        <member name="M:Quantum.RingBufferInputProvider.#ctor(Photon.Deterministic.DeterministicTickInputSet[])">
            <summary>
            Create a ring buffer input provider from a list of input sets.
            </summary>
            <param name="inputList">Input sets</param>
        </member>
        <member name="M:Quantum.RingBufferInputProvider.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a ring buffer input provider.
            </summary>
            <param name="playerCount">Max player count</param>
            <param name="startFrame">Start frame</param>
            <param name="capacity">Ring buffer capacity</param>
        </member>
        <member name="M:Quantum.RingBufferInputProvider.Clear(System.Int32)">
            <summary>
            Clear all input sets.
            </summary>
            <param name="startFrame">New start frame</param>
        </member>
        <member name="M:Quantum.RingBufferInputProvider.OnInputConfirmed(Quantum.QuantumGame,Photon.Deterministic.DeterministicFrameInputTemp)">
            <summary>
            The callback is used to record inputs.
            </summary>
            <param name="game">Quantum game</param>
            <param name="input">The confirmed input</param>
        </member>
        <member name="M:Quantum.RingBufferInputProvider.InjectInput(Photon.Deterministic.DeterministicTickInput,System.Boolean)">
            <summary>
            Inject input into the buffer.
            </summary>
            <param name="input">Input to inject</param>
            <param name="localReplay">If set to true the sent flag will be set</param>
        </member>
        <member name="M:Quantum.RingBufferInputProvider.AddRpc(System.Int32,System.Byte[],System.Boolean)">
            <summary>
            Unused
            </summary>
        </member>
        <member name="M:Quantum.RingBufferInputProvider.GetRpc(System.Int32,System.Int32)">
            <summary>
            Read the rpc from the input.
            </summary>
            <param name="frame">Frame</param>
            <param name="player">Player</param>
            <returns>Rpc data</returns>
        </member>
        <member name="M:Quantum.RingBufferInputProvider.GetInput(System.Int32,System.Int32)">
            <summary>
            Read the input object.
            </summary>
            <param name="frame">Frame</param>
            <param name="player">Player</param>
            <returns>Input object</returns>
        </member>
        <member name="T:Quantum.SystemBase">
            <summary>
            The Quantum system base class.
            <para>Only advised for advanced uses only.</para>
            </summary>
        </member>
        <member name="P:Quantum.SystemBase.RuntimeIndex">
            <summary>
            A unique index assigned to identify systems at runtime.
            </summary>
        </member>
        <member name="P:Quantum.SystemBase.ParentSystem">
            <summary>
            The parent system in the system hierarchy.
            </summary>
        </member>
        <member name="P:Quantum.SystemBase.ChildSystems">
            <summary>
            The enumerable child systems.
            </summary>
        </member>
        <member name="P:Quantum.SystemBase.Hierarchy">
            <summary>
            Creates the complete sub graph of child systems.
            </summary>
        </member>
        <member name="P:Quantum.SystemBase.StartEnabled">
            <summary>
            Set to <see langword="true"/> when the simulation should start with this system enabled.
            </summary>
        </member>
        <member name="M:Quantum.SystemBase.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Quantum.SystemBase.#ctor(System.String)">
            <summary>
            Create a new instance and setting the sample name.
            </summary>
            <param name="scheduleSample">The name of the system to identify in the profiler.</param>
        </member>
        <member name="M:Quantum.SystemBase.OnInit(Quantum.Frame)">
            <summary>
            Is called when the system is initialized.
            </summary>
            <param name="f">The referenced frame.</param>
        </member>
        <member name="M:Quantum.SystemBase.OnEnabled(Quantum.Frame)">
            <summary>
            Is called when the system was enabled for example after calling <see cref="M:Quantum.Frame.SystemEnable``1"/> 
            or during <see cref="M:Quantum.QuantumGame.InitSystems(Photon.Deterministic.DeterministicFrame)"/>.
            </summary>
            <param name="f">The referenced frame.</param>
        </member>
        <member name="M:Quantum.SystemBase.OnDisabled(Quantum.Frame)">
            <summary>
            Is called when the system was disabled for example after <see cref="M:Quantum.Frame.SystemDisable(System.Type)"/>.
            </summary>
            <param name="f">The referenced frame.</param>
        </member>
        <member name="M:Quantum.SystemBase.OnSchedule(Quantum.Frame,Quantum.Task.TaskHandle)">
            <summary>
            Creates the task graph for the system.
            </summary>
            <param name="f">The referenced frame.</param>
            <param name="taskHandle">The initial task handle.</param>
            <returns>The system task graph.</returns>
        </member>
        <member name="M:Quantum.SystemBase.Schedule(Quantum.Frame,Quantum.Task.TaskHandle)">
            <summary>
            Override to add tasks to this system.
            </summary>
            <param name="f">The referenced frame.</param>
            <param name="taskHandle">The initial task handle.</param>
            <returns>The system task graph.</returns>
        </member>
        <member name="T:Quantum.Frame">
            <summary>
            The user implementation of <see cref="T:Quantum.Core.FrameBase"/> that resides in the project quantum_state and has access to all user relevant classes.
            </summary>
            \ingroup FrameClass
        </member>
        <member name="T:Quantum.Frame.FrameSignals">
            <summary>
            The Quantum signal API consist of core and user-defined code-generated signals.
            </summary>
        </member>
        <member name="M:Quantum.Frame.FrameSignals.#ctor(Quantum.Frame)">
            <summary>
            Constructor. Only used internally.
            </summary>
            <param name="f">The frame reference.</param>
        </member>
        <member name="M:Quantum.Frame.FrameSignals.OnPlayerAdded(Quantum.PlayerRef,System.Boolean)">
            <inheritdoc cref="M:Quantum.ISignalOnPlayerAdded.OnPlayerAdded(Quantum.Frame,Quantum.PlayerRef,System.Boolean)"/>
        </member>
        <member name="M:Quantum.Frame.FrameSignals.OnPlayerRemoved(Quantum.PlayerRef)">
            <inheritdoc cref="M:Quantum.ISignalOnPlayerRemoved.OnPlayerRemoved(Quantum.Frame,Quantum.PlayerRef)"/>
        </member>
        <member name="M:Quantum.Frame.FrameSignals.OnMapChanged(Quantum.AssetRef{Quantum.Map})">
            <inheritdoc cref="M:Quantum.ISignalOnMapChanged.OnMapChanged(Quantum.Frame,Quantum.AssetRef{Quantum.Map})"/>
        </member>
        <member name="M:Quantum.Frame.FrameSignals.OnEntityPrototypeMaterialized(Quantum.EntityRef,Quantum.EntityPrototypeRef)">
            <inheritdoc cref="M:Quantum.ISignalOnEntityPrototypeMaterialized.OnEntityPrototypeMaterialized(Quantum.Frame,Quantum.EntityRef,Quantum.EntityPrototypeRef)"/>
        </member>
        <member name="M:Quantum.Frame.FrameSignals.OnPlayerConnected(Quantum.PlayerRef)">
            <inheritdoc cref="M:Quantum.ISignalOnPlayerConnected.OnPlayerConnected(Quantum.Frame,Quantum.PlayerRef)"/>
        </member>
        <member name="M:Quantum.Frame.FrameSignals.OnPlayerDisconnected(Quantum.PlayerRef)">
            <inheritdoc cref="M:Quantum.ISignalOnPlayerDisconnected.OnPlayerDisconnected(Quantum.Frame,Quantum.PlayerRef)"/>
        </member>
        <member name="M:Quantum.Frame.FrameSignals.OnNavMeshWaypointReached(Quantum.EntityRef,Photon.Deterministic.FPVector3,Quantum.Navigation.WaypointFlag,System.Boolean@)">
            <inheritdoc cref="M:Quantum.ISignalOnNavMeshWaypointReached.OnNavMeshWaypointReached(Quantum.Frame,Quantum.EntityRef,Photon.Deterministic.FPVector3,Quantum.Navigation.WaypointFlag,System.Boolean@)"/>
        </member>
        <member name="M:Quantum.Frame.FrameSignals.OnNavMeshSearchFailed(Quantum.EntityRef,System.Boolean@)">
            <inheritdoc cref="M:Quantum.ISignalOnNavMeshSearchFailed.OnNavMeshSearchFailed(Quantum.Frame,Quantum.EntityRef,System.Boolean@)"/>
        </member>
        <member name="M:Quantum.Frame.FrameSignals.OnNavMeshMoveAgent(Quantum.EntityRef,Photon.Deterministic.FPVector2)">
            <inheritdoc cref="M:Quantum.ISignalOnNavMeshMoveAgent.OnNavMeshMoveAgent(Quantum.Frame,Quantum.EntityRef,Photon.Deterministic.FPVector2)"/>
        </member>
        <member name="M:Quantum.Frame.FrameSignals.OnCollision2D(Quantum.CollisionInfo2D)">
            <inheritdoc cref="M:Quantum.ISignalOnCollision2D.OnCollision2D(Quantum.Frame,Quantum.CollisionInfo2D)"/>
        </member>
        <member name="M:Quantum.Frame.FrameSignals.OnCollisionEnter2D(Quantum.CollisionInfo2D)">
            <inheritdoc cref="M:Quantum.ISignalOnCollisionEnter2D.OnCollisionEnter2D(Quantum.Frame,Quantum.CollisionInfo2D)"/>
        </member>
        <member name="M:Quantum.Frame.FrameSignals.OnCollisionExit2D(Quantum.ExitInfo2D)">
            <inheritdoc cref="M:Quantum.ISignalOnCollisionExit2D.OnCollisionExit2D(Quantum.Frame,Quantum.ExitInfo2D)"/>
        </member>
        <member name="M:Quantum.Frame.FrameSignals.OnTrigger2D(Quantum.TriggerInfo2D)">
            <inheritdoc cref="M:Quantum.ISignalOnTrigger2D.OnTrigger2D(Quantum.Frame,Quantum.TriggerInfo2D)"/>
        </member>
        <member name="M:Quantum.Frame.FrameSignals.OnTriggerEnter2D(Quantum.TriggerInfo2D)">
            <inheritdoc cref="M:Quantum.ISignalOnTriggerEnter2D.OnTriggerEnter2D(Quantum.Frame,Quantum.TriggerInfo2D)"/>
        </member>
        <member name="M:Quantum.Frame.FrameSignals.OnTriggerExit2D(Quantum.ExitInfo2D)">
            <inheritdoc cref="M:Quantum.ISignalOnTriggerExit2D.OnTriggerExit2D(Quantum.Frame,Quantum.ExitInfo2D)"/>
        </member>
        <member name="M:Quantum.Frame.FrameSignals.OnCollision3D(Quantum.CollisionInfo3D)">
            <inheritdoc cref="M:Quantum.ISignalOnCollision3D.OnCollision3D(Quantum.Frame,Quantum.CollisionInfo3D)"/>
        </member>
        <member name="M:Quantum.Frame.FrameSignals.OnCollisionEnter3D(Quantum.CollisionInfo3D)">
            <inheritdoc cref="M:Quantum.ISignalOnCollisionEnter3D.OnCollisionEnter3D(Quantum.Frame,Quantum.CollisionInfo3D)"/>
        </member>
        <member name="M:Quantum.Frame.FrameSignals.OnCollisionExit3D(Quantum.ExitInfo3D)">
            <inheritdoc cref="M:Quantum.ISignalOnCollisionExit3D.OnCollisionExit3D(Quantum.Frame,Quantum.ExitInfo3D)"/>
        </member>
        <member name="M:Quantum.Frame.FrameSignals.OnTrigger3D(Quantum.TriggerInfo3D)">
            <inheritdoc cref="M:Quantum.ISignalOnTrigger3D.OnTrigger3D(Quantum.Frame,Quantum.TriggerInfo3D)"/>
        </member>
        <member name="M:Quantum.Frame.FrameSignals.OnTriggerEnter3D(Quantum.TriggerInfo3D)">
            <inheritdoc cref="M:Quantum.ISignalOnTriggerEnter3D.OnTriggerEnter3D(Quantum.Frame,Quantum.TriggerInfo3D)"/>
        </member>
        <member name="M:Quantum.Frame.FrameSignals.OnTriggerExit3D(Quantum.ExitInfo3D)">
            <inheritdoc cref="M:Quantum.ISignalOnTriggerExit3D.OnTriggerExit3D(Quantum.Frame,Quantum.ExitInfo3D)"/>
        </member>
        <member name="F:Quantum.Frame.DumpFlag_NoSimulationConfig">
            <summary>
            If set the <see cref="T:Quantum.SimulationConfig"/> will not be printed in the frame dump during <see cref="M:Quantum.Frame.DumpFrame(System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Quantum.Frame.DumpFlag_NoRuntimeConfig">
            <summary>
            If set the <see cref="T:Quantum.RuntimeConfig"/> will not be printed in the frame dump during <see cref="M:Quantum.Frame.DumpFrame(System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Quantum.Frame.DumpFlag_NoDeterministicSessionConfig">
            <summary>
            If set the <see cref="T:Photon.Deterministic.DeterministicSessionConfig"/> will not be printed in the frame dump during <see cref="M:Quantum.Frame.DumpFrame(System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Quantum.Frame.DumpFlag_NoRuntimePlayers">
            <summary>
            If set the <see cref="T:Quantum.RuntimePlayer"/>s will not be printed in the frame dump during <see cref="M:Quantum.Frame.DumpFrame(System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Quantum.Frame.DumpFlag_NoDynamicDB">
            <summary>
            If set the Dynamic Asset DB will not be printed in the frame dump during <see cref="M:Quantum.Frame.DumpFrame(System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Quantum.Frame.DumpFlag_ReadableDynamicDB">
            <summary>
            If set the Dynamic Asset DB will be dumped in readable form during <see cref="M:Quantum.Frame.DumpFrame(System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Quantum.Frame.DumpFlag_PrintRawValues">
            <summary>
            If set the frame dump will print more raw values like pointers.
            </summary>
        </member>
        <member name="F:Quantum.Frame.DumpFlag_ComponentChecksums">
            <summary>
            If set the frame dump will print component checksums.
            </summary>
        </member>
        <member name="F:Quantum.Frame.DumpFlag_AssetDBCheckums">
            <summary>
            If set the frame dump will print Asset DB checksums.
            </summary>
        </member>
        <member name="F:Quantum.Frame.DumpFlag_NoIsVerified">
            <summary>
            Is set the frame dump will not print the IsVerified information.
            </summary>
        </member>
        <member name="P:Quantum.Frame.Global">
            <summary>
            Access the global read and write struct with generated variables by the Quantum DSL compiler.
            <para>Globals can be declared in any .qtn file by using the global scope.</para>
            <para>Like all things DSL-defined, global variables are part of the state and are fully compatible with the predict-rollback system.</para>
            <para>An alternative to global variables are the Singleton Components.</para>
            <example><code>
            global {
              FPVector3 Foo;
            }
            </code></example>
            </summary>
        </member>
        <member name="P:Quantum.Frame.GlobalsCore">
            <summary>
            Whether this is safe is verified at the codegen stage.
            </summary>
        </member>
        <member name="P:Quantum.Frame.RNG">
            <summary>
            The randomization session started with the seed from the <see cref="P:Quantum.Frame.RuntimeConfig"/> used to start the simulation with.
            </summary>
            <para>Supports determinism under roll-backs.</para>
            <para>If random is used in conjunction with the prediction area feature the session needs to be stored on the entities themselves.</para>
        </member>
        <member name="P:Quantum.Frame.PlayerCount">
            <summary>
            Returns the max player count that the simulation was started with <see cref="F:Photon.Deterministic.DeterministicSessionConfig.PlayerCount"/>.
            </summary>
        </member>
        <member name="P:Quantum.Frame.PlayerConnectedCount">
            <summary>
            Returns the number of players that are currently connected, requires the <see cref="T:Quantum.Core.PlayerConnectedSystem"/>.
            </summary>
        </member>
        <member name="P:Quantum.Frame.NavMeshRegionMask">
            <summary>
            Returns the global navmesh region mask that controls toggling on/off regions.
            </summary>
        </member>
        <member name="P:Quantum.Frame.FrameMetaData">
            <summary>
            Returns the frame meta data.
            </summary>
        </member>
        <member name="P:Quantum.Frame._physicsState2D">
            <summary>
            Returns the physics 2D engine state.
            </summary>
        </member>
        <member name="P:Quantum.Frame._physicsState3D">
            <summary>
            Returns the physics 3d engine state.
            </summary>
        </member>
        <member name="P:Quantum.Frame.CommitCommandsMode">
            <summary>
            Returns the mode that commands are committed to the simulation.
            </summary>
        </member>
        <member name="F:Quantum.Frame.Signals">
            <summary>
            Access the Quantum signal API.
            <para>Signals are function signatures used as a decoupled inter-system communication API similar to a publisher/subscriber API or observer pattern.</para>
            <para>Custom signals are defined in the DSL.</para>
            </summary>
        </member>
        <member name="F:Quantum.Frame.Events">
            <summary>
            Access the Quantum event API.
            <para>Events are a fine-grained solution to communicate from the simulation to the view. </para>
            <para>Events should never be used to modify/update part of the game state.</para>
            <para>Custom events are defined in the DSL.</para>
            </summary>
        </member>
        <member name="P:Quantum.Frame.Context">
            <summary>
            The frame user context
            </summary>
        </member>
        <member name="P:Quantum.Frame.RuntimeConfig">
            <summary>
            The deserialized <see cref="P:Quantum.Frame.RuntimeConfig"/> used for this session.
            </summary>
        </member>
        <member name="P:Quantum.Frame.SimulationConfig">
            <summary>
            The <see cref="P:Quantum.Frame.SimulationConfig"/> used for this session.
            </summary>
        </member>
        <member name="P:Quantum.Frame.SessionConfig">
            <summary>
            The <see cref="T:Photon.Deterministic.DeterministicSessionConfig"/> used for this session.
            </summary>
        </member>
        <member name="P:Quantum.Frame.SystemsAll">
            <summary>
            All systems running in the session.
            </summary>
        </member>
        <member name="P:Quantum.Frame.UpdateRate">
            <summary>
            See <see cref="P:Photon.Deterministic.DeterministicSession.SimulationRate"/>. This getter acquires the value from the <see cref="P:Quantum.Frame.SessionConfig"/> though.
            </summary>
        </member>
        <member name="P:Quantum.Frame.PhysicsSceneSettings">
            <summary>
            Globally access the physics settings which are taken from the <see cref="P:Quantum.Frame.SimulationConfig"/> during the Frame constructor.
            </summary>
        </member>
        <member name="P:Quantum.Frame.DeltaTime">
            <summary>
            Delta time in seconds. Can be set during run-time.
            </summary>
        </member>
        <member name="P:Quantum.Frame.Map">
            <summary>
            Retrieves the Quantum map asset. Can be set during run-time.
            <para>If assigned value is different than the current one, signal <see cref="T:Quantum.ISignalOnMapChanged"/> is raised.</para>
            </summary>
        </member>
        <member name="P:Quantum.Frame.MapAssetRef">
            <summary>
            Get or set the map asset reference. Can be set during run-time.
            <para>If assigned value is different than the current one, signal <see cref="T:Quantum.ISignalOnMapChanged"/> is raised.</para>
            </summary>
        </member>
        <member name="M:Quantum.Frame.#ctor(Quantum.Core.FrameContext,Quantum.SystemBase[],Quantum.SystemBase[],Photon.Deterministic.DeterministicSessionConfig,Quantum.RuntimeConfig,Quantum.SimulationConfig,Photon.Deterministic.FP)">
            <summary>
            Create a new frame object.
            </summary>
        </member>
        <member name="M:Quantum.Frame.SetPredictionArea(Photon.Deterministic.FPVector3,Photon.Deterministic.FP)">
            <summary>
            Set the prediction area.
            </summary>
            <param name="position">Center of the prediction area</param>
            <param name="radius">Radius of the prediction area</param>
            <para>This can be safely called from the main-thread.</para>
            <para>Prediction Culling allows developers to save CPU time in games where the player has only a partial view of the game scene.
            Quantum prediction and rollbacks, which are time consuming, will only run for important entities that are visible to the local player(s). Leaving anything outside that area to be simulated only once per tick with no rollbacks as soon as the inputs are confirmed from server.
            It is safe and simple to activate and, depending on the game, the performance difference can be quite large.Imagine a 30Hz game to constantly rollback ten ticks for every confirmed input (with more players, the predictor eventually misses at least for one of them). This requires the game simulation to be lightweight to be able to run at almost 300Hz(because of the rollbacks). With Prediction Culling enabled the full frames will be simulated at the expected 30Hz all the time while the much smaller prediction area is the only one running within the prediction buffer.</para>
        </member>
        <member name="M:Quantum.Frame.SetPredictionArea(Photon.Deterministic.FPVector2,Photon.Deterministic.FP)">
            <summary>
            See <see cref="M:Quantum.Frame.SetPredictionArea(Photon.Deterministic.FPVector3,Photon.Deterministic.FP)"/>.
            </summary>
            <param name="position"></param>
            <param name="radius"></param>
        </member>
        <member name="M:Quantum.Frame.InPredictionArea(Photon.Deterministic.FPVector3)">
            <summary>
            Test is a position is inside the prediction area.
            </summary>
            <param name="position">Position</param>
            <returns>True if the position is inside the prediction area.</returns>
        </member>
        <member name="M:Quantum.Frame.InPredictionArea(Photon.Deterministic.FPVector2)">
            <summary>
            See <see cref="M:Quantum.Frame.InPredictionArea(Photon.Deterministic.FPVector3)"/>.
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.Frame.Serialize(Photon.Deterministic.DeterministicFrameSerializeMode)">
            <summary>
            Serializes the frame using a temporary buffer (20MB).
            </summary>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="M:Quantum.Frame.Serialize(Photon.Deterministic.DeterministicFrameSerializeMode,System.Byte[],System.Int32,System.Boolean)">
            <summary>
            Serializes the frame using <paramref name="buffer"/> as a buffer for temporary data. 
            
            If <paramref name="allocOutput"/> is set to false, then <paramref name="buffer"/> is also used for the final data - use offset and count from the result to access
            the part of <paramref name="buffer"/> where serialized frame is stored.
            
            If <paramref name="allocOutput"/> is set to true then a new array is allocated for the result.
            
            Despite accepting a buffer, this method still allocates a few small temporary objects. 
            <see cref="M:Quantum.IAssetSerializer.SerializeAssets(System.IO.Stream,Quantum.AssetObject[])"/> is also going
            to allocate when serializing DynamicAssetDB, but how much depends on the serializer itself and the number of dynamic assets.
            </summary>
            <param name="mode"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="allocOutput"></param>
            <returns>Segment of <paramref name="buffer"/> where the serialized frame is stored</returns>
            <remarks>Do not serialize during GameStart callback because systems have not been initialized, yet. Rather use CallbackSimulateFinished to wait for the first update.</remarks>
        </member>
        <member name="M:Quantum.Frame.DumpFrame(System.Int32)">
            <summary>
            Dump the frame in human readable form into a string.
            </summary>
            <param name="dumpFlags">Flags to control the output for example <see cref="F:Quantum.Frame.DumpFlag_AssetDBCheckums"/>.</param>
            <returns>Frame string representation.</returns>
        </member>
        <member name="M:Quantum.Frame.CalculateChecksum">
            <summary>
            Calculates a checksum for the current game state. If the game is not started with <see cref="F:Quantum.QuantumGameFlags.DisableSharedChecksumSerializer"/> 
            flag, this method is not thread-safe, i.e. calling it from multiple threads for frames from the same simulation is going to break.
            </summary>
        </member>
        <member name="M:Quantum.Frame.CalculateChecksum(System.Boolean)">
            <summary>
            Calculates a checksum for the current game state.
            </summary>
            <param name="useSharedSerializer">True - use shared checksum serializer to avoid allocs (not thread-safe).</param>
            <returns></returns>
        </member>
        <member name="M:Quantum.Frame.Copy(Photon.Deterministic.DeterministicFrame)">
            <summary>
            Copies the complete frame memory.
            </summary>
            <param name="frame">Input frame object</param>
        </member>
        <member name="M:Quantum.Frame.SystemIsEnabledSelf``1">
            <summary>
            Test if a system is enabled.
            </summary>
            <typeparam name="T">System type</typeparam>
            <returns>True if the system is enabled</returns>
            Logs an error if the system type is not found.
        </member>
        <member name="M:Quantum.Frame.SystemEnable``1">
            <summary>
            Enable a system.
            </summary>
            <typeparam name="T">System type</typeparam>
            Logs an error if the system type is not found.
        </member>
        <member name="M:Quantum.Frame.SystemDisable``1">
            <summary>
            Disables a system.
            </summary>
            <typeparam name="T">System type</typeparam>
            Logs an error if the system type is not found.
            <example><code>
            // test for a certain asset and disable the system during its OnInit method
            public override void OnInit(Frame f) {
              var testSettings = f.FindAsset&lt;NavMeshAgentsSettings&gt;(f.Map.UserAsset.Id);
              if (testSettings == null) {
                f.SystemDisable&lt;NavMeshAgentTestSystem&gt;();
                return;
               }
               //..
             }
            </code></example>
        </member>
        <member name="M:Quantum.Frame.InitStatic">
            <summary>
            Initialized Quantum static type registry.
            </summary>
        </member>
        <member name="M:Quantum.Frame.GetPlayerData(Quantum.PlayerRef)">
            <summary>
            Gets the runtime player configuration data for a certain player.
            </summary>
            <param name="player">Player ref</param>
            <returns>Player config or null if player was not found</returns>
        </member>
        <member name="M:Quantum.Frame.PlayerToActorId(Quantum.PlayerRef)">
            <summary>
            Converts a Quantum PlayerRef to an ActorId (Photon client id).
            </summary>
            <param name="player">Player reference</param>
            <returns>ActorId or null if payer was not found</returns>
        </member>
        <member name="M:Quantum.Frame.ActorIdToFirstPlayer(System.Int32)">
            <summary>
            Returns the first player that is using a certain ActorId (Photon client id).
            </summary>
            <param name="actorId">Actor id</param>
            <returns>Player reference or null if actor id was not found</returns>
            The first player because multiple players from the same Photon client can join.
        </member>
        <member name="M:Quantum.Frame.ActorIdToAllPlayers(System.Int32)">
            <summary>
            Returns all players with a certain ActorId (Photon client id).
            </summary>
            <param name="actorId">Actor id</param>
            <returns>Array of player references</returns>
        </member>
        <member name="T:Quantum.SessionRunner">
            <summary>
            The SessionRunner helps to start, run and shutdown a Quantum simulation.
            It should never be reused for multiple simulations of multiple runs of the same game session. Always recrate the runner.
            It has an extensive list of starting <see cref="T:Quantum.SessionRunner.Arguments"/> that make it start-able for a variety of use cases: Local, Multiplayer, Replay, Server etc
            It extracts platform dependent code into the <see cref="T:Quantum.IRunnerFactory"/> parameter.
            It offers asynchronous methods to start and stop the runner but although it uses the TPL syntax for convenience it is not considered to be run in a multi-threaded environment. 
            Use the non-async versions of the methods or use a <see cref="P:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ExclusiveScheduler"/> for unit tests and console applications.
            Also never use the async methods from the Quantum server plugin, parallelization is done by the Photon-Server.
            This class is delivered in source code to enable developers to create custom runner code.
            </summary>
        </member>
        <member name="P:Quantum.SessionRunner.Session">
            <summary>
            Access the Quantum session. Will be created during the start sequence.
            </summary>
        </member>
        <member name="P:Quantum.SessionRunner.DeterministicGame">
            <summary>
            Access the Quantum game. Will be created during the start sequence. 
            </summary>
        </member>
        <member name="P:Quantum.SessionRunner.Id">
            <summary>
            Runner id, is set by <see cref="F:Quantum.SessionRunner.Arguments.RunnerId"/>.
            </summary>
        </member>
        <member name="P:Quantum.SessionRunner.IsRunning">
            <summary>
            Returns if the SessionRunner is running a simulation.
            </summary>
        </member>
        <member name="P:Quantum.SessionRunner.Communicator">
            <summary>
            Access the communicator object.
            </summary>
        </member>
        <member name="P:Quantum.SessionRunner.State">
            <summary>
            Get the current state of the runner.
            </summary>
        </member>
        <member name="P:Quantum.SessionRunner.DeltaTimeType">
            <summary>
            Will be used by the Unity runner to update the Quantum simulation with different delta time settings.
            </summary>
        </member>
        <member name="P:Quantum.SessionRunner.RecordingFlags">
            <summary>
            Access the recording flags that the runner was started with.
            </summary>
        </member>
        <member name="M:Quantum.SessionRunner.op_Implicit(Quantum.SessionRunner)~System.Boolean">
            <summary>
            Support Unity null checks.
            </summary>
            <param name="v"></param>
        </member>
        <member name="M:Quantum.SessionRunner.Dispose">
            <summary>
            Implements disposable interface. Calls Shutdown internally. 
            This is also called from inside Session.Destroy() to signal shutdown by the simulation.
            </summary>
        </member>
        <member name="M:Quantum.SessionRunner.Destroy">
            <summary>
            Calls shutdown. Backwards compatibility.
            </summary>
        </member>
        <member name="M:Quantum.SessionRunner.OnShutdown(Quantum.ShutdownCause)">
            <summary>
            Can be overridden in a subclass not be notified on shutdowns.
            Is called right after tje <see cref="F:Quantum.SessionRunner.Arguments.OnShutdown"/> callback.
            </summary>
            <param name="cause">The shutdown cause</param>
        </member>
        <member name="M:Quantum.SessionRunner.Service(System.Nullable{System.Double})">
            <summary>
            To update the Quantum simulation this needs to be run from the outside.
            From Unity is would be a MonoBehaviour, on the plugin it would be from OnDeterministicUpdate() 
            and the spectator has an extra service task to tick this.
            </summary>
            <param name="deltaTime">If null the internal stopwatch is used to update, otherwise pass in the desired delta time to progress the simulation.</param>
        </member>
        <member name="M:Quantum.SessionRunner.Start(Quantum.SessionRunner.Arguments)">
            <summary>
            Create a runner object and initiates the start procedure.
            This method returns right away and will not wait until the actual simulation is started after the start protocol and potentially waiting for a snapshot.
            Use <see cref="M:Quantum.SessionRunner.WaitForStartAsync(System.Threading.CancellationToken)"/> to get notified about the actual local game start.
            </summary>
            <param name="arguments">Start runner arguments.</param>
            <returns>Session runner object</returns>
            <exception cref="T:System.ArgumentException">Arguments were invalid, check exception message.</exception>
        </member>
        <member name="M:Quantum.SessionRunner.StartAsync(Quantum.SessionRunner.Arguments)">
            <summary>
            Async version of the start sequence. Will return the runner object once the connection is complete.
            <see cref="F:Quantum.SessionRunner.Arguments.StartGameTimeoutInSeconds"/> must be greater than 0.
            Set explicit <see cref="F:Quantum.SessionRunner.Arguments.TaskRunner"/> or the default Task.Factory is used.
            Use <see cref="F:Quantum.SessionRunner.Arguments.CancellationToken"/> to cancel this task.
            Make sure to run this from a Unity "async void" method to not lose the unhandled exceptions.
            </summary>
            <param name="arguments">Start runner arguments.</param>
            <returns>Session runner object</returns>
            <exception cref="T:System.ArgumentException">Arguments were invalid, check exception message.</exception>
            <exception cref="T:Quantum.SessionRunnerException">Session failed to start.</exception>
        </member>
        <member name="M:Quantum.SessionRunner.Shutdown(Quantum.ShutdownCause)">
            <summary>
            Shutdown the runner. 
            Can be called from inside the simulation (during a simulation callback), the shutdown will commence during the next <see cref="M:Quantum.SessionRunner.Service(System.Nullable{System.Double})"/> call.
            </summary>
            <param name="cause">Shutdown cause</param>
        </member>
        <member name="M:Quantum.SessionRunner.ShutdownAsync(Quantum.ShutdownCause)">
            <summary>
            Shutdown the runner asynchronously. 
            Can be called from a simulation callback.
            Will also wait for the connection to be properly disconnected.
            </summary>
            <param name="cause">Shutdown cause</param>
            <returns>Once the complete shutdown is completed.</returns>
            <exception cref="T:Quantum.SessionRunnerException">TaskFactory was never set.</exception>
        </member>
        <member name="M:Quantum.SessionRunner.WaitForStartAsync(System.Single)">
            <summary>
            When starting the runner synchronously this Task can be used to wait for success, error or timeout.
            </summary>
            <param name="timeoutInSeconds">Wait for game start timeout.</param>
            <returns>Returns when the start has completed or failed.</returns>
        </member>
        <member name="M:Quantum.SessionRunner.WaitForStartAsync(System.Threading.CancellationToken)">
            <summary>
            When starting the runner synchronously this Task can be used to wait for success, error or timeout.
            </summary>
            <param name="cancellationToken">Cancellation token.</param>
            <returns>Returns when the start has completed or failed.</returns>
        </member>
        <member name="M:Quantum.SessionRunner.WaitForShutdownAsync(System.Threading.CancellationToken)">
            <summary>
            Wait for the simulation shutdown is signaled. This is an alternative way to listen for the <see cref="F:Quantum.SessionRunner.Arguments.OnShutdown"/> callback.
            </summary>
            <param name="cancellationToken">Token to cancel this task</param>
            <returns>After the runner shut down.</returns>
        </member>
        <member name="M:Quantum.SessionRunner.WaitForShutdownAsync">
            <summary>
            Wait for the simulation shutdown is signaled. This is an alternative way to listen for the <see cref="F:Quantum.SessionRunner.Arguments.OnShutdown"/> callback.
            </summary>
            <returns>After the runner shut down.</returns>
        </member>
        <member name="M:Quantum.SessionRunner.CreateRunnerInternal(Quantum.SessionRunner.Arguments)">
            <summary>
            Create runner object and initiates the start procedure.
            </summary>
            <param name="arguments">Start arguments.</param>
            <returns>Initialized runner object.</returns>
        </member>
        <member name="M:Quantum.SessionRunner.ShutdownInternal(Quantum.SessionRunner,Quantum.ShutdownCause)">
            <summary>
            Internal shutdown method. 
            </summary>
            <param name="runner">Session runner object.</param>
            <param name="cause">Shutdown code.</param>
        </member>
        <member name="T:Quantum.SessionRunner.Arguments">
            <summary>
            Arguments to start an online or offline Quantum simulation.
            </summary>
        </member>
        <member name="F:Quantum.SessionRunner.Arguments.DefaultStartGameTimeoutInSeconds">
            <summary>
            The default start game timeout. Overwrite by setting explicit StartGameTimeoutInSeconds.
            </summary>
        </member>
        <member name="F:Quantum.SessionRunner.Arguments.ClientId">
            <summary>
            The Quantum ClientId is a secret between the client and the server and is used when reconnecting into a running simulation to preserve the player index.
            </summary>
        </member>
        <member name="F:Quantum.SessionRunner.Arguments.RuntimeConfig">
            <summary>
            The runtime config the Quantum game should use. Every client needs to set it, the server selects the first one send to it.
            </summary>
        </member>
        <member name="F:Quantum.SessionRunner.Arguments.SessionConfig">
            <summary>
            The deterministic config the Quantum game should use. Every client needs to set it, the server selects the first one send to it.
            </summary>
        </member>
        <member name="F:Quantum.SessionRunner.Arguments.ReplayProvider">
            <summary>
            The replay provider injects recorded inputs and rpcs into the game which is required to run the game as a replay. InputProvider is an implementation of the replay provider. See usages of QuantumGame.RecordedInputs and QuantumRunnerLocalReplay.InputProvider.
            </summary>
        </member>
        <member name="F:Quantum.SessionRunner.Arguments.GameMode">
            <summary>
            The game mode (default is Multiplayer). 
            Local mode is for testing only, the simulation is not connected online. It does not go into prediction nor does it perform rollbacks.
            Replay mode will also run offline and requires the ReplayProvider to be set to process the input.
            Spectating mode will run the simulation without a player and without the ability to input.
            </summary>
        </member>
        <member name="F:Quantum.SessionRunner.Arguments.InitialTick">
            <summary>
            The initial tick to start the simulation from as set in FrameData (only set this when FrameData is set as well). The initial frame is also encoded in the data, but required deserialization first.
            </summary>
        </member>
        <member name="P:Quantum.SessionRunner.Arguments.InitialFrame">
            <summary>
            Obsolete: use InitialTick
            </summary>
        </member>
        <member name="F:Quantum.SessionRunner.Arguments.FrameData">
            <summary>
            Serialized frame to start the simulation from. Requires InitialFrame to be set as well. This can be a reconnect or an instant replay where we already have a frame snapshot locally (QuantumInstantReplay).
            </summary>
        </member>
        <member name="F:Quantum.SessionRunner.Arguments.RunnerId">
            <summary>
            Optionally name the runner to access it from by id. This is useful when multiple runners are active on the client (for example an instant replay).
            </summary>
        </member>
        <member name="F:Quantum.SessionRunner.Arguments.PlayerCount">
            <summary>
            Setting a player count here will overwrite the <see cref="F:Quantum.SessionRunner.Arguments.SessionConfig"/>.PlayerCount during runner creation.
            Either SessionConfig.Player or this PlayerCount needs to be > 0.
            </summary>
        </member>
        <member name="F:Quantum.SessionRunner.Arguments.StartGameTimeoutInSeconds">
            <summary>
            If set it defines the timeout in seconds to wait for StartGame() to commence the online game. This includes for example sending configurations and waiting for a snapshot.
            If not set the default timeout is used defined by <see cref="F:Quantum.SessionRunner.Arguments.DefaultStartGameTimeoutInSeconds"/>.
            This value is not related to <see cref="F:Photon.Deterministic.DeterministicSessionConfig.SessionStartTimeout"/>, but it's affected by it. The SessionStartTimeout should not be larger than this value.
            Use WaitForGameStart() to manually wait for the start. Be sure to Shutdown() the runner in case of exceptions.
            </summary>
        </member>
        <member name="F:Quantum.SessionRunner.Arguments.OnShutdown">
            <summary>
            The LoadBalancingClient object needs to be connected to game sever (joined a room) when handed to Quantum. Is not required for Replay or Local game modes.
            </summary>
        </member>
        <member name="F:Quantum.SessionRunner.Arguments.Communicator">
            <summary>
            Quantum communicator which encapsulates the connection object (from Photon Realtime).
            </summary>
        </member>
        <member name="F:Quantum.SessionRunner.Arguments.RunnerFactory">
            <summary>
            Runner factory to create platform dependent objects.
            </summary>
        </member>
        <member name="F:Quantum.SessionRunner.Arguments.TaskRunner">
            <summary>
            The Quantum internal task runner.
            </summary>
        </member>
        <member name="F:Quantum.SessionRunner.Arguments.CancellationToken">
            <summary>
            A cancellation token to stop all async tasks (only used during StartAsync()).
            </summary>
        </member>
        <member name="F:Quantum.SessionRunner.Arguments.GameParameters">
            <summary>
            Encapsulated QuantumGameStartParameters.
            </summary>
        </member>
        <member name="F:Quantum.SessionRunner.Arguments.DeltaTimeType">
            <summary>
            Will be used by the Unity runner to update the Quantum simulation with different delta time settings.
            </summary>
        </member>
        <member name="F:Quantum.SessionRunner.Arguments.RecordingFlags">
            <summary>
            The recording flags will enable the recording of input and checksums (requires memory and allocations).
            When enabled QuantumGame.GetRecordedReplay can be used access the replay data.
            </summary>
        </member>
        <member name="M:Quantum.SessionRunner.Arguments.CreateDefault">
            <summary>
            Initializes struct with default values.
            </summary>
        </member>
        <member name="P:Quantum.SessionRunner.Arguments.ResourceManager">
            <summary>
            Optionally override the resource manager for example from deserialized Quantum assets (as showcased in QuantumRunnerLocalReplay).
            Will set <see cref="F:Quantum.QuantumGameStartParameters.ResourceManager"/>
            </summary>
        </member>
        <member name="P:Quantum.SessionRunner.Arguments.AssetSerializer">
            <summary>
            Will set <see cref="F:Quantum.QuantumGameStartParameters.AssetSerializer"/>
            </summary>
        </member>
        <member name="P:Quantum.SessionRunner.Arguments.CallbackDispatcher">
            <summary>
            Will set <see cref="F:Quantum.QuantumGameStartParameters.CallbackDispatcher"/>
            </summary>
        </member>
        <member name="P:Quantum.SessionRunner.Arguments.EventDispatcher">
            <summary>
            Will set <see cref="F:Quantum.QuantumGameStartParameters.EventDispatcher"/>
            </summary>
        </member>
        <member name="P:Quantum.SessionRunner.Arguments.InstantReplaySettings">
            <summary>
            The instant replay feature requires this setup data for snapshot recording.
            </summary>
        </member>
        <member name="P:Quantum.SessionRunner.Arguments.HeapExtraCount">
            <summary>
             Extra heaps to allocate for a session in case you need to create 'auxiliary' frames than actually required for the simulation itself.
             Will set <see cref="F:Quantum.QuantumGameStartParameters.HeapExtraCount"/>
            </summary>
        </member>
        <member name="P:Quantum.SessionRunner.Arguments.InitialDynamicAssets">
            <summary>
            Optionally provide assets to be added to the dynamic asset db. This can be used to introduce procedurally generated assets into the simulation from the start.
            Will set <see cref="F:Quantum.QuantumGameStartParameters.InitialDynamicAssets"/>
            </summary>
        </member>
        <member name="P:Quantum.SessionRunner.Arguments.GameFlags">
            <summary>
            GameFlags from <see cref="T:Quantum.QuantumGameFlags"/>.
            Will set <see cref="F:Quantum.QuantumGameStartParameters.GameFlags"/>.
            </summary>
        </member>
        <member name="M:Quantum.SessionRunner.Arguments.Validate">
            <summary>
             Validate, log warnings and throw exceptions on errors.
            </summary>
            <exception cref="T:Quantum.SessionRunnerException">Communicator object invalid.</exception>
        </member>
        <member name="T:Quantum.SessionRunner.SessionState">
            <summary>
            The session runner has a state machine.
            </summary>
        </member>
        <member name="F:Quantum.SessionRunner.SessionState.NotStarted">
            <summary>
            Freshly created state.
            </summary>
        </member>
        <member name="F:Quantum.SessionRunner.SessionState.Starting">
            <summary>
            The runner is starting and waiting for the start protocol to complete.
            </summary>
        </member>
        <member name="F:Quantum.SessionRunner.SessionState.Running">
            <summary>
            The simulation is running.
            </summary>
        </member>
        <member name="F:Quantum.SessionRunner.SessionState.ShuttingDown">
            <summary>
            The runner is shutting down and waiting to complete shutdown sequence.
            </summary>
        </member>
        <member name="F:Quantum.SessionRunner.SessionState.Shutdown">
            <summary>
            The runner is shutdown.
            </summary>
        </member>
        <member name="T:Quantum.DeterministicCommandSetup">
            <summary>
            A partial static class to extend by implementing the partial method <see cref="M:Quantum.DeterministicCommandSetup.AddCommandFactoriesUser(System.Collections.Generic.ICollection{Photon.Deterministic.IDeterministicCommandFactory},Quantum.RuntimeConfig,Quantum.SimulationConfig)"/>.
            It's used to create the Quantum command factories when initializing the simulation, 
            either <see cref="T:Photon.Deterministic.DeterministicCommand"/> or <see cref="T:Photon.Deterministic.DeterministicCommandPool`1"/> object.
            Only commands added here can be invoked by the simulation.
            </summary>
        </member>
        <member name="M:Quantum.DeterministicCommandSetup.GetCommandFactories(Quantum.RuntimeConfig,Quantum.SimulationConfig)">
            <summary>
            Creates a list of command factories for a Quantum simulation.
            </summary>
            <param name="gameConfig">The used RuntimeConfig</param>
            <param name="simulationConfig">The used SimulationConfig</param>
            <returns>List of command factories</returns>
        </member>
        <member name="T:Quantum.Task.SystemThreadedComponent`1">
            <summary>
            A multi-threaded system to parallelize updating components.
            <para>Threaded task: the threads will iterate over a component buffer with a size that is not known at Schedule time.
            Each thread will acquire a slice of a given (configurable) size until the end of the buffer is reached. 
            While iterating over a slice, the thread will call the Update() method that can be implemented by the inheritor system, 
            passing a FrameThreadSafe, the EntityRef and a T*.</para>
            <para>Only access to the component itself and <see cref="T:Quantum.FrameThreadSafe"/> is safe.</para>
            <para>For more information request access to the online multi-threading documentation.</para>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Quantum.Task.SystemThreadedComponent`1.DEFAULT_SLICE_SIZE">
            <summary>
            The default slide size.
            </summary>
        </member>
        <member name="P:Quantum.Task.SystemThreadedComponent`1.SliceSize">
            <inheritdoc cref="P:Quantum.Task.SystemArrayComponent`1.SlicesCount"/>
        </member>
        <member name="M:Quantum.Task.SystemThreadedComponent`1.OnInit(Quantum.Frame)">
            <inheritdoc cref="M:Quantum.Task.SystemArrayComponent`1.OnInit(Quantum.Frame)"/>
        </member>
        <member name="M:Quantum.Task.SystemThreadedComponent`1.OnInitUser(Quantum.Frame)">
            <inheritdoc cref="M:Quantum.Task.SystemArrayComponent`1.OnInitUser(Quantum.Frame)"/>
        </member>
        <member name="M:Quantum.Task.SystemThreadedComponent`1.Schedule(Quantum.Frame,Quantum.Task.TaskHandle)">
            <inheritdoc cref="M:Quantum.Task.SystemArrayComponent`1.Schedule(Quantum.Frame,Quantum.Task.TaskHandle)"/>
        </member>
        <member name="M:Quantum.Task.SystemThreadedComponent`1.Update(Quantum.FrameThreadSafe,Quantum.EntityRef,`0*)">
            <inheritdoc cref="M:Quantum.Task.SystemArrayComponent`1.Update(Quantum.FrameThreadSafe,Quantum.EntityRef,`0*)"/>
        </member>
        <member name="T:Quantum.Task.SystemArrayComponent`1">
            <summary>
            A multi-threaded system to parallelize updating components.
            <para>Only access to the component itself and <see cref="T:Quantum.FrameThreadSafe"/> is safe.</para>
            <para>Array task: similar to <see cref="T:Quantum.Task.SystemThreadedComponent`1"/>, but, instead of slicing the component buffer in N slices of a fixed size each, 
            the buffer is sliced in a fixed number of slices and the size of the slice depends on the size of the buffer, 
            which must be known in Schedule time.</para>
            <para>For more information request access to the online multi-threading documentation.</para>
            </summary>
            <typeparam name="T">Component type to update.</typeparam>
        </member>
        <member name="P:Quantum.Task.SystemArrayComponent`1.SlicesCount">
            <summary>
            Override to specify the number of slices to use.
            </summary>
        </member>
        <member name="M:Quantum.Task.SystemArrayComponent`1.OnInit(Quantum.Frame)">
            <summary>
            Initializes the system and call the virtual <see cref="M:Quantum.Task.SystemArrayComponent`1.OnInitUser(Quantum.Frame)"/> method.
            </summary>
            <param name="f">The referenced frame.</param>
        </member>
        <member name="M:Quantum.Task.SystemArrayComponent`1.OnInitUser(Quantum.Frame)">
            <summary>
            Override to initialize a custom system.
            </summary>
            <param name="f">The referenced frame.</param>
        </member>
        <member name="M:Quantum.Task.SystemArrayComponent`1.Schedule(Quantum.Frame,Quantum.Task.TaskHandle)">
            <summary>
            Override to schedule extra tasks.
            </summary>
            <param name="f">The referenced frame.</param>
            <param name="taskHandle">The initial task handle.</param>
            <returns>The updated task graph.</returns>
        </member>
        <member name="M:Quantum.Task.SystemArrayComponent`1.Update(Quantum.FrameThreadSafe,Quantum.EntityRef,`0*)">
            <summary>
            Override to add workload.
            <para>Only access to the component itself and <see cref="T:Quantum.FrameThreadSafe"/> is safe.</para>
            </summary>
            <param name="f">The thread-safe referenced frame.</param>
            <param name="entity">The entity that the component belongs to, only read access is safe.</param>
            <param name="component">The component to update.</param>
        </member>
        <member name="T:Quantum.Task.SystemThreadedFilter`1">
            <summary>
            <para>Threaded task: similar to <see cref="T:Quantum.Task.SystemThreadedComponent`1"/>, but, instead of iterating over a single component buffer, 
            the threads will iterate over a filtered component set defined by the filter struct T, 
            similarly to the <see cref="T:Quantum.SystemMainThreadFilter`1"/>.</para>
            <para>Only access to the component itself and <see cref="T:Quantum.FrameThreadSafe"/> is safe.</para>
            <para>For more information request access to the online multi-threading documentation.</para>
            </summary>
            <typeparam name="T">Filter type.</typeparam>
        </member>
        <member name="F:Quantum.Task.SystemThreadedFilter`1.DEFAULT_SLICE_SIZE">
            <summary>
            The default slide size.
            </summary>
        </member>
        <member name="P:Quantum.Task.SystemThreadedFilter`1.SliceSize">
            <inheritdoc cref="P:Quantum.Task.SystemArrayComponent`1.SlicesCount"/>
        </member>
        <member name="P:Quantum.Task.SystemThreadedFilter`1.UseCulling">
            <summary>
            Override to change the if the filter should exclude culled entities.
            </summary>
        </member>
        <member name="P:Quantum.Task.SystemThreadedFilter`1.Without">
            <summary>
            A filter to exclude components from the iteration.
            </summary>
        </member>
        <member name="P:Quantum.Task.SystemThreadedFilter`1.Any">
            <summary>
            A filter to include components from the iteration.
            </summary>
        </member>
        <member name="M:Quantum.Task.SystemThreadedFilter`1.OnInit(Quantum.Frame)">
            <inheritdoc cref="M:Quantum.Task.SystemArrayComponent`1.OnInit(Quantum.Frame)"/>
        </member>
        <member name="M:Quantum.Task.SystemThreadedFilter`1.OnInitUser(Quantum.Frame)">
            <inheritdoc cref="M:Quantum.Task.SystemArrayComponent`1.OnInitUser(Quantum.Frame)"/>
        </member>
        <member name="M:Quantum.Task.SystemThreadedFilter`1.Schedule(Quantum.Frame,Quantum.Task.TaskHandle)">
            <inheritdoc cref="M:Quantum.Task.SystemArrayComponent`1.Schedule(Quantum.Frame,Quantum.Task.TaskHandle)"/>
        </member>
        <member name="M:Quantum.Task.SystemThreadedFilter`1.Update(Quantum.FrameThreadSafe,`0@)">
            <inheritdoc cref="M:Quantum.Task.SystemArrayFilter`1.Update(Quantum.FrameThreadSafe,`0@)"/>
        </member>
        <member name="T:Quantum.Task.SystemArrayFilter`1">
            <summary>
            A multi-threaded system to parallelize updating components.
            <para>Only access to the component itself and <see cref="T:Quantum.FrameThreadSafe"/> is safe.</para>
            <para>Array task: similar to <see cref="T:Quantum.Task.SystemArrayComponent`1"/>, 
            but the threads will iterate over a filtered component set defined by the filter struct T.</para>
            <para>For more information request access to the online multi-threading documentation.</para>
            </summary>
            <typeparam name="T">Component type to update.</typeparam>
        </member>
        <member name="P:Quantum.Task.SystemArrayFilter`1.SlicesCount">
            <inheritdoc cref="P:Quantum.Task.SystemArrayComponent`1.SlicesCount"/>
        </member>
        <member name="P:Quantum.Task.SystemArrayFilter`1.UseCulling">
            <summary>
            Override to specify if the filter should use culling.
            </summary>
        </member>
        <member name="P:Quantum.Task.SystemArrayFilter`1.Without">
            <summary>
            A filter to exclude components from the iteration.
            </summary>
        </member>
        <member name="P:Quantum.Task.SystemArrayFilter`1.Any">
            <summary>
            A filter to include components from the iteration.
            </summary>
        </member>
        <member name="M:Quantum.Task.SystemArrayFilter`1.OnInit(Quantum.Frame)">
            <inheritdoc cref="M:Quantum.Task.SystemArrayComponent`1.OnInit(Quantum.Frame)"/>
        </member>
        <member name="M:Quantum.Task.SystemArrayFilter`1.OnInitUser(Quantum.Frame)">
            <inheritdoc cref="M:Quantum.Task.SystemArrayComponent`1.OnInitUser(Quantum.Frame)"/>
        </member>
        <member name="M:Quantum.Task.SystemArrayFilter`1.Schedule(Quantum.Frame,Quantum.Task.TaskHandle)">
            <inheritdoc cref="M:Quantum.Task.SystemArrayComponent`1.Schedule(Quantum.Frame,Quantum.Task.TaskHandle)"/>
        </member>
        <member name="M:Quantum.Task.SystemArrayFilter`1.Update(Quantum.FrameThreadSafe,`0@)">
            <summary>
            Override to add workload.
            <para>Only access to the component itself and <see cref="T:Quantum.FrameThreadSafe"/> is safe.</para>
            </summary>
            <param name="f">The thread-safe referenced frame.</param>
            <param name="filter">The entity filter.</param>
        </member>
        <member name="T:Quantum.QuantumInputHistoryData">
            <summary>
            Input history wrapper to used to store on replay files.
            Default way to save is DeltaCompressed in Json with compression to reduce the (Json) file size the most.
            </summary>
        </member>
        <member name="F:Quantum.QuantumInputHistoryData.DeltaCompressed">
            <summary>
            The delta compressed input history stream.
            [length as int][data as int array][len][data][len][data]..
            </summary>
        </member>
        <member name="F:Quantum.QuantumInputHistoryData.DeltaCompressedLastTick">
            <summary>
            The last tick that the delta compressed input is available for, required when <see cref="F:Quantum.QuantumInputHistoryData.DeltaCompressed"/> is used.
            </summary>
        </member>
        <member name="F:Quantum.QuantumInputHistoryData.FullLegacy">
            <summary>
            The full verbose input history. This is replaced by <see cref="F:Quantum.QuantumInputHistoryData.DeltaCompressed"/> in Quantum 3.0 but it's still functional.
            </summary>
        </member>
        <member name="T:Quantum.ChecksumErrorFrameDumpContext">
            <summary>
            Gathers additional meta data during the Quantum game callback <see cref="M:Photon.Deterministic.IDeterministicGame.GetExtraErrorFrameDumpData(Photon.Deterministic.DeterministicFrame)"/>
            in response to a checksum error.
            </summary>
        </member>
        <member name="F:Quantum.ChecksumErrorFrameDumpContext.SimulationConfig">
            <summary>
            The simulation config.
            </summary>
        </member>
        <member name="F:Quantum.ChecksumErrorFrameDumpContext.AssetDBChecksums">
            <summary>
            AssetDB checksums.
            </summary>
        </member>
        <member name="M:Quantum.ChecksumErrorFrameDumpContext.#ctor(Quantum.QuantumGame,Quantum.Frame)">
            <summary>
            Constructor.
            </summary>
            <param name="game">Game</param>
            <param name="frame">Frame</param>
        </member>
        <member name="M:Quantum.ChecksumErrorFrameDumpContext.Serialize(Quantum.QuantumGame,System.IO.BinaryWriter)">
            <summary>
            Serialize the additional meta data.
            </summary>
            <param name="game">Game</param>
            <param name="writer">Writer object</param>
        </member>
        <member name="M:Quantum.ChecksumErrorFrameDumpContext.Deserialize(Quantum.QuantumGame,System.IO.BinaryReader)">
            <summary>
            Deserialize the additional meta data.
            </summary>
            <param name="game">Game</param>
            <param name="reader">Reader object</param>
            <returns></returns>
        </member>
        <member name="T:Quantum.InactiveTaskRunner">
            <summary>
            An implementation of <see cref="T:Photon.Deterministic.IDeterministicPlatformTaskRunner"/> that forces the Quantum task system to run synchronously (single-threaded).
            </summary>
        </member>
        <member name="M:Quantum.InactiveTaskRunner.Schedule(System.Action[])">
            <summary>
            Schedules actions to be executed by the task runner.
            </summary>
            <param name="delegates">Array of actions</param>
        </member>
        <member name="M:Quantum.InactiveTaskRunner.WaitForComplete">
            <summary>
            Wait for the task runner to complete all scheduled actions.
            </summary>
        </member>
        <member name="M:Quantum.InactiveTaskRunner.PollForComplete">
            <summary>
            Poll the task runner for completion.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Quantum.InactiveTaskRunner.Dispose">
            <summary>
            Dispose the object.
            </summary>
        </member>
        <member name="P:Quantum.SessionContainer.HasGameStartTimedOut">
            <summary>
            Check this when the container reconnects into a running game and handle accordingly.
            </summary>
        </member>
        <member name="P:Quantum.SessionContainer.GameStartTimeoutInMiliseconds">
            <summary>
            Default is infinity (-1). Set this when the you expect to connect to a running game and wait for a snapshot.
            </summary>
        </member>
        <member name="M:Quantum.SessionContainer.StartReplay(Quantum.QuantumGame.StartParameters,Photon.Deterministic.IDeterministicReplayProvider,System.String,System.Boolean,Photon.Deterministic.IDeterministicPlatformTaskRunner)">
            <summary>
            Start the simulation as a replay by providing an input provider.
            </summary>
            <param name="startParams">Game start parameters</param>
            <param name="provider">Input provider</param>
            <param name="clientId">Optional client id</param>
            <param name="logInitForConsole">Optionally disable setting up the console as log output (required on the Quantum plugin)</param>
            <param name="taskRunner">Task runner</param>
        </member>
        <member name="M:Quantum.SessionContainer.StartSpectator(Quantum.QuantumGame.StartParameters,Photon.Deterministic.ICommunicator,System.Byte[],System.Int32,System.String,System.Boolean,Photon.Deterministic.IDeterministicPlatformTaskRunner)">
            <summary>
            Start the simulation as a spectator.
            </summary>
            <param name="startParams">Game start parameters</param>
            <param name="networkCommunicator">Quantum network communicator (has to have a peer that is connected to a room</param>
            <param name="frameData">Optionally the frame to start from</param>
            <param name="initialTick">The tick that the frame data is based on</param>
            <param name="clientId">Optional client id</param>
            <param name="logInitForConsole">Optionally disable setting up the console as log output (required on the Quantum plugin)</param>
            <param name="taskRunner">Task runner</param>
        </member>
        <member name="M:Quantum.SessionContainer.Start(Quantum.QuantumGame.StartParameters,Photon.Deterministic.DeterministicSessionArgs,System.String,System.Boolean,Photon.Deterministic.IDeterministicPlatformTaskRunner)">
            <summary>
            Start the simulation in a custom way.
            </summary>
            <param name="startParams">Game start parameters</param>
            <param name="sessionArgs">Game session args</param>
            <param name="clientId">Optional client id</param>
            <param name="logInitForConsole">Optionally disable setting up the console as log output (required on the Quantum plugin)</param>
            <param name="taskRunner">Task runner</param>
        </member>
        <member name="M:Quantum.SessionContainer.Service(System.Nullable{System.Double})">
            <summary>
            Update the session.
            </summary>
            <param name="dt">Optionally provide a custom delta time</param>
        </member>
        <member name="M:Quantum.SessionContainer.Destroy">
            <summary>
            Destroy the session.
            </summary>
        </member>
        <member name="M:Quantum.SessionContainer.#ctor">
            <summary>
            Use other constructors that provide the session and runtime config.
            </summary>
        </member>
        <member name="T:Quantum.ShutdownConnectionOptions">
            <summary>
            The shutdown connection options define what to do with the client Photon connection during runner shutdown.
            </summary>
        </member>
        <member name="F:Quantum.ShutdownConnectionOptions.Disconnect">
            <summary>
            Disconnect
            </summary>
        </member>
        <member name="F:Quantum.ShutdownConnectionOptions.LeaveRoom">
            <summary>
            Leave the room and connect to master server.
            </summary>
        </member>
        <member name="F:Quantum.ShutdownConnectionOptions.LeaveRoomAndBecomeInactive">
            <summary>
            Leave the room and connect to master server, but keep inactive in the room.
            </summary>
        </member>
        <member name="F:Quantum.ShutdownConnectionOptions.None">
            <summary>
            Do do anything to the connection during runner shutdown.
            </summary>
        </member>
        <member name="T:Quantum.StreamReplayInputProvider">
            <summary>
            The stream replay input provider is used to play back input from a stream.
            </summary>
        </member>
        <member name="P:Quantum.StreamReplayInputProvider.MaxFrame">
            <summary>
            The max frame that the stream has input for.
            </summary>
        </member>
        <member name="M:Quantum.StreamReplayInputProvider.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Create a stream replay input provider.
            </summary>
            <param name="inputStream">Stream to read from</param>
            <param name="maxFrame">Max frame that input is available for</param>
        </member>
        <member name="M:Quantum.StreamReplayInputProvider.Reset">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:Quantum.StreamReplayInputProvider.CanSimulate(System.Int32)">
            <summary>
            Is all input for this frame available.
            </summary>
            <param name="frame">Frame number</param>
            <returns>True if all input is available and the simulation can progress</returns>
        </member>
        <member name="M:Quantum.StreamReplayInputProvider.BeginReadFrame(System.Int32)">
            <summary>
            Request input for a certain frame.
            </summary>
            <param name="frame">The frame for the requested input</param>
            <returns>The size of the input to be read</returns>
        </member>
        <member name="M:Quantum.StreamReplayInputProvider.CompleteReadFrame(System.Int32,System.Int32,System.Byte[]@)">
            <summary>
            Read the input data for the frame.
            </summary>
            <param name="frame">The frame to read the input for</param>
            <param name="length">The input length requested in <see cref="M:Quantum.StreamReplayInputProvider.BeginReadFrame(System.Int32)"/></param>
            <param name="data">The array to copy input data to</param>
        </member>
        <member name="M:Quantum.StreamReplayInputProvider.GetInput(System.Int32,System.Int32)">
            <summary>
            Unused.
            </summary>
        </member>
        <member name="M:Quantum.StreamReplayInputProvider.AddRpc(System.Int32,System.Byte[],System.Boolean)">
            <summary>
            Unused.
            </summary>
        </member>
        <member name="M:Quantum.StreamReplayInputProvider.GetRpc(System.Int32,System.Int32)">
            <summary>
            Unused.
            </summary>
        </member>
        <member name="M:Quantum.StreamReplayInputProvider.ForwardToFrame(System.IO.Stream,System.Int32)">
            <summary>
            Skip to a selected frame in the stream.
            </summary>
            <param name="stream">Stream</param>
            <param name="frame">Frame to fast forward to</param>
        </member>
        <member name="T:Quantum.DotNetRunnerFactory">
            <summary>
            Platform dependent information and factory methods for the <see cref="T:Quantum.SessionRunner"/>.
            This implementation of the <see cref="T:Quantum.IRunnerFactory"/> is not unused in Unity but in 
            standalone Quantum applications and on the Quantum server plugin.
            </summary>
        </member>
        <member name="P:Quantum.DotNetRunnerFactory.CreatePlaformInfo">
            <summary>
            Gather the platform information.
            </summary>
        </member>
        <member name="P:Quantum.DotNetRunnerFactory.CreateTaskFactory">
            <summary>
            Create a Quantum task factory.
            </summary>
        </member>
        <member name="P:Quantum.DotNetRunnerFactory.UpdateDB">
            <summary>
            The action to when an update to the AssetDB is required. Not required.
            </summary>
        </member>
        <member name="M:Quantum.DotNetRunnerFactory.CreateGame(Quantum.QuantumGameStartParameters)">
            <summary>
            Instantiate the <see cref="T:Quantum.QuantumGame"/>.
            </summary>
            <param name="startParameters">Start parameters</param>
            <returns>Instance of IDeterministicGame</returns>
        </member>
        <member name="M:Quantum.DotNetRunnerFactory.CreateProfiler(System.String,Photon.Deterministic.DeterministicSessionConfig,Photon.Deterministic.DeterministicPlatformInfo,Photon.Deterministic.IDeterministicGame)">
            <summary>
            The callback can be used to create and attach local profiler before the Quantum simulation has been started.
            No profilers are created.
            </summary>
            <param name="clientId">Quantum client id</param>
            <param name="deterministicConfig">Session config</param>
            <param name="platformInfo">Platform info</param>
            <param name="game">Game</param>
        </member>
        <member name="M:Quantum.DotNetRunnerFactory.CreateRunner(Quantum.SessionRunner.Arguments)">
            <summary>
            Instantiate a <see cref="T:Quantum.SessionRunner"/>.
            </summary>
            <param name="arguments">Session arguments</param>
            <returns>A session runner</returns>
        </member>
        <member name="M:Quantum.DotNetRunnerFactory.CreatePlatformInfo">
            <summary>
            Static method to create platform info.
            Initializes statics <see cref="F:Photon.Deterministic.Native.Utils"/> and <see cref="F:Quantum.MemoryLayoutVerifier.Platform"/>.
            </summary>
            <returns>Platform information data</returns>
        </member>
        <member name="T:Quantum.SessionRunnerException">
            <summary>
            Runner specific exceptions.
            </summary>
        </member>
        <member name="M:Quantum.SessionRunnerException.#ctor(System.String)">
            <summary>
            Constructs a new exception with a message.
            </summary>
            <param name="message">Exception message</param>
        </member>
        <member name="F:Quantum.RuntimePlayer.PlayerAvatar">
            <summary>
            Optionally let players select an avatar prototype using RuntimePlayer. This field can be removed from RuntimePlayer if not needed.
            </summary>
        </member>
        <member name="F:Quantum.RuntimePlayer.PlayerNickname">
            <summary>
            Optionally assign a nickname to players using RuntimePlayer. This field can be removed from RuntimePlayer if not needed.
            </summary>
        </member>
        <member name="P:Quantum.Constants.FPConst">
            <summary>3.14</summary>
        </member>
        <member name="F:Quantum.Constants.Raw.FPConst">
            <summary>3.14</summary>
        </member>
        <member name="T:Quantum.DeterministicSystemSetup">
            <summary>
            Responsible for instantiating Quantum systems on simulation start.
            User systems can be added by adding a <see cref="T:Quantum.SystemsConfig"/> to the <see cref="T:Quantum.RuntimeConfig"/>.
            Or adding them in the user callback <see cref="M:Quantum.DeterministicSystemSetup.AddSystemsUser(System.Collections.Generic.ICollection{Quantum.SystemBase},Quantum.RuntimeConfig,Quantum.SimulationConfig,Quantum.SystemsConfig)"/>.
            </summary>
        </member>
        <member name="M:Quantum.DeterministicSystemSetup.CreateSystems(Quantum.RuntimeConfig,Quantum.SimulationConfig,Quantum.SystemsConfig)">
            <summary>
            The methods instantiates requested Quantum systems when starting the simulation.
            <para>
            It first tries to call the legacy system setup method (SystemSetup class), if the method is found it will return those systems on not use the provided systems config.
            </para>
            <para>
            If <paramref name="systemsConfig"/> is null only the default Quantum system are created. Otherwise the types inside <paramref name="systemsConfig"/> are created.
            </para>
            <para>
            Debug build will add the <see cref="T:Quantum.Core.DebugCommand"/> system. Disable this by defining QUANTUM_DEBUG_COMMAND_DISABLED.
            </para>
            <para>
            Finally the <see cref="M:Quantum.DeterministicSystemSetup.AddSystemsUser(System.Collections.Generic.ICollection{Quantum.SystemBase},Quantum.RuntimeConfig,Quantum.SimulationConfig,Quantum.SystemsConfig)"/> partial method is called to allow changes to the final system list.
            </para>
            </summary>
            <param name="gameConfig">Runtime config.</param>
            <param name="simulationConfig">Simulation config.</param>
            <param name="systemsConfig">List of systems to create.</param>
            <returns>Collection of Quantum system objects.</returns>
        </member>
        <member name="T:Quantum.ISignalOnPlayerAdded">
            <inheritdoc cref="M:Quantum.ISignalOnPlayerAdded.OnPlayerAdded(Quantum.Frame,Quantum.PlayerRef,System.Boolean)"/>
        </member>
        <member name="M:Quantum.ISignalOnPlayerAdded.OnPlayerAdded(Quantum.Frame,Quantum.PlayerRef,System.Boolean)">
            <summary>
            This signal is called when a player was successfully added to the simulation 
            and the server accepted the RuntimePlayer data. 
            </summary>
            <para>The signal is always called from a verified frame.</para>
            <param name="f">The frame reference.</param>
            <param name="player">The player that was added.</param>
            <param name="firstTime">The first time that this player ref was assigned to a player at all. When firstTime is false the player ref is being reused by a different player. See documentation.</param>
        </member>
        <member name="T:Quantum.ISignalOnPlayerRemoved">
            <inheritdoc cref="M:Quantum.ISignalOnPlayerRemoved.OnPlayerRemoved(Quantum.Frame,Quantum.PlayerRef)"/>/>
        </member>
        <member name="M:Quantum.ISignalOnPlayerRemoved.OnPlayerRemoved(Quantum.Frame,Quantum.PlayerRef)">
            <summary>
            This signal is called when a player was removed from the simulation after
            the InputFlags are set to <see cref="F:Photon.Deterministic.DeterministicInputFlags.PlayerNotPresent"/>.
            </summary>
            <para>The signal is always called from a verified frame.</para>
            <param name="f">The frame reference.</param>
            <param name="player">The player that was removed.</param>
        </member>
        <member name="T:Quantum.ISignalOnPlayerDataSet">
            <summary>
            Obsolete: use <see cref="T:Quantum.ISignalOnPlayerAdded"/>.
            </summary>
        </member>
        <member name="M:Quantum.ISignalOnPlayerDataSet.OnPlayerDataSet(Quantum.Frame,Quantum.PlayerRef)">
            <summary>
            Is called when a player and his RuntimePlayer was added to the simulation.
            </summary>
            <param name="f">Frame</param>
            <param name="player">Player</param>
        </member>
        <member name="T:Quantum.InputProvider">
            <summary>
            The input provider is used to push recorded inputs into the simulation.
            This class uses the full input history instead of delta compressed input stream 
            which uses a large memory footprint.
            </summary>
        </member>
        <member name="M:Quantum.InputProvider.#ctor(Photon.Deterministic.DeterministicSessionConfig,System.Int32,System.Int32)">
            <summary>
            Construct an input provider with a given capacity and grow size.
            </summary>
            <param name="config">Session config used to gather PlayerCount and RollbackWindow</param>
            <param name="capacity">The initial capacity</param>
            <param name="growSize">The grow size, 0 means doubling the buffer</param>
        </member>
        <member name="M:Quantum.InputProvider.#ctor(Photon.Deterministic.DeterministicTickInputSet[])">
            <summary>
            Construct an input provider with a given list of inputs.
            </summary>
            <param name="inputList">Input list</param>
        </member>
        <member name="M:Quantum.InputProvider.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Construct an input provider with a given player count, start frame, capacity and grow size.
            </summary>
            <param name="playerCount">Player count</param>
            <param name="startFrame">Start frame</param>
            <param name="capacity">The initial capacity</param>
            <param name="growSize">The grow size, 0 means doubling the buffer</param>
        </member>
        <member name="M:Quantum.InputProvider.CanSimulate(System.Int32)">
            <summary>
            Returns true if the input provider can simulate the given frame.
            </summary>
            <param name="frame">Requested frame</param>
            <returns>True if the input for this frame is available</returns>
        </member>
        <member name="M:Quantum.InputProvider.Clear(System.Int32)">
            <summary>
            Clear all recorded inputs. Usually called after a resync.
            </summary>
            <param name="startFrame">New start frame</param>
        </member>
        <member name="M:Quantum.InputProvider.ImportFromList(Photon.Deterministic.DeterministicTickInputSet[])">
            <summary>
            Import a list of inputs into the input provider.
            </summary>
            <param name="inputList">A reference to the imported list is internally copied.</param>
        </member>
        <member name="M:Quantum.InputProvider.ExportToList(System.Int32)">
            <summary>
            Export the inputs to a list.
            </summary>
            <param name="verifiedFrame">The max frame that in input available for</param>
            <returns>A list on inputs that can be saved to a file.</returns>
        </member>
        <member name="M:Quantum.InputProvider.OnInputConfirmed(Quantum.QuantumGame,Photon.Deterministic.DeterministicFrameInputTemp)">
            <summary>
            This callback is called when an input was confirmed and can be recorded.
            </summary>
            <param name="game">The game </param>
            <param name="input">The confirmed input</param>
        </member>
        <member name="M:Quantum.InputProvider.InjectInput(Photon.Deterministic.DeterministicTickInput,System.Boolean)">
            <summary>
            Injects a random input.
            </summary>
            <param name="input">Input to inject</param>
            <param name="localReplay">If set to true the input sent flag is set to true</param>
        </member>
        <member name="M:Quantum.InputProvider.AddRpc(System.Int32,System.Byte[],System.Boolean)">
            <summary>
            Unused.
            </summary>
        </member>
        <member name="M:Quantum.InputProvider.GetRpc(System.Int32,System.Int32)">
            <summary>
            Reads a rpc from the input provider.
            </summary>
            <param name="frame">Frame</param>
            <param name="player">Player</param>
            <returns>The rpc and a bool that is true when the rpc is a command</returns>
        </member>
        <member name="M:Quantum.InputProvider.GetInput(System.Int32,System.Int32)">
            <summary>
            Returns input for a given frame and player.
            </summary>
            <param name="frame">Requested frame</param>
            <param name="player">Requested player</param>
            <returns>Input object for that player and frame</returns>
        </member>
        <member name="T:Quantum.InputProviderExtensions">
            <summary>
            Input provider extension methods.
            </summary>
        </member>
        <member name="M:Quantum.InputProviderExtensions.CopyFrom(Photon.Deterministic.DeterministicTickInput,Photon.Deterministic.DeterministicTickInput)">
            <summary>
            Copy and clone an input data object.
            </summary>
            <param name="input">Destination input</param>
            <param name="otherInput">Source input</param>
        </member>
        <member name="M:Quantum.InputProviderExtensions.Clear(Photon.Deterministic.DeterministicTickInput)">
            <summary>
            Clear an input data object.
            </summary>
            <param name="input">Input to clear</param>
        </member>
        <member name="M:Quantum.InputProviderExtensions.Set(Photon.Deterministic.DeterministicTickInput,Photon.Deterministic.DeterministicFrameInputTemp)">
            <summary>
            Set the content of a <see cref="T:Photon.Deterministic.DeterministicTickInput"/> from a <see cref="T:Photon.Deterministic.DeterministicFrameInputTemp"/>.
            </summary>
            <param name="input">Destination input</param>
            <param name="temp">Source input</param>
        </member>
        <member name="M:Quantum.InputProviderExtensions.Clear(Photon.Deterministic.DeterministicTickInputSet)">
            <summary>
            Clear this input set.
            </summary>
            <param name="set">Input set</param>
        </member>
        <member name="M:Quantum.InputProviderExtensions.IsComplete(Photon.Deterministic.DeterministicTickInputSet)">
            <summary>
            Return true if the input set has valid input for each player.
            </summary>
            <param name="set">Input set</param>
            <returns>True if the set is complete</returns>
        </member>
        <member name="M:Quantum.InputProviderExtensions.IsFinished(Photon.Deterministic.DeterministicTickInputSet)">
            <summary>
            Return true if this set is completed and sent.
            </summary>
            <param name="set">Input set to check</param>
            <returns>True if all inputs in this set are valid and have been sent</returns>
        </member>
        <member name="T:Quantum.BitStreamReplayInputProvider">
            <summary>
            This implementation of <see cref="T:Photon.Deterministic.IDeterministicStreamReplayInputProvider"/> 
            is used to provide delta compressed input for a Quantum simulation replay from a <see cref="T:Photon.Deterministic.BitStream"/>.
            </summary>
        </member>
        <member name="P:Quantum.BitStreamReplayInputProvider.MaxFrame">
            <summary>
            The max frame available to read.
            </summary>
        </member>
        <member name="M:Quantum.BitStreamReplayInputProvider.#ctor(Photon.Deterministic.BitStream,System.Int32)">
            <summary>
            Create input provider.
            </summary>
            <param name="inputStream">The input bitstream</param>
            <param name="maxFrame">The max frame of the recorded replay</param>
        </member>
        <member name="M:Quantum.BitStreamReplayInputProvider.Reset">
            <summary>
            Reset the stream to the beginning.
            </summary>
        </member>
        <member name="M:Quantum.BitStreamReplayInputProvider.CanSimulate(System.Int32)">
            <summary>
            Returns true if for the given frame input is available.
            </summary>
            <param name="frame">Requested frame</param>
            <returns>True if input for that frame can be requested</returns>
        </member>
        <member name="M:Quantum.BitStreamReplayInputProvider.BeginReadFrame(System.Int32)">
            <summary>
            Read the size of the input from the stream.
            It is expected that the input requested matches the input order in the stream.
            </summary>
            <param name="frame">Input requested for this frame</param>
            <returns>The size of the input that can be read</returns>
        </member>
        <member name="M:Quantum.BitStreamReplayInputProvider.CompleteReadFrame(System.Int32,System.Int32,System.Byte[]@)">
            <summary>
            Actually read the input data.
            </summary>
            <param name="frame">The frame of the requested input</param>
            <param name="length">The input length returned by <see cref="M:Quantum.BitStreamReplayInputProvider.BeginReadFrame(System.Int32)"/></param>
            <param name="data">The data to be copied to</param>
        </member>
        <member name="M:Quantum.BitStreamReplayInputProvider.GetInput(System.Int32,System.Int32)">
            <summary>
            Unused.
            </summary>
        </member>
        <member name="M:Quantum.BitStreamReplayInputProvider.AddRpc(System.Int32,System.Byte[],System.Boolean)">
            <summary>
            Unused.
            </summary>
        </member>
        <member name="M:Quantum.BitStreamReplayInputProvider.GetRpc(System.Int32,System.Int32)">
            <summary>
            Unused.
            </summary>
        </member>
        <member name="T:Quantum.CallbackId">
            <summary>
            Quantum game callback ids.
            </summary>
        </member>
        <member name="F:Quantum.CallbackId.PollInput">
            <summary>
            Callback called when the simulation queries local input.
            </summary>
        </member>
        <member name="F:Quantum.CallbackId.GameInit">
            <summary>
            Callback called when the game has been started.
            </summary>
        </member>
        <member name="F:Quantum.CallbackId.GameStarted">
            <summary>
            Callback called when the game has been started.
            </summary>
        </member>
        <member name="F:Quantum.CallbackId.GameResynced">
            <summary>
            Callback called when the game has been re-synchronized from a snapshot.
            </summary>
        </member>
        <member name="F:Quantum.CallbackId.GameDestroyed">
            <summary>
            Callback called when the game was destroyed.
            </summary>
        </member>
        <member name="F:Quantum.CallbackId.UpdateView">
            <summary>
            Callback guaranteed to be called every rendered frame.
            </summary>
        </member>
        <member name="F:Quantum.CallbackId.SimulateFinished">
            <summary>
            Callback called when frame simulation has completed.
            </summary>
        </member>
        <member name="F:Quantum.CallbackId.EventCanceled">
            <summary>
            Callback called when an event raised in a predicted frame was canceled in a verified frame due to a roll-back / missed prediction.
            </summary>
        </member>
        <member name="F:Quantum.CallbackId.EventConfirmed">
            <summary>
            Callback called when an event was confirmed by a verified frame.
            </summary>
        </member>
        <member name="F:Quantum.CallbackId.ChecksumError">
            <summary>
            Callback called on a checksum error.
            </summary>
        </member>
        <member name="F:Quantum.CallbackId.ChecksumErrorFrameDump">
            <summary>
            Callback called a frame dump is received due to a checksum error.
            </summary>
        </member>
        <member name="F:Quantum.CallbackId.InputConfirmed">
            <summary>
            Callback when input was confirmed. 
            </summary>
        </member>
        <member name="F:Quantum.CallbackId.ChecksumComputed">
            <summary>
            Callback called when a checksum has been computed.
            </summary>
        </member>
        <member name="F:Quantum.CallbackId.PluginDisconnect">
            <summary>
            Callback called when the local client is disconnected by the plugin.
            </summary>
        </member>
        <member name="F:Quantum.CallbackId.PlayerAddConfirmed">
            <summary>
            Callback when a local player was successfully added to the game.
            </summary>
        </member>
        <member name="F:Quantum.CallbackId.PlayerRemoveConfirmed">
            <summary>
            Callback when a local player was successfully removed from the game.
            </summary>
        </member>
        <member name="F:Quantum.CallbackId.PlayerAddFailed">
            <summary>
            Callback when a adding a local player failed.
            </summary>
        </member>
        <member name="F:Quantum.CallbackId.PlayerRemoveFailed">
            <summary>
            Callback when removing a local player failed.
            </summary>
        </member>
        <member name="F:Quantum.CallbackId.UserCallbackIdStart">
            <summary>
            A tag where user callbacks can start.
            </summary>
        </member>
        <member name="T:Quantum.CallbackPollInput">
            <summary>
            Callback called when the simulation queries local input.
            </summary>
        </member>
        <member name="F:Quantum.CallbackPollInput.ID">
            <summary>
            The const CallbackPollInput id.
            </summary>
        </member>
        <member name="F:Quantum.CallbackPollInput.Frame">
            <summary>
            The frame number the input is polled for.
            </summary>
        </member>
        <member name="F:Quantum.CallbackPollInput.PlayerSlot">
            <summary>
            The local player slot the input is polled for (this is not the global player number).
            </summary>
        </member>
        <member name="P:Quantum.CallbackPollInput.Player">
            <summary>
            Obsolete, renamed to PlayerSlot.
            </summary>
        </member>
        <member name="M:Quantum.CallbackPollInput.SetInput(Quantum.Input,Photon.Deterministic.DeterministicInputFlags)">
            <summary>
            Set the polled input result.
            </summary>
            <param name="input">Input object</param>
            <param name="flags">Flags</param>
        </member>
        <member name="M:Quantum.CallbackPollInput.SetInput(Photon.Deterministic.QTuple{Quantum.Input,Photon.Deterministic.DeterministicInputFlags})">
            <summary>
            Set the polled input result.
            </summary>
            <param name="input">Input tuple</param>
        </member>
        <member name="P:Quantum.CallbackPollInput.IsFirstInThisUpdate">
            <summary>
            Is set to true if this is first time ever that input is pulled in this simulation.
            </summary>
        </member>
        <member name="P:Quantum.CallbackPollInput.IsInputSet">
            <summary>
            Will be marked as set after <see cref="M:Quantum.CallbackPollInput.SetInput(Quantum.Input,Photon.Deterministic.DeterministicInputFlags)"/> has been called.
            </summary>
        </member>
        <member name="P:Quantum.CallbackPollInput.Input">
            <summary>
            Access the set input. Use <see cref="M:Quantum.CallbackPollInput.SetInput(Quantum.Input,Photon.Deterministic.DeterministicInputFlags)"/> to set.
            </summary>
        </member>
        <member name="P:Quantum.CallbackPollInput.Flags">
            <summary>
            Access the input flags. Use <see cref="M:Quantum.CallbackPollInput.SetInput(Quantum.Input,Photon.Deterministic.DeterministicInputFlags)"/> to set.
            </summary>
        </member>
        <member name="T:Quantum.CallbackGameInit">
            <summary>
            Callback called when the game is about to start.
            </summary>
        </member>
        <member name="F:Quantum.CallbackGameInit.ID">
            <summary>
            The const CallbackGameInit callback id.
            </summary>
        </member>
        <member name="F:Quantum.CallbackGameInit.IsResync">
            <summary>
            Is true when the simulation is paused and waits for snapshot to commence the start.
            </summary>
        </member>
        <member name="T:Quantum.CallbackGameStarted">
            <summary>
            Is called during <see cref="M:Quantum.QuantumGame.OnGameStart(Photon.Deterministic.DeterministicFrame)"/> or <see cref="M:Quantum.QuantumGame.OnGameResync"/>
            when the game is started after systems are initialized and the snapshot has arrived for late-joining clients.
            </summary>
        </member>
        <member name="F:Quantum.CallbackGameStarted.ID">
            <summary>
            The const CallbackGameStarted callback id.
            </summary>
        </member>
        <member name="F:Quantum.CallbackGameStarted.IsResync">
            <summary>
            Is true if the game was started from a snapshot.
            </summary>
        </member>
        <member name="T:Quantum.CallbackGameResynced">
            <summary>
            Callback called when the game has been re-synchronized from a snapshot and is about to start.
            Will be followed by the <see cref="T:Quantum.CallbackGameStarted"/> callback."/>
            </summary>
        </member>
        <member name="F:Quantum.CallbackGameResynced.ID">
            <summary>
            The const CallbackGameResynced callback id.
            </summary>
        </member>
        <member name="T:Quantum.CallbackGameDestroyed">
            <summary>
            Callback called when the game was destroyed.
            </summary>
        </member>
        <member name="F:Quantum.CallbackGameDestroyed.ID">
            <summary>
            The const CallbackGameDestroyed callback id.
            </summary>
        </member>
        <member name="T:Quantum.CallbackUpdateView">
            <summary>
            Callback guaranteed to be called every rendered frame.
            </summary>
        </member>
        <member name="F:Quantum.CallbackUpdateView.ID">
            <summary>
            The const CallbackUpdateView callback id.
            </summary>
        </member>
        <member name="T:Quantum.CallbackSimulateFinished">
            <summary>
            Callback called when frame simulation has completed.
            </summary>
        </member>
        <member name="F:Quantum.CallbackSimulateFinished.ID">
            <summary>
            The const CallbackSimulateFinished callback id.
            </summary>
        </member>
        <member name="F:Quantum.CallbackSimulateFinished.Frame">
            <summary>
            The frame that was simulated.
            </summary>
        </member>
        <member name="T:Quantum.CallbackEventCanceled">
            <summary>
            Callback called when an event raised in a predicted frame was canceled in a verified frame due to a roll-back / missed prediction.
            Synchronised events are only raised on verified frames and thus will never be canceled; this is useful to graciously discard non-sync'ed events in the view.
            </summary>
        </member>
        <member name="F:Quantum.CallbackEventCanceled.ID">
            <summary>
            The const CallbackEventCanceled callback id.
            </summary>
        </member>
        <member name="F:Quantum.CallbackEventCanceled.EventKey">
            <summary>
            The event key of the event that was canceled.
            </summary>
        </member>
        <member name="T:Quantum.CallbackEventConfirmed">
            <summary>
            Callback called when an event was confirmed by a verified frame.
            </summary>
        </member>
        <member name="F:Quantum.CallbackEventConfirmed.ID">
            <summary>
            The const CallbackEventConfirmed callback id.
            </summary>
        </member>
        <member name="F:Quantum.CallbackEventConfirmed.EventKey">
            <summary>
            The event key of the event that has been verified and confirmed.
            </summary>
        </member>
        <member name="T:Quantum.CallbackChecksumError">
            <summary>
            Callback called on a checksum error.
            </summary>
        </member>
        <member name="F:Quantum.CallbackChecksumError.ID">
            <summary>
            The const CallbackChecksumError callback id.
            </summary>
        </member>
        <member name="F:Quantum.CallbackChecksumError.Error">
            <summary>
            The checksum error details.
            </summary>
        </member>
        <member name="P:Quantum.CallbackChecksumError.FrameCount">
            <summary>
            The number of frames associated with this error.
            </summary>
        </member>
        <member name="M:Quantum.CallbackChecksumError.GetFrame(System.Int32)">
            <summary>
            Access the frame by index
            </summary>
            <param name="index">Index</param>
            <returns>Frame</returns>
        </member>
        <member name="P:Quantum.CallbackChecksumError.Frames">
            <summary>
            Get all frames associated with this error.
            </summary>
        </member>
        <member name="T:Quantum.CallbackChecksumErrorFrameDump">
            <summary>
            Callback called a frame dump is received due to a checksum error.
            </summary>
        </member>
        <member name="F:Quantum.CallbackChecksumErrorFrameDump.ID">
            <summary>
            The const CallbackChecksumErrorFrameDump callback id.
            </summary>
        </member>
        <member name="F:Quantum.CallbackChecksumErrorFrameDump.ActorId">
            <summary>
            The actor id of that send this error dump.
            </summary>
        </member>
        <member name="F:Quantum.CallbackChecksumErrorFrameDump.FrameNumber">
            <summary>
            The frame number that the dump belongs to.
            </summary>
        </member>
        <member name="F:Quantum.CallbackChecksumErrorFrameDump.FrameData">
            <summary>
            The serialized frame data.
            </summary>
        </member>
        <member name="F:Quantum.CallbackChecksumErrorFrameDump.RuntimeConfigBytes">
            <summary>
            The serialized runtime config.
            </summary>
        </member>
        <member name="F:Quantum.CallbackChecksumErrorFrameDump.ExtraBytes">
            <summary>
            The serialized extra meta information added to the frame dump.
            </summary>
        </member>
        <member name="F:Quantum.CallbackChecksumErrorFrameDump.SessionConfig">
            <summary>
            The session config.
            </summary>
        </member>
        <member name="F:Quantum.CallbackChecksumErrorFrameDump.Serializer">
            <summary>
            The asset serializer.
            </summary>
        </member>
        <member name="P:Quantum.CallbackChecksumErrorFrameDump.Frame">
            <summary>
            Deserialize the frame dump.
            </summary>
        </member>
        <member name="P:Quantum.CallbackChecksumErrorFrameDump.FrameDump">
            <summary>
            The frame dump as a string.
            </summary>
        </member>
        <member name="P:Quantum.CallbackChecksumErrorFrameDump.RuntimeConfig">
            <summary>
            Deserializes the runtime config.
            </summary>
        </member>
        <member name="P:Quantum.CallbackChecksumErrorFrameDump.SimulationConfig">
            <summary>
            Access the simulation config.
            </summary>
        </member>
        <member name="P:Quantum.CallbackChecksumErrorFrameDump.Context">
            <summary>
            Deserialize the frame dump context.
            </summary>
        </member>
        <member name="T:Quantum.CallbackInputConfirmed">
            <summary>
            Callback when input was confirmed.
            </summary>
        </member>
        <member name="F:Quantum.CallbackInputConfirmed.ID">
            <summary>
            The const CallbackInputConfirmed callback id.
            </summary>
        </member>
        <member name="F:Quantum.CallbackInputConfirmed.Input">
            <summary>
            The verified input object.
            </summary>
        </member>
        <member name="T:Quantum.CallbackChecksumComputed">
            <summary>
            Callback called when a checksum has been computed.
            </summary>
        </member>
        <member name="F:Quantum.CallbackChecksumComputed.ID">
            <summary>
            The const CallbackChecksumComputed callback id.
            </summary>
        </member>
        <member name="F:Quantum.CallbackChecksumComputed.Frame">
            <summary>
            The frame number the checksum was computed for.
            </summary>
        </member>
        <member name="F:Quantum.CallbackChecksumComputed.Checksum">
            <summary>
            The checksum value.
            </summary>
        </member>
        <member name="T:Quantum.CallbackPluginDisconnect">
            <summary>
            Callback called when the local client is disconnected by the plugin.
            </summary>
        </member>
        <member name="F:Quantum.CallbackPluginDisconnect.ID">
            <summary>
            The const CallbackPluginDisconnect callback id.
            </summary>
        </member>
        <member name="F:Quantum.CallbackPluginDisconnect.Reason">
            <summary>
            Debug string of the disconnect reason.
            </summary>
        </member>
        <member name="T:Quantum.CallbackLocalPlayerAddConfirmed">
            <summary>
            Callback when a local player was successfully added to the game.
            </summary>
        </member>
        <member name="F:Quantum.CallbackLocalPlayerAddConfirmed.ID">
            <summary>
            The const CallbackLocalPlayerAddConfirmed callback id.
            </summary>
        </member>
        <member name="F:Quantum.CallbackLocalPlayerAddConfirmed.Frame">
            <summary>
            The frame the player was added.
            </summary>
        </member>
        <member name="F:Quantum.CallbackLocalPlayerAddConfirmed.PlayerSlot">
            <summary>
            The local player index.
            </summary>
        </member>
        <member name="F:Quantum.CallbackLocalPlayerAddConfirmed.Player">
            <summary>
            The global player number.
            </summary>
        </member>
        <member name="T:Quantum.CallbackLocalPlayerRemoveConfirmed">
            <summary>
            Callback when a local player was successfully removed from the game.
            </summary>
        </member>
        <member name="F:Quantum.CallbackLocalPlayerRemoveConfirmed.ID">
            <summary>
            The const CallbackLocalPlayerRemoveConfirmed callback id.
            </summary>
        </member>
        <member name="F:Quantum.CallbackLocalPlayerRemoveConfirmed.Frame">
            <summary>
            The frame the player was removed.
            </summary>
        </member>
        <member name="F:Quantum.CallbackLocalPlayerRemoveConfirmed.PlayerSlot">
            <summary>
            The local player slot that was removed.
            </summary>
        </member>
        <member name="F:Quantum.CallbackLocalPlayerRemoveConfirmed.Player">
            <summary>
            The global player number that was removed.
            </summary>
        </member>
        <member name="T:Quantum.CallbackLocalPlayerAddFailed">
            <summary>
            Callback when a adding a local player failed.
            </summary>
        </member>
        <member name="F:Quantum.CallbackLocalPlayerAddFailed.ID">
            <summary>
            The const CallbackLocalPlayerAddFailed callback id.
            </summary>
        </member>
        <member name="F:Quantum.CallbackLocalPlayerAddFailed.PlayerSlot">
            <summary>
            The player slot that was tried to be added and failed.
            </summary>
        </member>
        <member name="F:Quantum.CallbackLocalPlayerAddFailed.Message">
            <summary>
            The error debug message.
            </summary>
        </member>
        <member name="T:Quantum.CallbackLocalPlayerRemoveFailed">
            <summary>
            Callback when removing a local player failed.
            </summary>
        </member>
        <member name="F:Quantum.CallbackLocalPlayerRemoveFailed.ID">
            <summary>
            The const CallbackLocalPlayerRemoveFailed callback id.
            </summary>
        </member>
        <member name="F:Quantum.CallbackLocalPlayerRemoveFailed.PlayerSlot">
            <summary>
            The local player slot that was tried to be removed and failed.
            </summary>
        </member>
        <member name="F:Quantum.CallbackLocalPlayerRemoveFailed.Message">
            <summary>
            The error debug message.
            </summary>
        </member>
        <member name="T:Quantum.ISignalOnCollision2D">
            <summary>
            Interface for receiving callbacks once per frame while two non-trigger 2D colliders are touching.
            <remarks>At least one of the entities involved in a collision must have the respective <see cref="T:Quantum.CallbackFlags"/> set for the callback to be called.</remarks>
            <remarks>See <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.SetCallbacks(Quantum.EntityRef,Quantum.CallbackFlags)"/> for setting the callbacks flags to an entity.</remarks>
            </summary>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.ISignalOnCollision2D.OnCollision2D(Quantum.Frame,Quantum.CollisionInfo2D)">
            <summary>
            Called once per frame while two non-trigger 2D colliders are touching.
            </summary>
            <param name="f">The frame in which the collision happened.</param>
            <param name="info">The <see cref="T:Quantum.CollisionInfo2D"/> with data about the collision.</param>
            \ingroup Physics2dApi
        </member>
        <member name="T:Quantum.ISignalOnCollisionEnter2D">
            <summary>
            Interface for receiving callbacks once two non-trigger 2D colliders start touching.
            <remarks>At least one of the entities involved in a collision must have the respective <see cref="T:Quantum.CallbackFlags"/> set for the callback to be called.</remarks>
            <remarks>See <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.SetCallbacks(Quantum.EntityRef,Quantum.CallbackFlags)"/> for setting the callbacks flags to an entity.</remarks>
            </summary>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.ISignalOnCollisionEnter2D.OnCollisionEnter2D(Quantum.Frame,Quantum.CollisionInfo2D)">
            <summary>
            Called once two non-trigger 2D colliders start touching.
            </summary>
            <param name="f">The frame in which the collision happened.</param>
            <param name="info">The <see cref="T:Quantum.CollisionInfo2D"/> with data about the collision.</param>
            \ingroup Physics2dApi
        </member>
        <member name="T:Quantum.ISignalOnCollisionExit2D">
            <summary>
            Interface for receiving callbacks once two non-trigger 2D colliders stop touching.
            <remarks>At least one of the entities involved in a collision must have the respective <see cref="T:Quantum.CallbackFlags"/> set for the callback to be called.</remarks>
            <remarks>See <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.SetCallbacks(Quantum.EntityRef,Quantum.CallbackFlags)"/> for setting the callbacks flags to an entity.</remarks>
            </summary>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.ISignalOnCollisionExit2D.OnCollisionExit2D(Quantum.Frame,Quantum.ExitInfo2D)">
            <summary>
            Called once two non-trigger 2D colliders stop touching.
            </summary>
            <param name="f">The frame in which the entities stopped touching.</param>
            <param name="info">The <see cref="T:Quantum.ExitInfo2D"/> with the entities that were touching.</param>
            \ingroup Physics2dApi
        </member>
        <member name="T:Quantum.ISignalOnTrigger2D">
            <summary>
            Interface for receiving callbacks once per frame while a non-trigger and a trigger 2D colliders are touching.
            <remarks>No collision is checked between two kinematic colliders that are both trigger or both non-trigger.</remarks>
            <remarks>At least one of the entities involved in a collision must have the respective <see cref="T:Quantum.CallbackFlags"/> set for the callback to be called.</remarks>
            <remarks>See <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.SetCallbacks(Quantum.EntityRef,Quantum.CallbackFlags)"/> for setting the callbacks flags to an entity.</remarks>
            </summary>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.ISignalOnTrigger2D.OnTrigger2D(Quantum.Frame,Quantum.TriggerInfo2D)">
            <summary>
            Called once per frame while a non-trigger and a trigger 2D colliders are touching.
            </summary>
            <param name="f">The frame in which the collision happened.</param>
            <param name="info">The <see cref="T:Quantum.TriggerInfo2D"/> with data about the trigger collision.</param>
            \ingroup Physics2dApi
        </member>
        <member name="T:Quantum.ISignalOnTriggerEnter2D">
            <summary>
            Interface for receiving callbacks once a non-trigger and a trigger 2D colliders start touching.
            <remarks>No collision is checked between two kinematic colliders that are both trigger or both non-trigger.</remarks>
            <remarks>At least one of the entities involved in a collision must have the respective <see cref="T:Quantum.CallbackFlags"/> set for the callback to be called.</remarks>
            <remarks>See <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.SetCallbacks(Quantum.EntityRef,Quantum.CallbackFlags)"/> for setting the callbacks flags to an entity.</remarks>
            </summary>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.ISignalOnTriggerEnter2D.OnTriggerEnter2D(Quantum.Frame,Quantum.TriggerInfo2D)">
            <summary>
            Called once a non-trigger and a trigger 2D colliders start touching.
            </summary>
            <param name="f">The frame in which the collision happened.</param>
            <param name="info">The <see cref="T:Quantum.TriggerInfo2D"/> with data about the trigger collision.</param>
            \ingroup Physics2dApi
        </member>
        <member name="T:Quantum.ISignalOnTriggerExit2D">
            <summary>
            Interface for receiving callbacks once a non-trigger and a trigger 2D colliders stop touching.
            <remarks>No collision is checked between two kinematic colliders that are both trigger or both non-trigger.</remarks>
            <remarks>At least one of the entities involved in a collision must have the respective <see cref="T:Quantum.CallbackFlags"/> set for the callback to be called.</remarks>
            <remarks>See <see cref="M:Quantum.Physics2D.PhysicsEngine2D.Api.SetCallbacks(Quantum.EntityRef,Quantum.CallbackFlags)"/> for setting the callbacks flags to an entity.</remarks>
            </summary>
            \ingroup Physics2dApi
        </member>
        <member name="M:Quantum.ISignalOnTriggerExit2D.OnTriggerExit2D(Quantum.Frame,Quantum.ExitInfo2D)">
            <summary>
            Called once a non-trigger and a trigger 2D colliders stop touching.
            </summary>
            <param name="f">The frame in which the entities stopped touching.</param>
            <param name="info">The <see cref="T:Quantum.ExitInfo2D"/> with the entities that were touching.</param>
            \ingroup Physics2dApi
        </member>
        <member name="T:Quantum.ISignalOnCollision3D">
            <summary>
            Interface for receiving callbacks once per frame while two non-trigger 3D colliders are touching.
            <remarks>At least one of the entities involved in a collision must have the respective <see cref="T:Quantum.CallbackFlags"/> set for the callback to be called.</remarks>
            <remarks>See <see cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.SetCallbacks(Quantum.EntityRef,Quantum.CallbackFlags)"/> for setting the callbacks flags to an entity.</remarks>
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.ISignalOnCollision3D.OnCollision3D(Quantum.Frame,Quantum.CollisionInfo3D)">
            <summary>
            Called once per frame while two non-trigger 3D colliders are touching.
            </summary>
            <param name="f">The frame in which the collision happened.</param>
            <param name="info">The <see cref="T:Quantum.CollisionInfo3D"/> with data about the collision.</param>
            \ingroup Physics3dApi
        </member>
        <member name="T:Quantum.ISignalOnCollisionEnter3D">
            <summary>
            Interface for receiving callbacks once two non-trigger 3D colliders start touching.
            <remarks>At least one of the entities involved in a collision must have the respective <see cref="T:Quantum.CallbackFlags"/> set for the callback to be called.</remarks>
            <remarks>See <see cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.SetCallbacks(Quantum.EntityRef,Quantum.CallbackFlags)"/> for setting the callbacks flags to an entity.</remarks>
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.ISignalOnCollisionEnter3D.OnCollisionEnter3D(Quantum.Frame,Quantum.CollisionInfo3D)">
            <summary>
            Called once two non-trigger 3D colliders start touching.
            </summary>
            <param name="f">The frame in which the collision happened.</param>
            <param name="info">The <see cref="T:Quantum.CollisionInfo3D"/> with data about the collision.</param>
            \ingroup Physics3dApi
        </member>
        <member name="T:Quantum.ISignalOnCollisionExit3D">
            <summary>
            Interface for receiving callbacks once two non-trigger 3D colliders stop touching.
            <remarks>At least one of the entities involved in a collision must have the respective <see cref="T:Quantum.CallbackFlags"/> set for the callback to be called.</remarks>
            <remarks>See <see cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.SetCallbacks(Quantum.EntityRef,Quantum.CallbackFlags)"/> for setting the callbacks flags to an entity.</remarks>
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.ISignalOnCollisionExit3D.OnCollisionExit3D(Quantum.Frame,Quantum.ExitInfo3D)">
            <summary>
            Called once two non-trigger 3D colliders stop touching.
            </summary>
            <param name="f">The frame in which the entities stopped touching.</param>
            <param name="info">The <see cref="T:Quantum.ExitInfo3D"/> with the entities that were touching.</param>
            \ingroup Physics3dApi
        </member>
        <member name="T:Quantum.ISignalOnTrigger3D">
            <summary>
            Interface for receiving callbacks once per frame while a non-trigger and a trigger 3D colliders are touching.
            <remarks>No collision is checked between two kinematic colliders that are both trigger or both non-trigger.</remarks>
            <remarks>At least one of the entities involved in a collision must have the respective <see cref="T:Quantum.CallbackFlags"/> set for the callback to be called.</remarks>
            <remarks>See <see cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.SetCallbacks(Quantum.EntityRef,Quantum.CallbackFlags)"/> for setting the callbacks flags to an entity.</remarks>
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.ISignalOnTrigger3D.OnTrigger3D(Quantum.Frame,Quantum.TriggerInfo3D)">
            <summary>
            Called once per frame while a non-trigger and a trigger 3D colliders are touching.
            </summary>
            <param name="f">The frame in which the collision happened.</param>
            <param name="info">The <see cref="T:Quantum.TriggerInfo3D"/> with data about the trigger collision.</param>
            \ingroup Physics3dApi
        </member>
        <member name="T:Quantum.ISignalOnTriggerEnter3D">
            <summary>
            Interface for receiving callbacks once a non-trigger and a trigger 3D colliders start touching.
            <remarks>No collision is checked between two kinematic colliders that are both trigger or both non-trigger.</remarks>
            <remarks>At least one of the entities involved in a collision must have the respective <see cref="T:Quantum.CallbackFlags"/> set for the callback to be called.</remarks>
            <remarks>See <see cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.SetCallbacks(Quantum.EntityRef,Quantum.CallbackFlags)"/> for setting the callbacks flags to an entity.</remarks>
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.ISignalOnTriggerEnter3D.OnTriggerEnter3D(Quantum.Frame,Quantum.TriggerInfo3D)">
            <summary>
            Called once a non-trigger and a trigger 3D colliders start touching.
            </summary>
            <param name="f">The frame in which the collision happened.</param>
            <param name="info">The <see cref="T:Quantum.TriggerInfo3D"/> with data about the trigger collision.</param>
            \ingroup Physics3dApi
        </member>
        <member name="T:Quantum.ISignalOnTriggerExit3D">
            <summary>
            Interface for receiving callbacks once a non-trigger and a trigger 3D colliders stop touching.
            <remarks>No collision is checked between two kinematic colliders that are both trigger or both non-trigger.</remarks>
            <remarks>At least one of the entities involved in a collision must have the respective <see cref="T:Quantum.CallbackFlags"/> set for the callback to be called.</remarks>
            <remarks>See <see cref="M:Quantum.Physics3D.PhysicsEngine3D.Api.SetCallbacks(Quantum.EntityRef,Quantum.CallbackFlags)"/> for setting the callbacks flags to an entity.</remarks>
            </summary>
            \ingroup Physics3dApi
        </member>
        <member name="M:Quantum.ISignalOnTriggerExit3D.OnTriggerExit3D(Quantum.Frame,Quantum.ExitInfo3D)">
            <summary>
            Called once a non-trigger and a trigger 3D colliders stop touching.
            </summary>
            <param name="f">The frame in which the entities stopped touching.</param>
            <param name="info">The <see cref="T:Quantum.ExitInfo3D"/> with the entities that were touching.</param>
            \ingroup Physics3dApi
        </member>
        <member name="T:Quantum.QuantumReplayFile">
            <summary>
            A class that holds all relevant data to run a Quantum replay and can serialized in JSON.
            A replay may contain an asset db for convenience, that should be omitted in production environments where files sizes are a concern.
            A replay may contain recorded checksums, that can be verified during runtime as a development feature.
            </summary>
        </member>
        <member name="F:Quantum.QuantumReplayFile.InputHistoryDeltaCompressed">
            <summary>
            Delta compressed binary input history, this is the same that is send over replay webhooks for example.
            </summary>
        </member>
        <member name="F:Quantum.QuantumReplayFile.InputHistoryLegacy">
            <summary>
            Full verbose input used in Quantum 2.1, which is still functional, but has only fringe use cases. 
            </summary>
        </member>
        <member name="F:Quantum.QuantumReplayFile.RuntimeConfigData">
            <summary>
            Binary serialized RuntimeConfig.
            Use AssetSerializer.ConfigToByteArray(runtimeConfig, compress: true)
            </summary>
        </member>
        <member name="F:Quantum.QuantumReplayFile.DeterministicConfig">
            <summary>
            The session config.
            </summary>
        </member>
        <member name="F:Quantum.QuantumReplayFile.LastTick">
            <summary>
            The last tick of the input.
            </summary>
        </member>
        <member name="F:Quantum.QuantumReplayFile.InitialTick">
            <summary>
            The initial tick to start from, requires <see cref="F:Quantum.QuantumReplayFile.InitialFrameData"/> to be set.
            </summary>
        </member>
        <member name="F:Quantum.QuantumReplayFile.InitialFrameData">
            <summary>
            Optional frame data to start the replay with. This is used for save games for example.
            </summary>
        </member>
        <member name="F:Quantum.QuantumReplayFile.Checksums">
            <summary>
            Optional checksums. Omit this for replays in production environments.
            </summary>
        </member>
        <member name="F:Quantum.QuantumReplayFile.AssetDatabaseData">
            <summary>
            Optional serialized asset database. Omit this for replays in production environments.
            Use AssetSerializer.SerializeAssets(stream, ResourceManager.LoadAllAssets().ToArray()
            </summary>
        </member>
        <member name="M:Quantum.QuantumReplayFile.CreateInputProvider">
            <summary>
            Helper method to create an input provider based on the combination of the saved input history configurations.
            </summary>
            <returns>Replay input provider to play back the input. Use this in <see cref="F:Quantum.SessionRunner.Arguments.ReplayProvider"/></returns>.
        </member>
        <member name="T:Quantum.ReplayFile">
            <summary>
            Obsolete class, use <see cref="T:Quantum.QuantumReplayFile"/> instead.
            </summary>
        </member>
        <member name="P:Quantum.ReplayFile.InputHistory">
            <summary>
            Obsolete
            </summary>
        </member>
        <member name="P:Quantum.ReplayFile.InputHistoryRaw">
            <summary>
            Obsolete, use InputHistoryDeltaCompressed instead
            </summary>
        </member>
        <member name="P:Quantum.ReplayFile.Frame">
            <summary>
            Obsolete, use InitialFrameData instead
            </summary>
        </member>
        <member name="P:Quantum.ReplayFile.InitialFrame">
            <summary>
            Obsolete, use InitialTick instead
            </summary>
        </member>
        <member name="P:Quantum.ReplayFile.RuntimeConfig">
            <summary>
            Obsolete, use RuntimeConfigData.Binary instead
            </summary>
        </member>
        <member name="P:Quantum.ReplayFile.RuntimeConfigBinary">
            <summary>
            Obsolete, use RuntimeConfigData.Binary instead
            </summary>
        </member>
        <member name="P:Quantum.ReplayFile.AssetDatabase">
            <summary>
            Obsolete, use AssetDatabaseData instead
            </summary>
        </member>
        <member name="T:Quantum.SimulationConfig">
            <summary>
            The SimulationConfig holds parameters used in the ECS layer and inside core systems like physics and navigation.
            </summary>
        </member>
        <member name="F:Quantum.SimulationConfig.DEFAULT_ID">
            <summary>
            Obsolete: Don't use the hard coded guids instead reference the simulation config used in the RuntimeConfig.
            </summary>
        </member>
        <member name="T:Quantum.SimulationConfig.AutoLoadSceneFromMapMode">
            <summary>
            The scene load mode to use when changing Quantum maps.
            <para>Will trigger for example for the initial map that is set in Quantum by <see cref="F:Quantum.RuntimeConfig.Map"/> and on subsequent map changes.</para>
            <para>The Unity scene referenced by <see cref="F:Quantum.Map.Scene"/> will be loaded.</para>
            </summary>
        </member>
        <member name="F:Quantum.SimulationConfig.AutoLoadSceneFromMapMode.Disabled">
            <summary>
            Automatic scene loading disabled.
            </summary>
        </member>
        <member name="F:Quantum.SimulationConfig.AutoLoadSceneFromMapMode.Legacy">
            <summary>
            Obsolete: unused.
            </summary>
        </member>
        <member name="F:Quantum.SimulationConfig.AutoLoadSceneFromMapMode.UnloadPreviousSceneThenLoad">
            <summary>
            Unload the current scene then load the new scene.
            </summary>
        </member>
        <member name="F:Quantum.SimulationConfig.AutoLoadSceneFromMapMode.LoadThenUnloadPreviousScene">
            <summary>
            Load the new scene then unload the current scene.
            </summary>
        </member>
        <member name="F:Quantum.SimulationConfig.Entities">
            <summary>
            Global entities configuration
            </summary>
        </member>
        <member name="F:Quantum.SimulationConfig.Physics">
            <summary>
            Global physics configurations.
            </summary>
        </member>
        <member name="F:Quantum.SimulationConfig.Navigation">
            <summary>
            Global navmesh configurations.
            </summary>
        </member>
        <member name="F:Quantum.SimulationConfig.AutoLoadSceneFromMap">
            <summary>
            This option will trigger a Unity scene load during the Quantum start sequence.\n
            This might be convenient to start with but once the starting sequence is customized disable it and implement the scene loading by yourself.
            "Previous Scene" refers to a scene name in Quantum Map.
            </summary>
        </member>
        <member name="F:Quantum.SimulationConfig.DeltaTimeType">
            <summary>
            Configure how the client tracks the time to progress the Quantum simulation from the QuantumRunner class.
            </summary>
        </member>
        <member name="F:Quantum.SimulationConfig.ThreadCount">
            <summary>
            Override the number of threads used internally. Default is 2.
            </summary>
        </member>
        <member name="F:Quantum.SimulationConfig.ChecksumSnapshotHistoryLengthSeconds">
            <summary>
            How long to store checksumed verified frames. The are used to generate a frame dump in case of a checksum error happening. Not used in Replay and Local mode. Default is 3.
            </summary>
        </member>
        <member name="F:Quantum.SimulationConfig.ChecksumErrorDumpOptions">
            <summary>
            Additional options for checksum dumps, if the default settings don't provide a clear picture. 
            </summary>
        </member>
        <member name="F:Quantum.SimulationConfig.HeapTrackingMode">
            <summary>
            If and to which extent allocations in the Frame Heap should be tracked when in Debug mode.
            Recommended modes for development is `DetectLeaks`.
            While actively debugging a memory leak,`TraceAllocations` mode can be enabled (warning: tracing is very slow).
            </summary>
        </member>
        <member name="F:Quantum.SimulationConfig.HeapPageShift">
            <summary>
            Define the max heap size for one page of memory the frame class uses for custom allocations like QList for example. The default is 15.
            </summary>
            <remarks>2^15 = 32.768 bytes</remarks>
            <remarks><code>TotalHeapSizeInBytes = (1 &lt;&lt; HeapPageShift) * HeapPageCount</code></remarks>
        </member>
        <member name="F:Quantum.SimulationConfig.HeapPageCount">
            <summary>
            Define the max heap page count for memory the frame class uses for custom allocations like QList for example. Default is 256.
            </summary>
            <remarks><code>TotalHeapSizeInBytes = (1 &lt;&lt; HeapPageShift) * HeapPageCount</code></remarks>
        </member>
        <member name="F:Quantum.SimulationConfig.HeapExtraCount">
            <summary>
            Sets extra heaps to allocate for a session in case you need to
            create 'auxiliary' frames than actually required for the simulation itself.
            Default is 0.
            </summary>
        </member>
        <member name="M:Quantum.SimulationConfig.Loaded(Quantum.IResourceManager,Photon.Deterministic.Native.Allocator)">
            <summary>
            The asset loaded callback, caches fixed calculation results.
            </summary>
            <param name="resourceManager">Resource manager.</param>
            <param name="allocator">The allocator.</param>
        </member>
        <member name="M:Quantum.SimulationConfig.Reset">
            <summary>
            Unity Reset() method is used to initialized class fields with default values.
            </summary>
        </member>
        <member name="T:Quantum.SimulationConfig.PhysicsType">
            <summary>
            Physics 2D or 3D used for importing layers from Unity.
            </summary>
        </member>
        <member name="F:Quantum.SimulationConfig.PhysicsType.Physics3D">
            <summary>
            Quantum Physics 3D.
            </summary>
        </member>
        <member name="F:Quantum.SimulationConfig.PhysicsType.Physics2D">
            <summary>
            Quantum Physics 2D.
            </summary>
        </member>
        <member name="M:Quantum.SimulationConfig.ImportLayersFromUnity(Quantum.SimulationConfig.PhysicsType)">
            <summary>
            Import Unity physics layers.
            </summary>
            <param name="physicsType">The physics type to import from.</param>
        </member>
        <member name="M:Quantum.SimulationConfig.GetUnityLayerNameArray">
            <summary>
            Creates 32 physics layer names from Unity.
            </summary>
        </member>
        <member name="M:Quantum.SimulationConfig.GetUnityLayerMatrix(Quantum.SimulationConfig.PhysicsType)">
            <summary>
            Creates 32 physics layer masks from Unity.
            </summary>
            <param name="physicsType"></param>
        </member>
        <member name="T:Quantum.SimulationConfigChecksumErrorDumpOptions">
            <summary>
            Configuration options for checksum error dumps.
            </summary>
        </member>
        <member name="F:Quantum.SimulationConfigChecksumErrorDumpOptions.SendAssetDBChecksums">
            <summary>
            Sends asset db checksums.
            </summary>
        </member>
        <member name="F:Quantum.SimulationConfigChecksumErrorDumpOptions.ReadableDynamicDB">
            <summary>
            Dumps readable information from the dynamic db.
            </summary>
        </member>
        <member name="F:Quantum.SimulationConfigChecksumErrorDumpOptions.RawFPValues">
            <summary>
            Prints raw FP values.
            </summary>
        </member>
        <member name="F:Quantum.SimulationConfigChecksumErrorDumpOptions.ComponentChecksums">
            <summary>
            Dumps component checksums.
            </summary>
        </member>
        <member name="T:Quantum.EventDispatcher">
            <summary>
            Publish, subscribe pattern for Quantum events: <see cref="T:Quantum.EventBase"/>.
            Quantum events are used to communicate view relevant game updates from the simulation to the view.
            </summary>
        </member>
        <member name="M:Quantum.EventDispatcher.GetEventTypes">
            <summary>
            Assembles a dictionary of built-in and user generated Quantum event types.
            </summary>
            <returns>Event mapping</returns>
        </member>
        <member name="M:Quantum.EventDispatcher.#ctor">
            <summary>
            Creates the event dispatcher and initializes the event type mapping.
            </summary>
        </member>
        <member name="M:Quantum.EventDispatcher.Publish(Quantum.EventBase)">
            <summary>
            Publish an event.
            </summary>
            <param name="e">Event</param>
            <returns>True if the event was handled by any subscription</returns>
        </member>
        <member name="T:Quantum.ISignalOnNavMeshWaypointReached">
            <inheritdoc cref="M:Quantum.ISignalOnNavMeshWaypointReached.OnNavMeshWaypointReached(Quantum.Frame,Quantum.EntityRef,Photon.Deterministic.FPVector3,Quantum.Navigation.WaypointFlag,System.Boolean@)"/>
            \ingroup NavigationApi
        </member>
        <member name="M:Quantum.ISignalOnNavMeshWaypointReached.OnNavMeshWaypointReached(Quantum.Frame,Quantum.EntityRef,Photon.Deterministic.FPVector3,Quantum.Navigation.WaypointFlag,System.Boolean@)">
            <summary>
            Signal is called when an agent reaches a waypoint.
            <para>Requires enabled <see cref="F:Quantum.Navigation.Config.EnableNavigationCallbacks"/> in <see cref="F:Quantum.SimulationConfig.Navigation"/>.</para>
            </summary>
            <param name="f">The frame reference.</param>
            <param name="entity">The entity the navmesh agent component belongs to</param>
            <param name="waypoint">The current waypoint position</param>
            <param name="waypointFlags">The current waypoint flags</param>
            <param name="resetAgent">If set to true the NavMeshPathfinder component will be cleared and stopped. Set to false if NavMeshPathfinder.SetTarget() was called inside the callback.</param>
        </member>
        <member name="T:Quantum.ISignalOnNavMeshSearchFailed">
            <inheritdoc cref="M:Quantum.ISignalOnNavMeshSearchFailed.OnNavMeshSearchFailed(Quantum.Frame,Quantum.EntityRef,System.Boolean@)"/>
            \ingroup NavigationApi
        </member>
        <member name="M:Quantum.ISignalOnNavMeshSearchFailed.OnNavMeshSearchFailed(Quantum.Frame,Quantum.EntityRef,System.Boolean@)">
            <summary>
            Signal is called when the agent could not find a path in the agent update after using <see cref="M:Quantum.NavMeshPathfinder.SetTarget(Quantum.Core.FrameBase,Photon.Deterministic.FPVector3,Quantum.NavMesh)"/>
            <para>Requires enabled <see cref="F:Quantum.Navigation.Config.EnableNavigationCallbacks"/> in <see cref="F:Quantum.SimulationConfig.Navigation"/>.</para>
            </summary>
            <param name="f">The frame reference.</param>
            <param name="entity">The entity the navmesh agent component belongs to</param>
            <param name="resetAgent">Set this to true if the agent should reset its internal state (default is true).</param>
        </member>
        <member name="T:Quantum.ISignalOnNavMeshMoveAgent">
            <inheritdoc cref="M:Quantum.ISignalOnNavMeshMoveAgent.OnNavMeshMoveAgent(Quantum.Frame,Quantum.EntityRef,Photon.Deterministic.FPVector2)"/>
            \ingroup NavigationApi
        </member>
        <member name="M:Quantum.ISignalOnNavMeshMoveAgent.OnNavMeshMoveAgent(Quantum.Frame,Quantum.EntityRef,Photon.Deterministic.FPVector2)">
            <summary>
            Signal is called when the agent should move. The desired direction is influence by avoidance.
            <para>The agent velocity should be set in the callback.</para>
            <para>Requires enabled <see cref="F:Quantum.NavMeshAgentConfig.MovementType"/> to be set to Callback.</para>
            <para>Requires enabled <see cref="F:Quantum.Navigation.Config.EnableNavigationCallbacks"/> in <see cref="F:Quantum.SimulationConfig.Navigation"/>.</para>
            </summary>
            <param name="f">The frame reference.</param>
            <param name="entity">The entity the navmesh agent component belongs to.</param>
            <param name="desiredDirection">The normalized direction that the internal steering and avoidance thinks the agent movement vector should be.</param>
        </member>
        <member name="T:Quantum.SystemMainThread">
            <summary>
            Most common Quantum system type. Implements a regular Update() with all the usual features.
            <para>Always register new system types on the <see cref="T:Quantum.SystemsConfig"/>.</para>
            </summary>
        </member>
        <member name="M:Quantum.SystemMainThread.#ctor">
            <summary>
            Create a new system.
            </summary>
        </member>
        <member name="M:Quantum.SystemMainThread.#ctor(System.String)">
            <summary>
            Create a new system with a custom name.
            </summary>
            <param name="name">The system name shows up in the task profiler for example.</param>
        </member>
        <member name="M:Quantum.SystemMainThread.ScheduleUpdate(Quantum.Frame,Quantum.Task.TaskHandle)">
            <summary>
            Adds the basic update callback.
            </summary>
            <param name="f">The referenced frame.</param>
            <param name="taskHandle">The initial task handle.</param>
            <returns>The final task graph.</returns>
        </member>
        <member name="M:Quantum.SystemMainThread.Schedule(Quantum.Frame,Quantum.Task.TaskHandle)">
            <summary>
            Override to add additional tasks.
            </summary>
            <param name="f">The referenced frame.</param>
            <param name="taskHandle">The initial task handle.</param>
            <returns>The final task graph.</returns>
        </member>
        <member name="M:Quantum.SystemMainThread.Update(Quantum.Frame)">
            <summary>
            Override to add workload.
            </summary>
            <param name="f">The current fame.</param>
        </member>
        <member name="T:Quantum.QuantumGameFlags">
            <summary>
            This class contains values for flags that will be accessible with <see cref="P:Quantum.QuantumGame.GameFlags"/>.
            Built-in flags control some aspects of QuantumGame inner workings, without affecting the simulation
            outcome.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameFlags.Server">
            <summary>
            Starts the game in the server mode. 
            When this flag is not set, all the events marked with "server" get culled immediately.
            If this flag is set, all the events marked with "client" get culled immediately.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameFlags.DisableSharedChecksumSerializer">
            <summary>
            By default, QuantumGame uses a single shared checksum serializer to reduce allocations. 
            The serializer is *not* static - it is only shared between frames coming from the same QuantumGame.
            Set this flag if you want to disable this behaviour, for example if you calculate
            checksums for multiple frames using multiple threads.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameFlags.DisableInterpolatableStates">
            <summary>
            By default, a Quantum session creates additional frame instances to cache previous states that can
            be used for interpolation, notably for transform interpolations on the View.
            Set this flag if you want to disable this behaviour (e.g. a server-side or console-only simulation),
            reducing memory allocations and the time spent copying states over.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameFlags.EnableTaskProfiler">
            <summary>
            Set this flag to enables the Quantum task profiler in debug or release configurations.
            </summary>
        </member>
        <member name="F:Quantum.QuantumGameFlags.CustomFlagsStart">
            <summary>
            Custom user flags start from this value. Flags are accessible with <see cref="P:Quantum.QuantumGame.GameFlags"/>.
            </summary>
        </member>
        <member name="F:Quantum.TrajectoryPredictor.lutExtraPrecisionBits">
            <summary>
            The LUT stores the raw values with an increased number of precision bits relative to the
            regular FP precision. This value must be smalled than the FP precision.
            </summary>
        </member>
        <member name="F:Quantum.TrajectoryPredictor.minInitBlock">
            <summary>
            The minimum amount of power factors computed one initializing a key.
            Further expansions also follow this minimum amount. 
            </summary>
        </member>
        <member name="F:Quantum.TrajectoryPredictor._dragPowFactorLut">
            <summary>
            LUT to store values for the expression (1 - drag * deltaTime)^n
            The values are store as raw FP value shifted by an additional number of precision bits.
            </summary>
        </member>
        <member name="M:Quantum.TrajectoryPredictor.PredictPosition(Photon.Deterministic.FP,System.Int32,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Photon.Deterministic.FP)">
            <summary>
            Predicts the expected position of a dynamic physics body on a given tick in the future,
            taking into consideration gravity and the drag force.
            </summary>
            <param name="dt">Delta time of each integration step. Usually the Frame.DeltaTime</param>
            <param name="ticksAhead">How many ticks ahead the prediction will be, where each tick is <paramref name="dt"/> long.</param>
            <param name="initPos">The initial position of the object, before the prediction.</param>
            <param name="initVel">The initial velocity of the object, before the prediction.</param>
            <param name="gravity">The gravity force which the object is subject to.</param>
            <param name="drag">Drag factor of the dynamic body.</param>
            <returns>The predicted position.</returns>
            <exception cref="T:System.InvalidOperationException">if <paramref name="ticksAhead"/> is smaller than 0.</exception>
        </member>
        <member name="M:Quantum.TrajectoryPredictor.PredictPosition(Photon.Deterministic.FP,System.Int32,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Photon.Deterministic.FP)">
            <summary>
            Predicts the expected position of a dynamic physics body on a given tick in the future,
            taking into consideration gravity and the drag force.
            </summary>
            <param name="dt">Delta time of each integration step. Usually the Frame.DeltaTime</param>
            <param name="ticksAhead">How many ticks ahead the prediction will be, where each tick is <paramref name="dt"/> long.</param>
            <param name="initPos">The initial position of the object, before the prediction.</param>
            <param name="initVel">The initial velocity of the object, before the prediction.</param>
            <param name="gravity">The gravity force which the object is subject to.</param>
            <param name="drag">Drag factor of the dynamic body.</param>
            <returns>The predicted position.</returns>
            <exception cref="T:System.InvalidOperationException">if <paramref name="ticksAhead"/> is smaller than 0.</exception>
        </member>
        <member name="M:Quantum.TrajectoryPredictor.PredictVelocity(Photon.Deterministic.FP,System.Int32,Photon.Deterministic.FPVector2,Photon.Deterministic.FPVector2,Photon.Deterministic.FP)">
            <summary>
            Predicts the expected velocity of a dynamic physics body on a given tick in the future,
            taking into consideration gravity and the drag force.
            </summary>
            <param name="dt">Delta time of each integration step. Usually the Frame.DeltaTime</param>
            <param name="ticksAhead">How many ticks ahead the prediction will be, where each tick is <paramref name="dt"/> long.</param>
            <param name="initVel">The initial velocity of the object, before the prediction.</param>
            <param name="gravity">The gravity force which the object is subject to.</param>
            <param name="drag">Drag factor of the dynamic body.</param>
            <returns>The predicted velocity.</returns>
            <exception cref="T:System.InvalidOperationException">if <paramref name="ticksAhead"/> is smaller than 0.</exception>
        </member>
        <member name="M:Quantum.TrajectoryPredictor.PredictVelocity(Photon.Deterministic.FP,System.Int32,Photon.Deterministic.FPVector3,Photon.Deterministic.FPVector3,Photon.Deterministic.FP)">
            <summary>
            Predicts the expected velocity of a dynamic physics body on a given tick in the future,
            taking into consideration gravity and the drag force.
            </summary>
            <param name="dt">Delta time of each integration step. Usually the Frame.DeltaTime</param>
            <param name="ticksAhead">How many ticks ahead the prediction will be, where each tick is <paramref name="dt"/> long.</param>
            <param name="initVel">The initial velocity of the object, before the prediction.</param>
            <param name="gravity">The gravity force which the object is subject to.</param>
            <param name="drag">Drag factor of the dynamic body.</param>
            <returns>The predicted velocity.</returns>
            <exception cref="T:System.InvalidOperationException">if <paramref name="ticksAhead"/> is smaller than 0.</exception>
        </member>
        <member name="T:Quantum.FrameThreadSafeExtensions">
            <summary>
            Extension methods for the <see cref="T:Quantum.FrameThreadSafe"/> class.
            </summary>
        </member>
        <member name="M:Quantum.FrameThreadSafeExtensions.GetGlobal(Quantum.FrameThreadSafe)">
            <summary>
            A convenience method to get the global state from a frame without having to cast it.
            </summary>
            <param name="frame"></param>
            <returns></returns>
        </member>
        <member name="T:Quantum.ISignalOnComponentAdded`1">
            <inheritdoc cref="M:Quantum.ISignalOnComponentAdded`1.OnAdded(Quantum.Frame,Quantum.EntityRef,`0*)"/>
            <typeparam name="T">Component type</typeparam>
        </member>
        <member name="M:Quantum.ISignalOnComponentAdded`1.OnAdded(Quantum.Frame,Quantum.EntityRef,`0*)">
            <summary>
            The signal is called after a component of the desired type has been added to an entity.
            </summary>
            <param name="f">The frame reference.</param>
            <param name="entity">The entity that the component was added to.</param>
            <param name="component">The component that was added.</param>
        </member>
        <member name="T:Quantum.ISignalOnComponentRemoved`1">
            <inheritdoc cref="M:Quantum.ISignalOnComponentRemoved`1.OnRemoved(Quantum.Frame,Quantum.EntityRef,`0*)"/>
            <typeparam name="T">Component type</typeparam>
        </member>
        <member name="M:Quantum.ISignalOnComponentRemoved`1.OnRemoved(Quantum.Frame,Quantum.EntityRef,`0*)">
            <summary>
            The signal is called after a component of the desired type has been removed from an entity.
            </summary>
            <param name="f">The frame reference.</param>
            <param name="entity">The entity that the component was removed from.</param>
            <param name="component">The component that was removed.</param>
        </member>
        <member name="T:Quantum.ISignalOnMapChanged">
            <inheritdoc cref="M:Quantum.ISignalOnMapChanged.OnMapChanged(Quantum.Frame,Quantum.AssetRef{Quantum.Map})"/>
        </member>
        <member name="M:Quantum.ISignalOnMapChanged.OnMapChanged(Quantum.Frame,Quantum.AssetRef{Quantum.Map})">
            <summary>
            This signal is called after the map has been changed by assigning a new map to <see cref="P:Quantum.Frame.Map"/>.
            </summary>
            <param name="f">The frame reference</param>
            <param name="previousMap">The previous map</param>
        </member>
        <member name="T:Quantum.ISignalOnEntityPrototypeMaterialized">
            <inheritdoc cref="M:Quantum.ISignalOnEntityPrototypeMaterialized.OnEntityPrototypeMaterialized(Quantum.Frame,Quantum.EntityRef,Quantum.EntityPrototypeRef)"/>
        </member>
        <member name="M:Quantum.ISignalOnEntityPrototypeMaterialized.OnEntityPrototypeMaterialized(Quantum.Frame,Quantum.EntityRef,Quantum.EntityPrototypeRef)">
            <summary>
            This signal is called after an entity prototype has been materialized.
            <para>During Load Map: the signal is invoked for all Entity and Entity Prototype pairs after all scene prototypes have been materialized.</para>
            <para>Created with Frame.Create(): the signal is invoked immediately after the prototype has been materialized.</para>    /// <param name="f">The frame reference.</param>
            </summary>
            <param name="entity">The entity that was created.</param>
            <param name="prototypeRef">The entity prototype that was materialized.</param>
        </member>
        <member name="T:Quantum.ISignalOnPlayerConnected">
            <inheritdoc cref="M:Quantum.ISignalOnPlayerConnected.OnPlayerConnected(Quantum.Frame,Quantum.PlayerRef)"/>
        </member>
        <member name="M:Quantum.ISignalOnPlayerConnected.OnPlayerConnected(Quantum.Frame,Quantum.PlayerRef)">
            <summary>
            The signal is called when a player has successfully joined the simulation.
            <para>It's originating from the <see cref="T:Quantum.Core.PlayerConnectedSystem"/>.</para>
            <para>The connected status is based on the <see cref="M:Photon.Deterministic.DeterministicFrame.GetPlayerInputFlags(Quantum.PlayerRef)"/>.</para>
            <para>The signal is always called from a verified frame.</para>
            </summary>
            <param name="f">The frame reference.</param>
            <param name="player">The player that connected.</param>
        </member>
        <member name="T:Quantum.ISignalOnPlayerDisconnected">
            <inheritdoc cref="M:Quantum.ISignalOnPlayerDisconnected.OnPlayerDisconnected(Quantum.Frame,Quantum.PlayerRef)"/>
        </member>
        <member name="M:Quantum.ISignalOnPlayerDisconnected.OnPlayerDisconnected(Quantum.Frame,Quantum.PlayerRef)">
            <summary>
            The signal is called when a player has been removed and disconnected from the simulation.
            <para>It's originating from the <see cref="T:Quantum.Core.PlayerConnectedSystem"/>.</para>
            <para>The connected status is based on the <see cref="M:Photon.Deterministic.DeterministicFrame.GetPlayerInputFlags(Quantum.PlayerRef)"/>.</para>
            <para>The signal is always called from a verified frame.</para>
            </summary>    /// <param name="f">The frame reference.</param>
            <param name="player">The disconnected player.</param>
        </member>
        <member name="T:Quantum.DotNetTaskRunner">
            <summary>
            The implementation of <see cref="T:Photon.Deterministic.IDeterministicPlatformTaskRunner"/> for .Net frameworks.
            Not used when running the simulation in Unity.
            </summary>
        </member>
        <member name="M:Quantum.DotNetTaskRunner.Schedule(System.Action[])">
            <summary>
            Schedules actions to be executed by the task runner.
            </summary>
            <param name="delegates">Array of actions</param>
        </member>
        <member name="M:Quantum.DotNetTaskRunner.WaitForComplete">
            <summary>
            Wait for the task runner to complete all scheduled actions.
            </summary>
        </member>
        <member name="M:Quantum.DotNetTaskRunner.PollForComplete">
            <summary>
            Poll the task runner for completion.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Quantum.DotNetTaskRunner.Dispose">
            <summary>
            Dispose the object.
            </summary>
        </member>
        <member name="T:Quantum.IRunnerFactory">
            <summary>
            The interface for the runner factory. It creates platform specific objects to run the Quantum simulation.
            </summary>
        </member>
        <member name="P:Quantum.IRunnerFactory.CreatePlaformInfo">
            <summary>
            Gather the platform information.
            There is a spelling mistake in the method name, but it's considered a bigger annoyance to change the interface.
            </summary>
        </member>
        <member name="P:Quantum.IRunnerFactory.CreateTaskFactory">
            <summary>
            Create a Quantum task factory.
            </summary>
        </member>
        <member name="M:Quantum.IRunnerFactory.CreateProfiler(System.String,Photon.Deterministic.DeterministicSessionConfig,Photon.Deterministic.DeterministicPlatformInfo,Photon.Deterministic.IDeterministicGame)">
            <summary>
            The callback can be used to create and attach local profiler before the Quantum simulation has been started.
            </summary>
            <param name="clientId">Quantum client id</param>
            <param name="deterministicConfig">Session config</param>
            <param name="platformInfo">Platform info</param>
            <param name="game">Game</param>
        </member>
        <member name="M:Quantum.IRunnerFactory.CreateGame(Quantum.QuantumGameStartParameters)">
            <summary>
            Instantiate an implementation of the <see cref="T:Photon.Deterministic.IDeterministicGame"/>. 
            </summary>
            <param name="startParameters">Start parameters</param>
            <returns>Instance of IDeterministicGame</returns>
        </member>
        <member name="P:Quantum.IRunnerFactory.UpdateDB">
            <summary>
            The action to when an update to the AssetDB is required.
            </summary>
        </member>
        <member name="M:Quantum.IRunnerFactory.CreateRunner(Quantum.SessionRunner.Arguments)">
            <summary>
            Create an object that the SessionRunner is running on.
            For Unity it is wrapped in a MonoBehaviour.
            </summary>
            <param name="arguments">Session arguments</param>
            <returns>A session runner</returns>
        </member>
        <member name="T:Quantum.SystemSignalsOnly">
            <summary>
            This type of system does not have an Update() function.
            It is meant for systems that focus solely on implementing and receiving signals from other systems. 
            By avoiding the Update loop, it helps you save some overhead.
            </summary>
            <para>Always register new system types on the <see cref="T:Quantum.SystemsConfig"/>.</para>
        </member>
        <member name="M:Quantum.SystemSignalsOnly.Schedule(Quantum.Frame,Quantum.Task.TaskHandle)">
            <inheritdoc cref="M:Quantum.SystemBase.Schedule(Quantum.Frame,Quantum.Task.TaskHandle)"/>/>
        </member>
        <member name="T:Quantum.SystemsConfig">
            <summary>
            A Quantum configuration asset that will create and start Quantum systems in a data-driven way when starting the simulation.
            Can be assigned to <see cref="T:Quantum.RuntimeConfig"/>. 
            If no config is assigned then a default selection of build-in systems is used (<see cref="M:Quantum.DeterministicSystemSetup.CreateSystems(Quantum.RuntimeConfig,Quantum.SimulationConfig,Quantum.SystemsConfig)"/>.
            The systems to be used can always be changed by code inside <see cref="M:Quantum.DeterministicSystemSetup.AddSystemsUser(System.Collections.Generic.ICollection{Quantum.SystemBase},Quantum.RuntimeConfig,Quantum.SimulationConfig,Quantum.SystemsConfig)"/>.
            </summary>
        </member>
        <member name="T:Quantum.SystemsConfig.SystemEntryBase">
            <summary>
            System that will be instantiated on simulation start.
            </summary>
        </member>
        <member name="F:Quantum.SystemsConfig.SystemEntryBase.SystemType">
            <summary>
            System type name. Use typeof(SystemBase).FullName to get a valid name programmatically. E.g. Quantum.Core.SystemSignalsOnly.
            </summary>
        </member>
        <member name="F:Quantum.SystemsConfig.SystemEntryBase.SystemName">
            <summary>
            Optional System name. If set, then the SystemType class needs to have a matching constructor.
            </summary>
        </member>
        <member name="F:Quantum.SystemsConfig.SystemEntryBase.StartDisabled">
            <summary>
            Start system disabled.
            Set <see cref="P:Quantum.SystemBase.StartEnabled"/> accordingly. The value is inversed to have a better default value in Unity inspectors.
            </summary>
        </member>
        <member name="M:Quantum.SystemsConfig.SystemEntryBase.GetChildren">
            <summary>
            Returns child system list if any.
            </summary>
            <returns>List of child systems</returns>
        </member>
        <member name="T:Quantum.SystemsConfig.SystemEntryBase`1">
            <summary>
            To prevent indefinite recursion in Unity serialization system hierarchies are limited to 3 levels.
            </summary>
            <typeparam name="T">Type of the children</typeparam>
        </member>
        <member name="F:Quantum.SystemsConfig.SystemEntryBase`1.Children">
            <summary>
            Child systems.
            </summary>
        </member>
        <member name="M:Quantum.SystemsConfig.SystemEntryBase`1.GetChildren">
            <summary>
            Return child systems.
            </summary>
            <returns>List of child systems</returns>
        </member>
        <member name="M:Quantum.SystemsConfig.SystemEntryBase`1.AddSystem``1(System.String,System.Boolean)">
            <summary>
            Add a child system.
            </summary>
            <typeparam name="TSystem">System type</typeparam>
            <param name="name">System name</param>
            <param name="enabled">Start enabled</param>
            <returns>The created child system entry</returns>
        </member>
        <member name="T:Quantum.SystemsConfig.SystemEntry">
            <summary>
            Base system type.
            </summary>
        </member>
        <member name="T:Quantum.SystemsConfig.SubSystemEntry">
            <summary>
            1st sub level system type.
            </summary>
        </member>
        <member name="T:Quantum.SystemsConfig.SubSubSystemEntry">
            <summary>
            2nd sub level system type.
            </summary>
        </member>
        <member name="M:Quantum.SystemsConfig.SubSubSystemEntry.GetChildren">
            <summary>
            This system cannot have children.
            </summary>
            <returns>Empty array</returns>
        </member>
        <member name="F:Quantum.SystemsConfig.Entries">
            <summary>
            System entries to be instantiated on simulation start.
            </summary>
        </member>
        <member name="M:Quantum.SystemsConfig.CreateSystems(Quantum.SystemsConfig)">
            <summary>
            Converts the systems configuration into a list of system objects while calling the matching (Name, Children) constructors.
            This method throws AssertionExceptions on any invalid system configuration.
            
                                                 SystemBase   
                   __________________________________|___________________________________________________________
                  |                 |                |                    |                     |                |
            SystemGroup     SystemMainThread  SystemArrayComponent  SystemArrayFilter  SystemSignalsOnly  SystemThreadedFilter
             children (SystemBase)  |
                          __________|__________
                         |                     |
              SystemMainThreadGroup  SystemMainThreadFilter
                   children (SystemMainThread)
            </summary>
        </member>
        <member name="M:Quantum.SystemsConfig.AddSystem``1(System.String,System.Boolean)">
            <summary>
            Add a system entry that describes a system to be instantiated on simulation start.
            </summary>
            <typeparam name="T">System type</typeparam>
            <param name="name">System name</param>
            <param name="enabled">System starts enabled</param>
            <returns>System entry that was added to the config</returns>
        </member>
        <member name="M:Quantum.SystemsConfig.AddSystem(System.Type,System.String,System.Boolean)">
            <summary>
            Add a system entry that describes a system to be instantiated on simulation start.
            </summary>
            <param name="systemType">System type</param>
            <param name="name">System name</param>
            <param name="enabled">System starts enabled</param>
            <returns>System entry that was added to the config</returns>
            <exception cref="T:System.ArgumentNullException">Is raised of the systemType is null</exception>
        </member>
        <member name="M:Quantum.SystemsConfig.Reset">
            <summary>
            Unity Reset() event will add all Quantum core default systems to the asset.
            </summary>
        </member>
    </members>
</doc>
