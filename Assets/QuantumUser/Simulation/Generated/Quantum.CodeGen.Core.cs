// <auto-generated>
// This code was auto-generated by a tool, every time
// the tool executes this code will be reset.
//
// If you need to extend the classes generated to add
// fields or methods to them, please create partial
// declarations in another file.
// </auto-generated>
#pragma warning disable 0109
#pragma warning disable 1591


namespace Quantum {
  using Photon.Deterministic;
  using Quantum;
  using Quantum.Core;
  using Quantum.Collections;
  using Quantum.Inspector;
  using Quantum.Physics2D;
  using Quantum.Physics3D;
  using Byte = System.Byte;
  using SByte = System.SByte;
  using Int16 = System.Int16;
  using UInt16 = System.UInt16;
  using Int32 = System.Int32;
  using UInt32 = System.UInt32;
  using Int64 = System.Int64;
  using UInt64 = System.UInt64;
  using Boolean = System.Boolean;
  using String = System.String;
  using Object = System.Object;
  using FlagsAttribute = System.FlagsAttribute;
  using SerializableAttribute = System.SerializableAttribute;
  using MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;
  using MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;
  using FieldOffsetAttribute = System.Runtime.InteropServices.FieldOffsetAttribute;
  using StructLayoutAttribute = System.Runtime.InteropServices.StructLayoutAttribute;
  using LayoutKind = System.Runtime.InteropServices.LayoutKind;
  #if QUANTUM_UNITY //;
  using TooltipAttribute = UnityEngine.TooltipAttribute;
  using HeaderAttribute = UnityEngine.HeaderAttribute;
  using SpaceAttribute = UnityEngine.SpaceAttribute;
  using RangeAttribute = UnityEngine.RangeAttribute;
  using HideInInspectorAttribute = UnityEngine.HideInInspector;
  using PreserveAttribute = UnityEngine.Scripting.PreserveAttribute;
  using FormerlySerializedAsAttribute = UnityEngine.Serialization.FormerlySerializedAsAttribute;
  using MovedFromAttribute = UnityEngine.Scripting.APIUpdating.MovedFromAttribute;
  using CreateAssetMenu = UnityEngine.CreateAssetMenuAttribute;
  using RuntimeInitializeOnLoadMethodAttribute = UnityEngine.RuntimeInitializeOnLoadMethodAttribute;
  #endif //;
  
  public enum BattlePlayerSlot : int {
    Guest = 0,
    Slot1 = 1,
    Slot2 = 2,
    Slot3 = 3,
    Slot4 = 4,
    Spectator = 10,
  }
  public enum BattleTeamNumber : int {
    NoTeam = 0,
    TeamAlpha = 1,
    TeamBeta = 2,
  }
  public enum GameState : int {
    PreGame,
    ReadyToStart,
    Countdown,
    GetReadyToPlay,
    Playing,
    GameOver,
    PostGame,
  }
  public enum PlayerCollisionType : int {
    None = 0,
    Reflect = 1,
    Override = 2,
  }
  public enum PlayerHitboxType : int {
    Shield = 0,
    Character = 1,
  }
  public enum PlayerPlayState : int {
    NotInGame,
    OutOfPlay,
    InPlay,
  }
  public enum SoundEffect : int {
    SoulWallHit,
    GoalHit,
    SideWallHit,
    WallBroken,
  }
  [System.FlagsAttribute()]
  public enum InputButtons : int {
    MouseClick = 1 << 0,
    RotateMotion = 1 << 1,
    MouseRightClick = 1 << 2,
  }
  public static unsafe partial class FlagsExtensions {
    public static Boolean IsFlagSet(this InputButtons self, InputButtons flag) {
      return (self & flag) == flag;
    }
    public static InputButtons SetFlag(this InputButtons self, InputButtons flag) {
      return self | flag;
    }
    public static InputButtons ClearFlag(this InputButtons self, InputButtons flag) {
      return self & ~flag;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet128 {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[2];
    public const Int32 BitsSize = 128;
    public Int32 Length {
      get {
        return 128;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet128*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 128, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet128 FromArray(UInt64[] values) {
      Assert.Always(2 == values.Length, "Invalid array size", values.Length);
      BitSet128 result = default;
      for (int i = 0; i < 2; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 128);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 128);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 16);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 4463;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 2);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet128*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 2);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet2048 {
    public const Int32 SIZE = 256;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[32];
    public const Int32 BitsSize = 2048;
    public Int32 Length {
      get {
        return 2048;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet2048*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 2048, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet2048 FromArray(UInt64[] values) {
      Assert.Always(32 == values.Length, "Invalid array size", values.Length);
      BitSet2048 result = default;
      for (int i = 0; i < 32; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 2048);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 2048);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 256);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 3319;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 32);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet2048*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 32);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet256 {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[4];
    public const Int32 BitsSize = 256;
    public Int32 Length {
      get {
        return 256;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet256*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 256, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet256 FromArray(UInt64[] values) {
      Assert.Always(4 == values.Length, "Invalid array size", values.Length);
      BitSet256 result = default;
      for (int i = 0; i < 4; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 256);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 256);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 32);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 14057;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 4);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet256*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 4);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet4096 {
    public const Int32 SIZE = 512;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[64];
    public const Int32 BitsSize = 4096;
    public Int32 Length {
      get {
        return 4096;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet4096*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 4096, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet4096 FromArray(UInt64[] values) {
      Assert.Always(64 == values.Length, "Invalid array size", values.Length);
      BitSet4096 result = default;
      for (int i = 0; i < 64; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 4096);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 4096);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 512);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 1433;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 64);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet4096*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 64);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet512 {
    public const Int32 SIZE = 64;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[8];
    public const Int32 BitsSize = 512;
    public Int32 Length {
      get {
        return 512;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet512*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 512, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet512 FromArray(UInt64[] values) {
      Assert.Always(8 == values.Length, "Invalid array size", values.Length);
      BitSet512 result = default;
      for (int i = 0; i < 8; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 512);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 512);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 64);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 17491;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 8);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet512*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 8);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet6 {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[1];
    public const Int32 BitsSize = 6;
    public Int32 Length {
      get {
        return 6;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet6*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 6, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet6 FromArray(UInt64[] values) {
      Assert.Always(1 == values.Length, "Invalid array size", values.Length);
      BitSet6 result = default;
      for (int i = 0; i < 1; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 6);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 6);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 8);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 13669;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 1);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet6*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 1);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [Serializable()]
  public unsafe partial struct GridPosition {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(4)]
    public Int32 Row;
    [FieldOffset(0)]
    public Int32 Col;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 3461;
        hash = hash * 31 + Row.GetHashCode();
        hash = hash * 31 + Col.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (GridPosition*)ptr;
        serializer.Stream.Serialize(&p->Col);
        serializer.Stream.Serialize(&p->Row);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Input {
    public const Int32 SIZE = 56;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(52)]
    private fixed Byte _alignment_padding_[4];
    [FieldOffset(16)]
    public Button MouseClick;
    [FieldOffset(8)]
    public GridPosition MovementPosition;
    [FieldOffset(40)]
    public Button RotateMotion;
    [FieldOffset(0)]
    public FP RotationDirection;
    [FieldOffset(28)]
    public Button MouseRightClick;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 19249;
        hash = hash * 31 + MouseClick.GetHashCode();
        hash = hash * 31 + MovementPosition.GetHashCode();
        hash = hash * 31 + RotateMotion.GetHashCode();
        hash = hash * 31 + RotationDirection.GetHashCode();
        hash = hash * 31 + MouseRightClick.GetHashCode();
        return hash;
      }
    }
    static partial void GetMaxCountCodeGen(ref int maxCount) {
      maxCount = 6;
    }
    public Boolean IsDown(InputButtons button) {
      switch (button) {
        case InputButtons.MouseClick: return MouseClick.IsDown;
        case InputButtons.RotateMotion: return RotateMotion.IsDown;
        case InputButtons.MouseRightClick: return MouseRightClick.IsDown;
        default: return false;
      }
    }
    public Boolean WasPressed(InputButtons button) {
      switch (button) {
        case InputButtons.MouseClick: return MouseClick.WasPressed;
        case InputButtons.RotateMotion: return RotateMotion.WasPressed;
        case InputButtons.MouseRightClick: return MouseRightClick.WasPressed;
        default: return false;
      }
    }
    static partial void SerializeCodeGen(void* ptr, FrameSerializer serializer) {
        var p = (Input*)ptr;
        FP.Serialize(&p->RotationDirection, serializer);
        Quantum.GridPosition.Serialize(&p->MovementPosition, serializer);
        Button.Serialize(&p->MouseClick, serializer);
        Button.Serialize(&p->MouseRightClick, serializer);
        Button.Serialize(&p->RotateMotion, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct PlayerHitBoxLink {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public EntityRef Entity;
    [FieldOffset(8)]
    public FPVector2 Position;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 20173;
        hash = hash * 31 + Entity.GetHashCode();
        hash = hash * 31 + Position.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PlayerHitBoxLink*)ptr;
        EntityRef.Serialize(&p->Entity, serializer);
        FPVector2.Serialize(&p->Position, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [Serializable()]
  public unsafe partial struct PlayerHitBoxTemplate {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(16)]
    public IntVector2 Position;
    [FieldOffset(0)]
    public PlayerCollisionType CollisionType;
    [FieldOffset(8)]
    public FP NormalAngle;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 131;
        hash = hash * 31 + Position.GetHashCode();
        hash = hash * 31 + (Int32)CollisionType;
        hash = hash * 31 + NormalAngle.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PlayerHitBoxTemplate*)ptr;
        serializer.Stream.Serialize((Int32*)&p->CollisionType);
        FP.Serialize(&p->NormalAngle, serializer);
        IntVector2.Serialize(&p->Position, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct _globals_ {
    public const Int32 SIZE = 904;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetRef<Map> Map;
    [FieldOffset(8)]
    public FP DeltaTime;
    [FieldOffset(16)]
    public NavMeshRegionMask NavMeshRegions;
    [FieldOffset(32)]
    public PhysicsEngineState PhysicsState2D;
    [FieldOffset(48)]
    public PhysicsEngineState PhysicsState3D;
    [FieldOffset(64)]
    public RNGSession RngSession;
    [FieldOffset(80)]
    public FrameMetaData FrameMetaData;
    [FieldOffset(128)]
    public BitSet1024 Systems;
    [FieldOffset(256)]
    public PhysicsSceneSettings PhysicsSettings;
    [FieldOffset(552)]
    public Int32 PlayerConnectedCount;
    [FieldOffset(560)]
    [FramePrinter.FixedArrayAttribute(typeof(Input), 6)]
    private fixed Byte _input_[336];
    [FieldOffset(896)]
    public BitSet6 PlayerLastConnectionState;
    public FixedArray<Input> input {
      get {
        fixed (byte* p = _input_) { return new FixedArray<Input>(p, 56, 6); }
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 12473;
        hash = hash * 31 + Map.GetHashCode();
        hash = hash * 31 + DeltaTime.GetHashCode();
        hash = hash * 31 + NavMeshRegions.GetHashCode();
        hash = hash * 31 + PhysicsState2D.GetHashCode();
        hash = hash * 31 + PhysicsState3D.GetHashCode();
        hash = hash * 31 + RngSession.GetHashCode();
        hash = hash * 31 + FrameMetaData.GetHashCode();
        hash = hash * 31 + Systems.GetHashCode();
        hash = hash * 31 + PhysicsSettings.GetHashCode();
        hash = hash * 31 + PlayerConnectedCount.GetHashCode();
        hash = hash * 31 + HashCodeUtils.GetArrayHashCode(input);
        hash = hash * 31 + PlayerLastConnectionState.GetHashCode();
        return hash;
      }
    }
    static partial void SerializeCodeGen(void* ptr, FrameSerializer serializer) {
        var p = (_globals_*)ptr;
        AssetRef.Serialize(&p->Map, serializer);
        FP.Serialize(&p->DeltaTime, serializer);
        NavMeshRegionMask.Serialize(&p->NavMeshRegions, serializer);
        PhysicsEngineState.Serialize(&p->PhysicsState2D, serializer);
        PhysicsEngineState.Serialize(&p->PhysicsState3D, serializer);
        RNGSession.Serialize(&p->RngSession, serializer);
        FrameMetaData.Serialize(&p->FrameMetaData, serializer);
        Quantum.BitSet1024.Serialize(&p->Systems, serializer);
        PhysicsSceneSettings.Serialize(&p->PhysicsSettings, serializer);
        serializer.Stream.Serialize(&p->PlayerConnectedCount);
        FixedArray.Serialize(p->input, serializer, Statics.SerializeInput);
        Quantum.BitSet6.Serialize(&p->PlayerLastConnectionState, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct ArenaBorder : Quantum.IComponent {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public FPVector2 Normal;
    [FieldOffset(0)]
    public FP CollisionMinOffset;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 17551;
        hash = hash * 31 + Normal.GetHashCode();
        hash = hash * 31 + CollisionMinOffset.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (ArenaBorder*)ptr;
        FP.Serialize(&p->CollisionMinOffset, serializer);
        FPVector2.Serialize(&p->Normal, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct GameSession : Quantum.IComponentSingleton {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public GameState state;
    [FieldOffset(8)]
    public FP TimeUntilStart;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 10163;
        hash = hash * 31 + (Int32)state;
        hash = hash * 31 + TimeUntilStart.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (GameSession*)ptr;
        serializer.Stream.Serialize((Int32*)&p->state);
        FP.Serialize(&p->TimeUntilStart, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Goal : Quantum.IComponent {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public AssetRef<GoalConfig> goalConfig;
    [FieldOffset(0)]
    public QBoolean hasTriggered;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 16223;
        hash = hash * 31 + goalConfig.GetHashCode();
        hash = hash * 31 + hasTriggered.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Goal*)ptr;
        QBoolean.Serialize(&p->hasTriggered, serializer);
        AssetRef.Serialize(&p->goalConfig, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct PlayerData : Quantum.IComponent {
    public const Int32 SIZE = 136;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(16)]
    public PlayerRef PlayerRef;
    [FieldOffset(0)]
    public BattlePlayerSlot Slot;
    [FieldOffset(4)]
    public BattleTeamNumber TeamNumber;
    [FieldOffset(12)]
    public Int32 CharacterId;
    [FieldOffset(8)]
    public Int32 CharacterClass;
    [FieldOffset(88)]
    public FP StatHp;
    [FieldOffset(96)]
    public FP StatSpeed;
    [FieldOffset(72)]
    public FP StatCharacterSize;
    [FieldOffset(64)]
    public FP StatAttack;
    [FieldOffset(80)]
    public FP StatDefence;
    [FieldOffset(56)]
    public FP Speed;
    [FieldOffset(120)]
    public FPVector2 TargetPosition;
    [FieldOffset(32)]
    public FP BaseRotation;
    [FieldOffset(48)]
    public FP MovementRotation;
    [FieldOffset(104)]
    public FPVector2 Normal;
    [FieldOffset(40)]
    public FP CollisionMinOffset;
    [FieldOffset(24)]
    [FreeOnComponentRemoved()]
    public QListPtr<PlayerHitBoxLink> PlayerHitboxList;
    [FieldOffset(28)]
    [FreeOnComponentRemoved()]
    public QListPtr<PlayerHitBoxLink> ShieldHitboxList;
    [FieldOffset(20)]
    [FreeOnComponentRemoved()]
    public QListPtr<PlayerHitBoxLink> CharacterHitboxList;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 10271;
        hash = hash * 31 + PlayerRef.GetHashCode();
        hash = hash * 31 + (Int32)Slot;
        hash = hash * 31 + (Int32)TeamNumber;
        hash = hash * 31 + CharacterId.GetHashCode();
        hash = hash * 31 + CharacterClass.GetHashCode();
        hash = hash * 31 + StatHp.GetHashCode();
        hash = hash * 31 + StatSpeed.GetHashCode();
        hash = hash * 31 + StatCharacterSize.GetHashCode();
        hash = hash * 31 + StatAttack.GetHashCode();
        hash = hash * 31 + StatDefence.GetHashCode();
        hash = hash * 31 + Speed.GetHashCode();
        hash = hash * 31 + TargetPosition.GetHashCode();
        hash = hash * 31 + BaseRotation.GetHashCode();
        hash = hash * 31 + MovementRotation.GetHashCode();
        hash = hash * 31 + Normal.GetHashCode();
        hash = hash * 31 + CollisionMinOffset.GetHashCode();
        hash = hash * 31 + PlayerHitboxList.GetHashCode();
        hash = hash * 31 + ShieldHitboxList.GetHashCode();
        hash = hash * 31 + CharacterHitboxList.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      if (PlayerHitboxList != default) f.FreeList(ref PlayerHitboxList);
      if (ShieldHitboxList != default) f.FreeList(ref ShieldHitboxList);
      if (CharacterHitboxList != default) f.FreeList(ref CharacterHitboxList);
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.PlayerData*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PlayerData*)ptr;
        serializer.Stream.Serialize((Int32*)&p->Slot);
        serializer.Stream.Serialize((Int32*)&p->TeamNumber);
        serializer.Stream.Serialize(&p->CharacterClass);
        serializer.Stream.Serialize(&p->CharacterId);
        PlayerRef.Serialize(&p->PlayerRef, serializer);
        QList.Serialize(&p->CharacterHitboxList, serializer, Statics.SerializePlayerHitBoxLink);
        QList.Serialize(&p->PlayerHitboxList, serializer, Statics.SerializePlayerHitBoxLink);
        QList.Serialize(&p->ShieldHitboxList, serializer, Statics.SerializePlayerHitBoxLink);
        FP.Serialize(&p->BaseRotation, serializer);
        FP.Serialize(&p->CollisionMinOffset, serializer);
        FP.Serialize(&p->MovementRotation, serializer);
        FP.Serialize(&p->Speed, serializer);
        FP.Serialize(&p->StatAttack, serializer);
        FP.Serialize(&p->StatCharacterSize, serializer);
        FP.Serialize(&p->StatDefence, serializer);
        FP.Serialize(&p->StatHp, serializer);
        FP.Serialize(&p->StatSpeed, serializer);
        FPVector2.Serialize(&p->Normal, serializer);
        FPVector2.Serialize(&p->TargetPosition, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct PlayerDataTemplate : Quantum.IComponent {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(4)]
    [FreeOnComponentRemoved()]
    public QListPtr<PlayerHitBoxTemplate> ShieldHitboxList;
    [FieldOffset(0)]
    [FreeOnComponentRemoved()]
    public QListPtr<PlayerHitBoxTemplate> CharacterHitboxList;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 181;
        hash = hash * 31 + ShieldHitboxList.GetHashCode();
        hash = hash * 31 + CharacterHitboxList.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      if (ShieldHitboxList != default) f.FreeList(ref ShieldHitboxList);
      if (CharacterHitboxList != default) f.FreeList(ref CharacterHitboxList);
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.PlayerDataTemplate*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PlayerDataTemplate*)ptr;
        QList.Serialize(&p->CharacterHitboxList, serializer, Statics.SerializePlayerHitBoxTemplate);
        QList.Serialize(&p->ShieldHitboxList, serializer, Statics.SerializePlayerHitBoxTemplate);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct PlayerHitBox : Quantum.IComponent {
    public const Int32 SIZE = 40;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public EntityRef PlayerEntity;
    [FieldOffset(4)]
    public PlayerHitboxType HitBoxType;
    [FieldOffset(0)]
    public PlayerCollisionType CollisionType;
    [FieldOffset(24)]
    public FPVector2 Normal;
    [FieldOffset(16)]
    public FP CollisionMinOffset;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 20749;
        hash = hash * 31 + PlayerEntity.GetHashCode();
        hash = hash * 31 + (Int32)HitBoxType;
        hash = hash * 31 + (Int32)CollisionType;
        hash = hash * 31 + Normal.GetHashCode();
        hash = hash * 31 + CollisionMinOffset.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PlayerHitBox*)ptr;
        serializer.Stream.Serialize((Int32*)&p->CollisionType);
        serializer.Stream.Serialize((Int32*)&p->HitBoxType);
        EntityRef.Serialize(&p->PlayerEntity, serializer);
        FP.Serialize(&p->CollisionMinOffset, serializer);
        FPVector2.Serialize(&p->Normal, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct PlayerManagerData : Quantum.IComponentSingleton {
    public const Int32 SIZE = 176;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(16)]
    [FramePrinter.FixedArrayAttribute(typeof(PlayerPlayState), 4)]
    private fixed Byte _PlayStates_[16];
    [FieldOffset(32)]
    [FramePrinter.FixedArrayAttribute(typeof(PlayerRef), 4)]
    private fixed Byte _PlayerRefs_[16];
    [FieldOffset(144)]
    [FramePrinter.FixedArrayAttribute(typeof(EntityRef), 4)]
    private fixed Byte _SelectedCharacters_[32];
    [FieldOffset(48)]
    [FramePrinter.FixedArrayAttribute(typeof(EntityRef), 12)]
    private fixed Byte _AllCharacters_[96];
    [FieldOffset(0)]
    public fixed Int32 SelectedCharacterNumbers[4];
    public FixedArray<PlayerPlayState> PlayStates {
      get {
        fixed (byte* p = _PlayStates_) { return new FixedArray<PlayerPlayState>(p, 4, 4); }
      }
    }
    public FixedArray<PlayerRef> PlayerRefs {
      get {
        fixed (byte* p = _PlayerRefs_) { return new FixedArray<PlayerRef>(p, 4, 4); }
      }
    }
    public FixedArray<EntityRef> SelectedCharacters {
      get {
        fixed (byte* p = _SelectedCharacters_) { return new FixedArray<EntityRef>(p, 8, 4); }
      }
    }
    public FixedArray<EntityRef> AllCharacters {
      get {
        fixed (byte* p = _AllCharacters_) { return new FixedArray<EntityRef>(p, 8, 12); }
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 19913;
        hash = hash * 31 + HashCodeUtils.GetArrayHashCode(PlayStates);
        hash = hash * 31 + HashCodeUtils.GetArrayHashCode(PlayerRefs);
        hash = hash * 31 + HashCodeUtils.GetArrayHashCode(SelectedCharacters);
        hash = hash * 31 + HashCodeUtils.GetArrayHashCode(AllCharacters);
        fixed (Int32* p = SelectedCharacterNumbers) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 4);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PlayerManagerData*)ptr;
        serializer.Stream.SerializeBuffer(&p->SelectedCharacterNumbers[0], 4);
        FixedArray.Serialize(p->PlayStates, serializer, Statics.SerializePlayerPlayState);
        FixedArray.Serialize(p->PlayerRefs, serializer, Statics.SerializePlayerRef);
        FixedArray.Serialize(p->AllCharacters, serializer, Statics.SerializeEntityRef);
        FixedArray.Serialize(p->SelectedCharacters, serializer, Statics.SerializeEntityRef);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Projectile : Quantum.IComponent {
    public const Int32 SIZE = 48;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(4)]
    public QBoolean IsLaunched;
    [FieldOffset(24)]
    public FP Speed;
    [FieldOffset(32)]
    public FPVector2 Direction;
    [FieldOffset(8)]
    public FP CoolDown;
    [FieldOffset(16)]
    public FP Radius;
    [FieldOffset(0)]
    public Int32 TestSpriteIndex;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 16141;
        hash = hash * 31 + IsLaunched.GetHashCode();
        hash = hash * 31 + Speed.GetHashCode();
        hash = hash * 31 + Direction.GetHashCode();
        hash = hash * 31 + CoolDown.GetHashCode();
        hash = hash * 31 + Radius.GetHashCode();
        hash = hash * 31 + TestSpriteIndex.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Projectile*)ptr;
        serializer.Stream.Serialize(&p->TestSpriteIndex);
        QBoolean.Serialize(&p->IsLaunched, serializer);
        FP.Serialize(&p->CoolDown, serializer);
        FP.Serialize(&p->Radius, serializer);
        FP.Serialize(&p->Speed, serializer);
        FPVector2.Serialize(&p->Direction, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct ProjectileSpawner : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public QBoolean HasSpawned;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 1693;
        hash = hash * 31 + HasSpawned.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (ProjectileSpawner*)ptr;
        QBoolean.Serialize(&p->HasSpawned, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct SoulWall : Quantum.IComponent {
    public const Int32 SIZE = 40;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public EntityRef ChildEntity;
    [FieldOffset(24)]
    public FPVector2 Normal;
    [FieldOffset(16)]
    public FP CollisionMinOffset;
    [FieldOffset(0)]
    public Int32 Layer;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 10253;
        hash = hash * 31 + ChildEntity.GetHashCode();
        hash = hash * 31 + Normal.GetHashCode();
        hash = hash * 31 + CollisionMinOffset.GetHashCode();
        hash = hash * 31 + Layer.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (SoulWall*)ptr;
        serializer.Stream.Serialize(&p->Layer);
        EntityRef.Serialize(&p->ChildEntity, serializer);
        FP.Serialize(&p->CollisionMinOffset, serializer);
        FPVector2.Serialize(&p->Normal, serializer);
    }
  }
  public unsafe partial interface ISignalOnCollisionProjectileHitSoulWall : ISignal {
    void OnCollisionProjectileHitSoulWall(Frame f, CollisionInfo2D info, Projectile* projectile, SoulWall* soulWall);
  }
  public unsafe partial interface ISignalOnCollisionProjectileHitGoal : ISignal {
    void OnCollisionProjectileHitGoal(Frame f, CollisionInfo2D info, Projectile* projectile, Goal* goal);
  }
  public unsafe partial interface ISignalOnCollisionProjectileHitSomething : ISignal {
    void OnCollisionProjectileHitSomething(Frame f, CollisionInfo2D info, Projectile* projectile);
  }
  public unsafe partial interface ISignalOnTriggerTopGoal : ISignal {
    void OnTriggerTopGoal(Frame f);
  }
  public unsafe partial interface ISignalOnTriggerBottomGoal : ISignal {
    void OnTriggerBottomGoal(Frame f);
  }
  public unsafe partial interface ISignalOnTriggerProjectileHitSoulWall : ISignal {
    void OnTriggerProjectileHitSoulWall(Frame f, Projectile* projectile, EntityRef projectileEntity, SoulWall* soulWall, EntityRef soulWallEntity);
  }
  public unsafe partial interface ISignalOnTriggerProjectileHitArenaBorder : ISignal {
    void OnTriggerProjectileHitArenaBorder(Frame f, Projectile* projectile, EntityRef projectileEntity, ArenaBorder* arenaBorder, EntityRef arenaBorderEntity);
  }
  public unsafe partial interface ISignalOnTriggerProjectileHitPlayerHitbox : ISignal {
    void OnTriggerProjectileHitPlayerHitbox(Frame f, Projectile* projectile, EntityRef projectileEntity, PlayerHitBox* playerHitBox, EntityRef playerEntity);
  }
  public unsafe partial interface ISignalOnTriggerProjectileHitPlayer : ISignal {
    void OnTriggerProjectileHitPlayer(Frame f, Projectile* projectile, EntityRef projectileEntity, PlayerData* playerData, EntityRef playerEntity);
  }
  public static unsafe partial class Constants {
    public const Int32 PLAYER_SLOT_COUNT = 4;
    public const Int32 PLAYER_CHARACTER_COUNT = 3;
    public const Int32 PLAYER_CHARACTER_TOTAL_COUNT = 12;
  }
  public unsafe partial class Frame {
    private ISignalOnCollisionProjectileHitSoulWall[] _ISignalOnCollisionProjectileHitSoulWallSystems;
    private ISignalOnCollisionProjectileHitGoal[] _ISignalOnCollisionProjectileHitGoalSystems;
    private ISignalOnCollisionProjectileHitSomething[] _ISignalOnCollisionProjectileHitSomethingSystems;
    private ISignalOnTriggerTopGoal[] _ISignalOnTriggerTopGoalSystems;
    private ISignalOnTriggerBottomGoal[] _ISignalOnTriggerBottomGoalSystems;
    private ISignalOnTriggerProjectileHitSoulWall[] _ISignalOnTriggerProjectileHitSoulWallSystems;
    private ISignalOnTriggerProjectileHitArenaBorder[] _ISignalOnTriggerProjectileHitArenaBorderSystems;
    private ISignalOnTriggerProjectileHitPlayerHitbox[] _ISignalOnTriggerProjectileHitPlayerHitboxSystems;
    private ISignalOnTriggerProjectileHitPlayer[] _ISignalOnTriggerProjectileHitPlayerSystems;
    partial void AllocGen() {
      _globals = (_globals_*)Context.Allocator.AllocAndClear(sizeof(_globals_));
    }
    partial void FreeGen() {
      Context.Allocator.Free(_globals);
    }
    partial void CopyFromGen(Frame frame) {
      Native.Utils.Copy(_globals, frame._globals, sizeof(_globals_));
    }
    partial void InitGen() {
      Initialize(this, this.SimulationConfig.Entities, 256);
      _ISignalOnCollisionProjectileHitSoulWallSystems = BuildSignalsArray<ISignalOnCollisionProjectileHitSoulWall>();
      _ISignalOnCollisionProjectileHitGoalSystems = BuildSignalsArray<ISignalOnCollisionProjectileHitGoal>();
      _ISignalOnCollisionProjectileHitSomethingSystems = BuildSignalsArray<ISignalOnCollisionProjectileHitSomething>();
      _ISignalOnTriggerTopGoalSystems = BuildSignalsArray<ISignalOnTriggerTopGoal>();
      _ISignalOnTriggerBottomGoalSystems = BuildSignalsArray<ISignalOnTriggerBottomGoal>();
      _ISignalOnTriggerProjectileHitSoulWallSystems = BuildSignalsArray<ISignalOnTriggerProjectileHitSoulWall>();
      _ISignalOnTriggerProjectileHitArenaBorderSystems = BuildSignalsArray<ISignalOnTriggerProjectileHitArenaBorder>();
      _ISignalOnTriggerProjectileHitPlayerHitboxSystems = BuildSignalsArray<ISignalOnTriggerProjectileHitPlayerHitbox>();
      _ISignalOnTriggerProjectileHitPlayerSystems = BuildSignalsArray<ISignalOnTriggerProjectileHitPlayer>();
      _ComponentSignalsOnAdded = new ComponentReactiveCallbackInvoker[ComponentTypeId.Type.Length];
      _ComponentSignalsOnRemoved = new ComponentReactiveCallbackInvoker[ComponentTypeId.Type.Length];
      BuildSignalsArrayOnComponentAdded<Quantum.ArenaBorder>();
      BuildSignalsArrayOnComponentRemoved<Quantum.ArenaBorder>();
      BuildSignalsArrayOnComponentAdded<CharacterController2D>();
      BuildSignalsArrayOnComponentRemoved<CharacterController2D>();
      BuildSignalsArrayOnComponentAdded<CharacterController3D>();
      BuildSignalsArrayOnComponentRemoved<CharacterController3D>();
      BuildSignalsArrayOnComponentAdded<Quantum.GameSession>();
      BuildSignalsArrayOnComponentRemoved<Quantum.GameSession>();
      BuildSignalsArrayOnComponentAdded<Quantum.Goal>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Goal>();
      BuildSignalsArrayOnComponentAdded<MapEntityLink>();
      BuildSignalsArrayOnComponentRemoved<MapEntityLink>();
      BuildSignalsArrayOnComponentAdded<NavMeshAvoidanceAgent>();
      BuildSignalsArrayOnComponentRemoved<NavMeshAvoidanceAgent>();
      BuildSignalsArrayOnComponentAdded<NavMeshAvoidanceObstacle>();
      BuildSignalsArrayOnComponentRemoved<NavMeshAvoidanceObstacle>();
      BuildSignalsArrayOnComponentAdded<NavMeshPathfinder>();
      BuildSignalsArrayOnComponentRemoved<NavMeshPathfinder>();
      BuildSignalsArrayOnComponentAdded<NavMeshSteeringAgent>();
      BuildSignalsArrayOnComponentRemoved<NavMeshSteeringAgent>();
      BuildSignalsArrayOnComponentAdded<PhysicsBody2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsBody2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsBody3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsBody3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCallbacks2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCallbacks2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCallbacks3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCallbacks3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCollider2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCollider2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCollider3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCollider3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsJoints2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsJoints2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsJoints3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsJoints3D>();
      BuildSignalsArrayOnComponentAdded<Quantum.PlayerData>();
      BuildSignalsArrayOnComponentRemoved<Quantum.PlayerData>();
      BuildSignalsArrayOnComponentAdded<Quantum.PlayerDataTemplate>();
      BuildSignalsArrayOnComponentRemoved<Quantum.PlayerDataTemplate>();
      BuildSignalsArrayOnComponentAdded<Quantum.PlayerHitBox>();
      BuildSignalsArrayOnComponentRemoved<Quantum.PlayerHitBox>();
      BuildSignalsArrayOnComponentAdded<Quantum.PlayerManagerData>();
      BuildSignalsArrayOnComponentRemoved<Quantum.PlayerManagerData>();
      BuildSignalsArrayOnComponentAdded<Quantum.Projectile>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Projectile>();
      BuildSignalsArrayOnComponentAdded<Quantum.ProjectileSpawner>();
      BuildSignalsArrayOnComponentRemoved<Quantum.ProjectileSpawner>();
      BuildSignalsArrayOnComponentAdded<Quantum.SoulWall>();
      BuildSignalsArrayOnComponentRemoved<Quantum.SoulWall>();
      BuildSignalsArrayOnComponentAdded<Transform2D>();
      BuildSignalsArrayOnComponentRemoved<Transform2D>();
      BuildSignalsArrayOnComponentAdded<Transform2DVertical>();
      BuildSignalsArrayOnComponentRemoved<Transform2DVertical>();
      BuildSignalsArrayOnComponentAdded<Transform3D>();
      BuildSignalsArrayOnComponentRemoved<Transform3D>();
      BuildSignalsArrayOnComponentAdded<View>();
      BuildSignalsArrayOnComponentRemoved<View>();
    }
    partial void SetPlayerInputCodeGen(PlayerRef player, Input input) {
      if ((int)player >= (int)_globals->input.Length) { throw new System.ArgumentOutOfRangeException("player"); }
      var i = _globals->input.GetPointer(player);
      i->MouseClick = i->MouseClick.Update(this.Number, input.MouseClick);
      i->MovementPosition = input.MovementPosition;
      i->RotateMotion = i->RotateMotion.Update(this.Number, input.RotateMotion);
      i->RotationDirection = input.RotationDirection;
      i->MouseRightClick = i->MouseRightClick.Update(this.Number, input.MouseRightClick);
    }
    public Input* GetPlayerInput(PlayerRef player) {
      if ((int)player >= (int)_globals->input.Length) { throw new System.ArgumentOutOfRangeException("player"); }
      return _globals->input.GetPointer(player);
    }
    partial void GetPlayerLastConnectionStateCodeGen(ref BitSetRef bitSet) {
      bitSet = new(_globals->PlayerLastConnectionState.Bits, _globals->PlayerLastConnectionState.Length);
    }
    partial void ResetPhysicsCodeGen() {
      if (Context.Physics2D != null && Physics2D.Map != null && Physics2D.Map.Guid.IsDynamic) Physics2D.ResetMap();
      Physics2D.Init(_globals->PhysicsState2D.MapStaticCollidersState.TrackedMap);
      if (Context.Physics3D != null && Physics3D.Map != null && Physics3D.Map.Guid.IsDynamic) Physics3D.ResetMap();
      Physics3D.Init(_globals->PhysicsState3D.MapStaticCollidersState.TrackedMap);
    }
    public unsafe partial struct FrameSignals {
      public void OnCollisionProjectileHitSoulWall(CollisionInfo2D info, Projectile* projectile, SoulWall* soulWall) {
        var array = _f._ISignalOnCollisionProjectileHitSoulWallSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnCollisionProjectileHitSoulWall(_f, info, projectile, soulWall);
          }
        }
      }
      public void OnCollisionProjectileHitGoal(CollisionInfo2D info, Projectile* projectile, Goal* goal) {
        var array = _f._ISignalOnCollisionProjectileHitGoalSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnCollisionProjectileHitGoal(_f, info, projectile, goal);
          }
        }
      }
      public void OnCollisionProjectileHitSomething(CollisionInfo2D info, Projectile* projectile) {
        var array = _f._ISignalOnCollisionProjectileHitSomethingSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnCollisionProjectileHitSomething(_f, info, projectile);
          }
        }
      }
      public void OnTriggerTopGoal() {
        var array = _f._ISignalOnTriggerTopGoalSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnTriggerTopGoal(_f);
          }
        }
      }
      public void OnTriggerBottomGoal() {
        var array = _f._ISignalOnTriggerBottomGoalSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnTriggerBottomGoal(_f);
          }
        }
      }
      public void OnTriggerProjectileHitSoulWall(Projectile* projectile, EntityRef projectileEntity, SoulWall* soulWall, EntityRef soulWallEntity) {
        var array = _f._ISignalOnTriggerProjectileHitSoulWallSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnTriggerProjectileHitSoulWall(_f, projectile, projectileEntity, soulWall, soulWallEntity);
          }
        }
      }
      public void OnTriggerProjectileHitArenaBorder(Projectile* projectile, EntityRef projectileEntity, ArenaBorder* arenaBorder, EntityRef arenaBorderEntity) {
        var array = _f._ISignalOnTriggerProjectileHitArenaBorderSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnTriggerProjectileHitArenaBorder(_f, projectile, projectileEntity, arenaBorder, arenaBorderEntity);
          }
        }
      }
      public void OnTriggerProjectileHitPlayerHitbox(Projectile* projectile, EntityRef projectileEntity, PlayerHitBox* playerHitBox, EntityRef playerEntity) {
        var array = _f._ISignalOnTriggerProjectileHitPlayerHitboxSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnTriggerProjectileHitPlayerHitbox(_f, projectile, projectileEntity, playerHitBox, playerEntity);
          }
        }
      }
      public void OnTriggerProjectileHitPlayer(Projectile* projectile, EntityRef projectileEntity, PlayerData* playerData, EntityRef playerEntity) {
        var array = _f._ISignalOnTriggerProjectileHitPlayerSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnTriggerProjectileHitPlayer(_f, projectile, projectileEntity, playerData, playerEntity);
          }
        }
      }
    }
  }
  public unsafe partial class Statics {
    public static FrameSerializer.Delegate SerializePlayerHitBoxLink;
    public static FrameSerializer.Delegate SerializePlayerHitBoxTemplate;
    public static FrameSerializer.Delegate SerializeEntityRef;
    public static FrameSerializer.Delegate SerializePlayerPlayState;
    public static FrameSerializer.Delegate SerializePlayerRef;
    public static FrameSerializer.Delegate SerializeInput;
    static partial void InitStaticDelegatesGen() {
      SerializePlayerHitBoxLink = Quantum.PlayerHitBoxLink.Serialize;
      SerializePlayerHitBoxTemplate = Quantum.PlayerHitBoxTemplate.Serialize;
      SerializeEntityRef = EntityRef.Serialize;
      SerializePlayerPlayState = (v, s) => {{ s.Stream.Serialize((Int32*)v); }};
      SerializePlayerRef = PlayerRef.Serialize;
      SerializeInput = Quantum.Input.Serialize;
    }
    static partial void RegisterSimulationTypesGen(TypeRegistry typeRegistry) {
      typeRegistry.Register(typeof(Quantum.ArenaBorder), Quantum.ArenaBorder.SIZE);
      typeRegistry.Register(typeof(AssetGuid), AssetGuid.SIZE);
      typeRegistry.Register(typeof(AssetRef), AssetRef.SIZE);
      typeRegistry.Register(typeof(Quantum.BattlePlayerSlot), 4);
      typeRegistry.Register(typeof(Quantum.BattleTeamNumber), 4);
      typeRegistry.Register(typeof(Quantum.BitSet1024), Quantum.BitSet1024.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet128), Quantum.BitSet128.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet2048), Quantum.BitSet2048.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet256), Quantum.BitSet256.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet4096), Quantum.BitSet4096.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet512), Quantum.BitSet512.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet6), Quantum.BitSet6.SIZE);
      typeRegistry.Register(typeof(Button), Button.SIZE);
      typeRegistry.Register(typeof(CallbackFlags), 4);
      typeRegistry.Register(typeof(CharacterController2D), CharacterController2D.SIZE);
      typeRegistry.Register(typeof(CharacterController3D), CharacterController3D.SIZE);
      typeRegistry.Register(typeof(ColorRGBA), ColorRGBA.SIZE);
      typeRegistry.Register(typeof(ComponentPrototypeRef), ComponentPrototypeRef.SIZE);
      typeRegistry.Register(typeof(ComponentTypeRef), ComponentTypeRef.SIZE);
      typeRegistry.Register(typeof(DistanceJoint), DistanceJoint.SIZE);
      typeRegistry.Register(typeof(DistanceJoint3D), DistanceJoint3D.SIZE);
      typeRegistry.Register(typeof(EntityPrototypeRef), EntityPrototypeRef.SIZE);
      typeRegistry.Register(typeof(EntityRef), EntityRef.SIZE);
      typeRegistry.Register(typeof(FP), FP.SIZE);
      typeRegistry.Register(typeof(FPBounds2), FPBounds2.SIZE);
      typeRegistry.Register(typeof(FPBounds3), FPBounds3.SIZE);
      typeRegistry.Register(typeof(FPMatrix2x2), FPMatrix2x2.SIZE);
      typeRegistry.Register(typeof(FPMatrix3x3), FPMatrix3x3.SIZE);
      typeRegistry.Register(typeof(FPMatrix4x4), FPMatrix4x4.SIZE);
      typeRegistry.Register(typeof(FPQuaternion), FPQuaternion.SIZE);
      typeRegistry.Register(typeof(FPVector2), FPVector2.SIZE);
      typeRegistry.Register(typeof(FPVector3), FPVector3.SIZE);
      typeRegistry.Register(typeof(FrameMetaData), FrameMetaData.SIZE);
      typeRegistry.Register(typeof(FrameTimer), FrameTimer.SIZE);
      typeRegistry.Register(typeof(Quantum.GameSession), Quantum.GameSession.SIZE);
      typeRegistry.Register(typeof(Quantum.GameState), 4);
      typeRegistry.Register(typeof(Quantum.Goal), Quantum.Goal.SIZE);
      typeRegistry.Register(typeof(Quantum.GridPosition), Quantum.GridPosition.SIZE);
      typeRegistry.Register(typeof(HingeJoint), HingeJoint.SIZE);
      typeRegistry.Register(typeof(HingeJoint3D), HingeJoint3D.SIZE);
      typeRegistry.Register(typeof(Hit), Hit.SIZE);
      typeRegistry.Register(typeof(Hit3D), Hit3D.SIZE);
      typeRegistry.Register(typeof(Quantum.Input), Quantum.Input.SIZE);
      typeRegistry.Register(typeof(Quantum.InputButtons), 4);
      typeRegistry.Register(typeof(IntVector2), IntVector2.SIZE);
      typeRegistry.Register(typeof(IntVector3), IntVector3.SIZE);
      typeRegistry.Register(typeof(Joint), Joint.SIZE);
      typeRegistry.Register(typeof(Joint3D), Joint3D.SIZE);
      typeRegistry.Register(typeof(LayerMask), LayerMask.SIZE);
      typeRegistry.Register(typeof(MapEntityId), MapEntityId.SIZE);
      typeRegistry.Register(typeof(MapEntityLink), MapEntityLink.SIZE);
      typeRegistry.Register(typeof(NavMeshAvoidanceAgent), NavMeshAvoidanceAgent.SIZE);
      typeRegistry.Register(typeof(NavMeshAvoidanceObstacle), NavMeshAvoidanceObstacle.SIZE);
      typeRegistry.Register(typeof(NavMeshPathfinder), NavMeshPathfinder.SIZE);
      typeRegistry.Register(typeof(NavMeshRegionMask), NavMeshRegionMask.SIZE);
      typeRegistry.Register(typeof(NavMeshSteeringAgent), NavMeshSteeringAgent.SIZE);
      typeRegistry.Register(typeof(NullableFP), NullableFP.SIZE);
      typeRegistry.Register(typeof(NullableFPVector2), NullableFPVector2.SIZE);
      typeRegistry.Register(typeof(NullableFPVector3), NullableFPVector3.SIZE);
      typeRegistry.Register(typeof(NullableNonNegativeFP), NullableNonNegativeFP.SIZE);
      typeRegistry.Register(typeof(PhysicsBody2D), PhysicsBody2D.SIZE);
      typeRegistry.Register(typeof(PhysicsBody3D), PhysicsBody3D.SIZE);
      typeRegistry.Register(typeof(PhysicsCallbacks2D), PhysicsCallbacks2D.SIZE);
      typeRegistry.Register(typeof(PhysicsCallbacks3D), PhysicsCallbacks3D.SIZE);
      typeRegistry.Register(typeof(PhysicsCollider2D), PhysicsCollider2D.SIZE);
      typeRegistry.Register(typeof(PhysicsCollider3D), PhysicsCollider3D.SIZE);
      typeRegistry.Register(typeof(PhysicsEngineState), PhysicsEngineState.SIZE);
      typeRegistry.Register(typeof(PhysicsJoints2D), PhysicsJoints2D.SIZE);
      typeRegistry.Register(typeof(PhysicsJoints3D), PhysicsJoints3D.SIZE);
      typeRegistry.Register(typeof(PhysicsQueryRef), PhysicsQueryRef.SIZE);
      typeRegistry.Register(typeof(PhysicsSceneSettings), PhysicsSceneSettings.SIZE);
      typeRegistry.Register(typeof(Quantum.PlayerCollisionType), 4);
      typeRegistry.Register(typeof(Quantum.PlayerData), Quantum.PlayerData.SIZE);
      typeRegistry.Register(typeof(Quantum.PlayerDataTemplate), Quantum.PlayerDataTemplate.SIZE);
      typeRegistry.Register(typeof(Quantum.PlayerHitBox), Quantum.PlayerHitBox.SIZE);
      typeRegistry.Register(typeof(Quantum.PlayerHitBoxLink), Quantum.PlayerHitBoxLink.SIZE);
      typeRegistry.Register(typeof(Quantum.PlayerHitBoxTemplate), Quantum.PlayerHitBoxTemplate.SIZE);
      typeRegistry.Register(typeof(Quantum.PlayerHitboxType), 4);
      typeRegistry.Register(typeof(Quantum.PlayerManagerData), Quantum.PlayerManagerData.SIZE);
      typeRegistry.Register(typeof(Quantum.PlayerPlayState), 4);
      typeRegistry.Register(typeof(PlayerRef), PlayerRef.SIZE);
      typeRegistry.Register(typeof(Quantum.Projectile), Quantum.Projectile.SIZE);
      typeRegistry.Register(typeof(Quantum.ProjectileSpawner), Quantum.ProjectileSpawner.SIZE);
      typeRegistry.Register(typeof(Ptr), Ptr.SIZE);
      typeRegistry.Register(typeof(QBoolean), QBoolean.SIZE);
      typeRegistry.Register(typeof(Quantum.Ptr), Quantum.Ptr.SIZE);
      typeRegistry.Register(typeof(QueryOptions), 2);
      typeRegistry.Register(typeof(RNGSession), RNGSession.SIZE);
      typeRegistry.Register(typeof(Shape2D), Shape2D.SIZE);
      typeRegistry.Register(typeof(Shape3D), Shape3D.SIZE);
      typeRegistry.Register(typeof(Quantum.SoulWall), Quantum.SoulWall.SIZE);
      typeRegistry.Register(typeof(Quantum.SoundEffect), 4);
      typeRegistry.Register(typeof(SpringJoint), SpringJoint.SIZE);
      typeRegistry.Register(typeof(SpringJoint3D), SpringJoint3D.SIZE);
      typeRegistry.Register(typeof(Transform2D), Transform2D.SIZE);
      typeRegistry.Register(typeof(Transform2DVertical), Transform2DVertical.SIZE);
      typeRegistry.Register(typeof(Transform3D), Transform3D.SIZE);
      typeRegistry.Register(typeof(View), View.SIZE);
      typeRegistry.Register(typeof(Quantum._globals_), Quantum._globals_.SIZE);
    }
    static partial void InitComponentTypeIdGen() {
      ComponentTypeId.Reset(ComponentTypeId.BuiltInComponentCount + 10)
        .AddBuiltInComponents()
        .Add<Quantum.ArenaBorder>(Quantum.ArenaBorder.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.GameSession>(Quantum.GameSession.Serialize, null, null, ComponentFlags.Singleton)
        .Add<Quantum.Goal>(Quantum.Goal.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.PlayerData>(Quantum.PlayerData.Serialize, null, Quantum.PlayerData.OnRemoved, ComponentFlags.None)
        .Add<Quantum.PlayerDataTemplate>(Quantum.PlayerDataTemplate.Serialize, null, Quantum.PlayerDataTemplate.OnRemoved, ComponentFlags.None)
        .Add<Quantum.PlayerHitBox>(Quantum.PlayerHitBox.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.PlayerManagerData>(Quantum.PlayerManagerData.Serialize, null, null, ComponentFlags.Singleton)
        .Add<Quantum.Projectile>(Quantum.Projectile.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.ProjectileSpawner>(Quantum.ProjectileSpawner.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.SoulWall>(Quantum.SoulWall.Serialize, null, null, ComponentFlags.None)
        .Finish();
    }
    [Preserve()]
    public static void EnsureNotStrippedGen() {
      FramePrinter.EnsureNotStripped();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.BattlePlayerSlot>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.BattleTeamNumber>();
      FramePrinter.EnsurePrimitiveNotStripped<CallbackFlags>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.GameState>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.InputButtons>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.PlayerCollisionType>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.PlayerHitboxType>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.PlayerPlayState>();
      FramePrinter.EnsurePrimitiveNotStripped<QueryOptions>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.SoundEffect>();
    }
  }
}
#pragma warning restore 0109
#pragma warning restore 1591
